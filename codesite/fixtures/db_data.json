[{"model": "admin.logentry", "pk": 1, "fields": {"action_time": "2024-04-19T14:40:49.455Z", "user": 1, "content_type": 25, "object_id": "1", "object_repr": "Array", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 2, "fields": {"action_time": "2024-04-19T14:44:16.766Z", "user": 1, "content_type": 26, "object_id": "1", "object_repr": "1. Two Sum", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 3, "fields": {"action_time": "2024-04-19T14:52:36.202Z", "user": 1, "content_type": 26, "object_id": "2", "object_repr": "167. Two Sum II - Input Array Is Sorted", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 4, "fields": {"action_time": "2024-04-19T14:54:12.944Z", "user": 1, "content_type": 26, "object_id": "2", "object_repr": "167. Two Sum II - Input Array Is Sorted", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Testcase\"]}}]"}}, {"model": "admin.logentry", "pk": 5, "fields": {"action_time": "2024-04-19T14:54:46.941Z", "user": 1, "content_type": 26, "object_id": "1", "object_repr": "1. Two Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solution\", \"Testcase\"]}}]"}}, {"model": "admin.logentry", "pk": 6, "fields": {"action_time": "2024-04-19T14:56:57.212Z", "user": 1, "content_type": 25, "object_id": "6", "object_repr": "String", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 7, "fields": {"action_time": "2024-04-19T14:57:02.136Z", "user": 1, "content_type": 25, "object_id": "7", "object_repr": "Stack", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 8, "fields": {"action_time": "2024-04-19T14:57:37.458Z", "user": 1, "content_type": 26, "object_id": "3", "object_repr": "20. Valid Parentheses", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 9, "fields": {"action_time": "2024-04-19T14:58:06.512Z", "user": 1, "content_type": 26, "object_id": "3", "object_repr": "20. Valid Parentheses", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Is solved\", \"Solution\", \"Testcase\"]}}]"}}, {"model": "admin.logentry", "pk": 10, "fields": {"action_time": "2024-04-19T15:39:51.844Z", "user": 1, "content_type": 26, "object_id": "4", "object_repr": "# Directions Reduction", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 11, "fields": {"action_time": "2024-04-19T15:40:03.598Z", "user": 1, "content_type": 26, "object_id": "4", "object_repr": "Directions Reduction", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Title\"]}}]"}}, {"model": "admin.logentry", "pk": 12, "fields": {"action_time": "2024-04-20T21:32:58.437Z", "user": 1, "content_type": 26, "object_id": "5", "object_repr": "125. Valid Palindrome", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 13, "fields": {"action_time": "2024-04-21T14:06:30.631Z", "user": 1, "content_type": 25, "object_id": "9", "object_repr": "String", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 14, "fields": {"action_time": "2024-04-21T14:32:19.516Z", "user": 1, "content_type": 26, "object_id": "7", "object_repr": "1221. Split a String in Balanced Strings", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Description\"]}}]"}}, {"model": "admin.logentry", "pk": 15, "fields": {"action_time": "2024-04-21T14:35:02.021Z", "user": 1, "content_type": 26, "object_id": "1", "object_repr": "1. Two Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solution\"]}}]"}}, {"model": "admin.logentry", "pk": 16, "fields": {"action_time": "2024-04-23T11:57:40.520Z", "user": 1, "content_type": 22, "object_id": "2", "object_repr": "krzysztof", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 17, "fields": {"action_time": "2024-04-23T12:59:22.454Z", "user": 1, "content_type": 26, "object_id": "7", "object_repr": "Split a String in Balanced Strings", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Title\"]}}]"}}, {"model": "admin.logentry", "pk": 18, "fields": {"action_time": "2024-04-23T12:59:30.001Z", "user": 1, "content_type": 26, "object_id": "6", "object_repr": "Valid Palindrome", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Title\"]}}]"}}, {"model": "admin.logentry", "pk": 19, "fields": {"action_time": "2024-04-23T12:59:37.553Z", "user": 1, "content_type": 26, "object_id": "3", "object_repr": "Valid Parentheses", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Title\"]}}]"}}, {"model": "admin.logentry", "pk": 20, "fields": {"action_time": "2024-04-23T12:59:44.286Z", "user": 1, "content_type": 26, "object_id": "2", "object_repr": "Two Sum II - Input Array Is Sorted", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Title\"]}}]"}}, {"model": "admin.logentry", "pk": 21, "fields": {"action_time": "2024-04-23T12:59:52.411Z", "user": 1, "content_type": 26, "object_id": "1", "object_repr": "Two Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Title\"]}}]"}}, {"model": "admin.logentry", "pk": 22, "fields": {"action_time": "2024-04-23T15:32:17.011Z", "user": 1, "content_type": 26, "object_id": "8", "object_repr": "Sum of Pairs", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 23, "fields": {"action_time": "2024-04-24T13:19:47.573Z", "user": 1, "content_type": 26, "object_id": "6", "object_repr": "Valid Palindrome", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solution\"]}}]"}}, {"model": "admin.logentry", "pk": 24, "fields": {"action_time": "2024-04-24T13:22:44.360Z", "user": 1, "content_type": 26, "object_id": "6", "object_repr": "Valid Palindrome", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solution\"]}}]"}}, {"model": "admin.logentry", "pk": 25, "fields": {"action_time": "2024-04-29T21:00:40.269Z", "user": 1, "content_type": 25, "object_id": "16", "object_repr": "Easy", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 26, "fields": {"action_time": "2024-04-29T21:00:57.685Z", "user": 1, "content_type": 25, "object_id": "16", "object_repr": "Easy", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 27, "fields": {"action_time": "2024-04-29T21:01:04.316Z", "user": 1, "content_type": 34, "object_id": "1", "object_repr": "Easy", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 28, "fields": {"action_time": "2024-04-29T21:01:15.054Z", "user": 1, "content_type": 34, "object_id": "2", "object_repr": "Medium", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 29, "fields": {"action_time": "2024-04-29T21:01:19.981Z", "user": 1, "content_type": 34, "object_id": "3", "object_repr": "Hard", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 30, "fields": {"action_time": "2024-04-29T21:02:36.812Z", "user": 1, "content_type": 34, "object_id": "4", "object_repr": "Impossible", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 31, "fields": {"action_time": "2024-04-29T21:14:14.669Z", "user": 1, "content_type": 34, "object_id": "5", "object_repr": "Easy", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 32, "fields": {"action_time": "2024-04-29T21:14:25.639Z", "user": 1, "content_type": 34, "object_id": "5", "object_repr": "Easy", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 33, "fields": {"action_time": "2024-04-30T11:00:17.903Z", "user": 1, "content_type": 36, "object_id": "1", "object_repr": "Easy", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 34, "fields": {"action_time": "2024-04-30T11:00:29.357Z", "user": 1, "content_type": 36, "object_id": "2", "object_repr": "Medium", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 35, "fields": {"action_time": "2024-04-30T11:00:43.824Z", "user": 1, "content_type": 36, "object_id": "3", "object_repr": "Hard", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 36, "fields": {"action_time": "2024-04-30T11:01:24.131Z", "user": 1, "content_type": 35, "object_id": "1", "object_repr": "Database", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 37, "fields": {"action_time": "2024-04-30T11:06:20.578Z", "user": 1, "content_type": 37, "object_id": "1", "object_repr": "Combine Two Tables", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 38, "fields": {"action_time": "2024-05-08T21:42:19.427Z", "user": 1, "content_type": 38, "object_id": "1", "object_repr": "O(1)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 39, "fields": {"action_time": "2024-05-08T21:42:27.811Z", "user": 1, "content_type": 38, "object_id": "2", "object_repr": "O(n)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 40, "fields": {"action_time": "2024-05-08T21:59:42.067Z", "user": 1, "content_type": 26, "object_id": "2", "object_repr": "Two Sum II - Input Array Is Sorted", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Space complexity\", \"Solution\"]}}]"}}, {"model": "admin.logentry", "pk": 41, "fields": {"action_time": "2024-05-08T22:01:17.514Z", "user": 1, "content_type": 26, "object_id": "6", "object_repr": "Valid Palindrome", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Space complexity\", \"Solution\"]}}]"}}, {"model": "admin.logentry", "pk": 42, "fields": {"action_time": "2024-05-08T22:03:45.257Z", "user": 1, "content_type": 38, "object_id": "3", "object_repr": "O(n2)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 43, "fields": {"action_time": "2024-05-08T22:03:53.344Z", "user": 1, "content_type": 38, "object_id": "4", "object_repr": "O(logn)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 44, "fields": {"action_time": "2024-05-08T22:04:02.115Z", "user": 1, "content_type": 38, "object_id": "5", "object_repr": "O(nlog)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 45, "fields": {"action_time": "2024-05-08T22:05:11.486Z", "user": 1, "content_type": 26, "object_id": "10", "object_repr": "Unique Paths", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Time complexity\"]}}]"}}, {"model": "admin.logentry", "pk": 46, "fields": {"action_time": "2024-05-08T22:05:56.472Z", "user": 1, "content_type": 26, "object_id": "12", "object_repr": "Valid Anagram", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solution\"]}}]"}}, {"model": "admin.logentry", "pk": 47, "fields": {"action_time": "2024-05-08T22:06:09.788Z", "user": 1, "content_type": 26, "object_id": "13", "object_repr": "Group Anagrams", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Time complexity\", \"Space complexity\"]}}]"}}, {"model": "admin.logentry", "pk": 48, "fields": {"action_time": "2024-05-08T22:18:35.423Z", "user": 1, "content_type": 26, "object_id": "16", "object_repr": "3Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Time complexity\"]}}]"}}, {"model": "admin.logentry", "pk": 49, "fields": {"action_time": "2024-05-08T22:19:46.769Z", "user": 1, "content_type": 26, "object_id": "15", "object_repr": "Longest Consecutive Sequence", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Url\"]}}]"}}, {"model": "admin.logentry", "pk": 50, "fields": {"action_time": "2024-05-08T22:24:48.954Z", "user": 1, "content_type": 26, "object_id": "17", "object_repr": "Container With Most Water", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 51, "fields": {"action_time": "2024-06-18T19:46:11.825Z", "user": 1, "content_type": 44, "object_id": "41", "object_repr": "Two Sum (JavaScript)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 52, "fields": {"action_time": "2024-06-19T14:22:41.567Z", "user": 1, "content_type": 26, "object_id": "1", "object_repr": "Two Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 53, "fields": {"action_time": "2024-06-19T14:23:21.401Z", "user": 1, "content_type": 26, "object_id": "1", "object_repr": "Two Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 54, "fields": {"action_time": "2024-06-19T14:55:31.481Z", "user": 1, "content_type": 26, "object_id": "1", "object_repr": "Two Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solution\"]}}]"}}, {"model": "admin.logentry", "pk": 55, "fields": {"action_time": "2024-06-19T20:32:28.265Z", "user": 1, "content_type": 26, "object_id": "2", "object_repr": "Two Sum II - Input Array Is Sorted", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 56, "fields": {"action_time": "2024-06-19T20:32:37.624Z", "user": 1, "content_type": 26, "object_id": "3", "object_repr": "Valid Parentheses", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 57, "fields": {"action_time": "2024-06-19T20:32:51.112Z", "user": 1, "content_type": 26, "object_id": "4", "object_repr": "Directions Reduction", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 58, "fields": {"action_time": "2024-06-19T20:33:02.086Z", "user": 1, "content_type": 26, "object_id": "6", "object_repr": "Valid Palindrome", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 59, "fields": {"action_time": "2024-06-19T20:33:14.605Z", "user": 1, "content_type": 26, "object_id": "7", "object_repr": "Split a String in Balanced Strings", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 60, "fields": {"action_time": "2024-06-19T20:36:10.795Z", "user": 1, "content_type": 26, "object_id": "8", "object_repr": "Sum of Pairs", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 61, "fields": {"action_time": "2024-06-19T20:38:08.466Z", "user": 1, "content_type": 26, "object_id": "10", "object_repr": "Unique Paths", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 62, "fields": {"action_time": "2024-06-19T20:39:43.919Z", "user": 1, "content_type": 26, "object_id": "11", "object_repr": "Contains Duplicate", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 63, "fields": {"action_time": "2024-06-19T20:39:58.748Z", "user": 1, "content_type": 26, "object_id": "12", "object_repr": "Valid Anagram", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 64, "fields": {"action_time": "2024-06-19T20:40:14.720Z", "user": 1, "content_type": 26, "object_id": "13", "object_repr": "Group Anagrams", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 65, "fields": {"action_time": "2024-06-19T20:40:26.895Z", "user": 1, "content_type": 26, "object_id": "14", "object_repr": "Top K Frequent Elements", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 66, "fields": {"action_time": "2024-06-19T20:40:35.250Z", "user": 1, "content_type": 26, "object_id": "15", "object_repr": "Longest Consecutive Sequence", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 67, "fields": {"action_time": "2024-06-19T20:40:45.582Z", "user": 1, "content_type": 26, "object_id": "16", "object_repr": "3Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 68, "fields": {"action_time": "2024-06-19T20:41:06.897Z", "user": 1, "content_type": 26, "object_id": "17", "object_repr": "Container With Most Water", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 69, "fields": {"action_time": "2024-06-19T20:41:24.326Z", "user": 1, "content_type": 26, "object_id": "18", "object_repr": "Count Pairs Whose Sum is Less than Target", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 70, "fields": {"action_time": "2024-06-19T20:42:07.137Z", "user": 1, "content_type": 26, "object_id": "19", "object_repr": "Reverse Prefix of Word", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 71, "fields": {"action_time": "2024-06-19T20:42:16.631Z", "user": 1, "content_type": 26, "object_id": "18", "object_repr": "Count Pairs Whose Sum is Less than Target", "action_flag": 2, "change_message": "[]"}}, {"model": "admin.logentry", "pk": 72, "fields": {"action_time": "2024-06-19T20:43:06.355Z", "user": 1, "content_type": 26, "object_id": "20", "object_repr": "Find First Palindromic String in the Array", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 73, "fields": {"action_time": "2024-06-19T20:43:23.049Z", "user": 1, "content_type": 26, "object_id": "17", "object_repr": "Container With Most Water", "action_flag": 2, "change_message": "[]"}}, {"model": "admin.logentry", "pk": 74, "fields": {"action_time": "2024-06-19T20:43:32.089Z", "user": 1, "content_type": 26, "object_id": "18", "object_repr": "Count Pairs Whose Sum is Less than Target", "action_flag": 2, "change_message": "[]"}}, {"model": "admin.logentry", "pk": 75, "fields": {"action_time": "2024-06-19T20:43:57.880Z", "user": 1, "content_type": 26, "object_id": "19", "object_repr": "Reverse Prefix of Word", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 76, "fields": {"action_time": "2024-06-19T20:44:43.893Z", "user": 1, "content_type": 26, "object_id": "20", "object_repr": "Find First Palindromic String in the Array", "action_flag": 2, "change_message": "[]"}}, {"model": "admin.logentry", "pk": 77, "fields": {"action_time": "2024-06-19T20:49:16.729Z", "user": 1, "content_type": 26, "object_id": "21", "object_repr": "Number of Arithmetic Triplets", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 78, "fields": {"action_time": "2024-06-19T20:49:28.834Z", "user": 1, "content_type": 26, "object_id": "22", "object_repr": "Reverse Words in a String III", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 79, "fields": {"action_time": "2024-06-19T20:49:46.389Z", "user": 1, "content_type": 26, "object_id": "23", "object_repr": "Best Time to Buy and Sell Stock", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 80, "fields": {"action_time": "2024-06-19T20:49:57.509Z", "user": 1, "content_type": 26, "object_id": "24", "object_repr": "Longest Substring Without Repeating Characters", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 81, "fields": {"action_time": "2024-06-19T20:50:10.199Z", "user": 1, "content_type": 26, "object_id": "25", "object_repr": "Substrings of Size Three with Distinct Characters", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 82, "fields": {"action_time": "2024-06-19T20:50:37.535Z", "user": 1, "content_type": 26, "object_id": "26", "object_repr": "Find Minimum in Rotated Sorted Array", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 83, "fields": {"action_time": "2024-06-19T20:50:50.602Z", "user": 1, "content_type": 26, "object_id": "27", "object_repr": "Longest Password", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 84, "fields": {"action_time": "2024-06-19T20:51:00.489Z", "user": 1, "content_type": 26, "object_id": "28", "object_repr": "Flood Depth", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 85, "fields": {"action_time": "2024-06-19T20:51:08.404Z", "user": 1, "content_type": 26, "object_id": "29", "object_repr": "Trapping Rain Water", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 86, "fields": {"action_time": "2024-06-19T20:51:18.810Z", "user": 1, "content_type": 26, "object_id": "30", "object_repr": "Climbing Stairs", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 87, "fields": {"action_time": "2024-06-19T20:51:26.788Z", "user": 1, "content_type": 26, "object_id": "31", "object_repr": "House Robber", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 88, "fields": {"action_time": "2024-06-19T20:51:34.362Z", "user": 1, "content_type": 26, "object_id": "32", "object_repr": "House Robber II", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 89, "fields": {"action_time": "2024-06-19T20:51:43.811Z", "user": 1, "content_type": 26, "object_id": "33", "object_repr": "Longest Palindromic Substring", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 90, "fields": {"action_time": "2024-06-19T20:51:53.045Z", "user": 1, "content_type": 26, "object_id": "34", "object_repr": "Palindromic Substrings", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 91, "fields": {"action_time": "2024-06-19T20:52:02.925Z", "user": 1, "content_type": 26, "object_id": "35", "object_repr": "Coin Change", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 92, "fields": {"action_time": "2024-06-19T20:52:16.566Z", "user": 1, "content_type": 26, "object_id": "35", "object_repr": "Coin Change", "action_flag": 2, "change_message": "[]"}}, {"model": "admin.logentry", "pk": 93, "fields": {"action_time": "2024-06-19T20:52:33.506Z", "user": 1, "content_type": 26, "object_id": "36", "object_repr": "Maximum Product Subarray", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 94, "fields": {"action_time": "2024-06-19T20:52:42.275Z", "user": 1, "content_type": 26, "object_id": "37", "object_repr": "Hedgehog", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 95, "fields": {"action_time": "2024-06-19T20:52:50.672Z", "user": 1, "content_type": 26, "object_id": "38", "object_repr": "Word Break", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 96, "fields": {"action_time": "2024-06-19T20:53:01.092Z", "user": 1, "content_type": 26, "object_id": "39", "object_repr": "Longest Increasing Subsequence", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 97, "fields": {"action_time": "2024-06-19T20:53:09.330Z", "user": 1, "content_type": 26, "object_id": "40", "object_repr": "Partition Equal Subset Sum", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 98, "fields": {"action_time": "2024-06-19T20:53:20.149Z", "user": 1, "content_type": 26, "object_id": "41", "object_repr": "Longest Common Subsequence", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 99, "fields": {"action_time": "2024-06-19T20:53:26.936Z", "user": 1, "content_type": 26, "object_id": "42", "object_repr": "Maximum Subarray", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Solutions\"]}}]"}}, {"model": "admin.logentry", "pk": 100, "fields": {"action_time": "2024-06-20T09:56:16.435Z", "user": 1, "content_type": 26, "object_id": "44", "object_repr": "qwfkqkq", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 101, "fields": {"action_time": "2024-06-20T09:56:16.449Z", "user": 1, "content_type": 26, "object_id": "43", "object_repr": "qwfk", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 102, "fields": {"action_time": "2024-06-20T12:13:57.247Z", "user": 1, "content_type": 43, "object_id": "3", "object_repr": "Pandas", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 103, "fields": {"action_time": "2024-06-20T12:14:27.519Z", "user": 1, "content_type": 43, "object_id": "4", "object_repr": "MySQL", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 104, "fields": {"action_time": "2024-06-20T12:14:46.582Z", "user": 1, "content_type": 43, "object_id": "5", "object_repr": "PostgreSQL", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 105, "fields": {"action_time": "2024-06-21T13:54:42.987Z", "user": 1, "content_type": 44, "object_id": "45", "object_repr": "Two Sum (Python)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 106, "fields": {"action_time": "2024-06-21T21:08:41.127Z", "user": 1, "content_type": 44, "object_id": "45", "object_repr": "Two Sum (Python)", "action_flag": 3, "change_message": ""}}, {"model": "admin.logentry", "pk": 107, "fields": {"action_time": "2024-07-22T23:46:25.318Z", "user": 1, "content_type": 38, "object_id": "5", "object_repr": "O(nlogn)", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Name\"]}}]"}}, {"model": "admin.logentry", "pk": 108, "fields": {"action_time": "2024-08-12T20:00:06.718Z", "user": 1, "content_type": 38, "object_id": "6", "object_repr": "O(2^n)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 109, "fields": {"action_time": "2024-08-13T12:03:54.599Z", "user": 1, "content_type": 38, "object_id": "7", "object_repr": "O(n2^n)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 110, "fields": {"action_time": "2024-08-13T21:48:37.119Z", "user": 1, "content_type": 38, "object_id": "8", "object_repr": "O(n!)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "auth.permission", "pk": 73, "fields": {"name": "Can add log entry", "content_type": 19, "codename": "add_logentry"}}, {"model": "auth.permission", "pk": 74, "fields": {"name": "Can change log entry", "content_type": 19, "codename": "change_logentry"}}, {"model": "auth.permission", "pk": 75, "fields": {"name": "Can delete log entry", "content_type": 19, "codename": "delete_logentry"}}, {"model": "auth.permission", "pk": 76, "fields": {"name": "Can view log entry", "content_type": 19, "codename": "view_logentry"}}, {"model": "auth.permission", "pk": 77, "fields": {"name": "Can add permission", "content_type": 20, "codename": "add_permission"}}, {"model": "auth.permission", "pk": 78, "fields": {"name": "Can change permission", "content_type": 20, "codename": "change_permission"}}, {"model": "auth.permission", "pk": 79, "fields": {"name": "Can delete permission", "content_type": 20, "codename": "delete_permission"}}, {"model": "auth.permission", "pk": 80, "fields": {"name": "Can view permission", "content_type": 20, "codename": "view_permission"}}, {"model": "auth.permission", "pk": 81, "fields": {"name": "Can add group", "content_type": 21, "codename": "add_group"}}, {"model": "auth.permission", "pk": 82, "fields": {"name": "Can change group", "content_type": 21, "codename": "change_group"}}, {"model": "auth.permission", "pk": 83, "fields": {"name": "Can delete group", "content_type": 21, "codename": "delete_group"}}, {"model": "auth.permission", "pk": 84, "fields": {"name": "Can view group", "content_type": 21, "codename": "view_group"}}, {"model": "auth.permission", "pk": 85, "fields": {"name": "Can add user", "content_type": 22, "codename": "add_user"}}, {"model": "auth.permission", "pk": 86, "fields": {"name": "Can change user", "content_type": 22, "codename": "change_user"}}, {"model": "auth.permission", "pk": 87, "fields": {"name": "Can delete user", "content_type": 22, "codename": "delete_user"}}, {"model": "auth.permission", "pk": 88, "fields": {"name": "Can view user", "content_type": 22, "codename": "view_user"}}, {"model": "auth.permission", "pk": 89, "fields": {"name": "Can add content type", "content_type": 23, "codename": "add_contenttype"}}, {"model": "auth.permission", "pk": 90, "fields": {"name": "Can change content type", "content_type": 23, "codename": "change_contenttype"}}, {"model": "auth.permission", "pk": 91, "fields": {"name": "Can delete content type", "content_type": 23, "codename": "delete_contenttype"}}, {"model": "auth.permission", "pk": 92, "fields": {"name": "Can view content type", "content_type": 23, "codename": "view_contenttype"}}, {"model": "auth.permission", "pk": 93, "fields": {"name": "Can add session", "content_type": 24, "codename": "add_session"}}, {"model": "auth.permission", "pk": 94, "fields": {"name": "Can change session", "content_type": 24, "codename": "change_session"}}, {"model": "auth.permission", "pk": 95, "fields": {"name": "Can delete session", "content_type": 24, "codename": "delete_session"}}, {"model": "auth.permission", "pk": 96, "fields": {"name": "Can view session", "content_type": 24, "codename": "view_session"}}, {"model": "auth.permission", "pk": 97, "fields": {"name": "Can add tag", "content_type": 25, "codename": "add_tag"}}, {"model": "auth.permission", "pk": 98, "fields": {"name": "Can change tag", "content_type": 25, "codename": "change_tag"}}, {"model": "auth.permission", "pk": 99, "fields": {"name": "Can delete tag", "content_type": 25, "codename": "delete_tag"}}, {"model": "auth.permission", "pk": 100, "fields": {"name": "Can view tag", "content_type": 25, "codename": "view_tag"}}, {"model": "auth.permission", "pk": 101, "fields": {"name": "Can add problem", "content_type": 26, "codename": "add_problem"}}, {"model": "auth.permission", "pk": 102, "fields": {"name": "Can change problem", "content_type": 26, "codename": "change_problem"}}, {"model": "auth.permission", "pk": 103, "fields": {"name": "Can delete problem", "content_type": 26, "codename": "delete_problem"}}, {"model": "auth.permission", "pk": 104, "fields": {"name": "Can view problem", "content_type": 26, "codename": "view_problem"}}, {"model": "auth.permission", "pk": 105, "fields": {"name": "Can add association", "content_type": 27, "codename": "add_association"}}, {"model": "auth.permission", "pk": 106, "fields": {"name": "Can change association", "content_type": 27, "codename": "change_association"}}, {"model": "auth.permission", "pk": 107, "fields": {"name": "Can delete association", "content_type": 27, "codename": "delete_association"}}, {"model": "auth.permission", "pk": 108, "fields": {"name": "Can view association", "content_type": 27, "codename": "view_association"}}, {"model": "auth.permission", "pk": 109, "fields": {"name": "Can add code", "content_type": 28, "codename": "add_code"}}, {"model": "auth.permission", "pk": 110, "fields": {"name": "Can change code", "content_type": 28, "codename": "change_code"}}, {"model": "auth.permission", "pk": 111, "fields": {"name": "Can delete code", "content_type": 28, "codename": "delete_code"}}, {"model": "auth.permission", "pk": 112, "fields": {"name": "Can view code", "content_type": 28, "codename": "view_code"}}, {"model": "auth.permission", "pk": 113, "fields": {"name": "Can add nonce", "content_type": 29, "codename": "add_nonce"}}, {"model": "auth.permission", "pk": 114, "fields": {"name": "Can change nonce", "content_type": 29, "codename": "change_nonce"}}, {"model": "auth.permission", "pk": 115, "fields": {"name": "Can delete nonce", "content_type": 29, "codename": "delete_nonce"}}, {"model": "auth.permission", "pk": 116, "fields": {"name": "Can view nonce", "content_type": 29, "codename": "view_nonce"}}, {"model": "auth.permission", "pk": 117, "fields": {"name": "Can add user social auth", "content_type": 30, "codename": "add_usersocialauth"}}, {"model": "auth.permission", "pk": 118, "fields": {"name": "Can change user social auth", "content_type": 30, "codename": "change_usersocialauth"}}, {"model": "auth.permission", "pk": 119, "fields": {"name": "Can delete user social auth", "content_type": 30, "codename": "delete_usersocialauth"}}, {"model": "auth.permission", "pk": 120, "fields": {"name": "Can view user social auth", "content_type": 30, "codename": "view_usersocialauth"}}, {"model": "auth.permission", "pk": 121, "fields": {"name": "Can add partial", "content_type": 31, "codename": "add_partial"}}, {"model": "auth.permission", "pk": 122, "fields": {"name": "Can change partial", "content_type": 31, "codename": "change_partial"}}, {"model": "auth.permission", "pk": 123, "fields": {"name": "Can delete partial", "content_type": 31, "codename": "delete_partial"}}, {"model": "auth.permission", "pk": 124, "fields": {"name": "Can view partial", "content_type": 31, "codename": "view_partial"}}, {"model": "auth.permission", "pk": 125, "fields": {"name": "Can add tag", "content_type": 32, "codename": "add_tag"}}, {"model": "auth.permission", "pk": 126, "fields": {"name": "Can change tag", "content_type": 32, "codename": "change_tag"}}, {"model": "auth.permission", "pk": 127, "fields": {"name": "Can delete tag", "content_type": 32, "codename": "delete_tag"}}, {"model": "auth.permission", "pk": 128, "fields": {"name": "Can view tag", "content_type": 32, "codename": "view_tag"}}, {"model": "auth.permission", "pk": 129, "fields": {"name": "Can add tagged item", "content_type": 33, "codename": "add_taggeditem"}}, {"model": "auth.permission", "pk": 130, "fields": {"name": "Can change tagged item", "content_type": 33, "codename": "change_taggeditem"}}, {"model": "auth.permission", "pk": 131, "fields": {"name": "Can delete tagged item", "content_type": 33, "codename": "delete_taggeditem"}}, {"model": "auth.permission", "pk": 132, "fields": {"name": "Can view tagged item", "content_type": 33, "codename": "view_taggeditem"}}, {"model": "auth.permission", "pk": 133, "fields": {"name": "Can add difficulty", "content_type": 34, "codename": "add_difficulty"}}, {"model": "auth.permission", "pk": 134, "fields": {"name": "Can change difficulty", "content_type": 34, "codename": "change_difficulty"}}, {"model": "auth.permission", "pk": 135, "fields": {"name": "Can delete difficulty", "content_type": 34, "codename": "delete_difficulty"}}, {"model": "auth.permission", "pk": 136, "fields": {"name": "Can view difficulty", "content_type": 34, "codename": "view_difficulty"}}, {"model": "auth.permission", "pk": 137, "fields": {"name": "Can add tag", "content_type": 35, "codename": "add_tag"}}, {"model": "auth.permission", "pk": 138, "fields": {"name": "Can change tag", "content_type": 35, "codename": "change_tag"}}, {"model": "auth.permission", "pk": 139, "fields": {"name": "Can delete tag", "content_type": 35, "codename": "delete_tag"}}, {"model": "auth.permission", "pk": 140, "fields": {"name": "Can view tag", "content_type": 35, "codename": "view_tag"}}, {"model": "auth.permission", "pk": 141, "fields": {"name": "Can add difficulty", "content_type": 36, "codename": "add_difficulty"}}, {"model": "auth.permission", "pk": 142, "fields": {"name": "Can change difficulty", "content_type": 36, "codename": "change_difficulty"}}, {"model": "auth.permission", "pk": 143, "fields": {"name": "Can delete difficulty", "content_type": 36, "codename": "delete_difficulty"}}, {"model": "auth.permission", "pk": 144, "fields": {"name": "Can view difficulty", "content_type": 36, "codename": "view_difficulty"}}, {"model": "auth.permission", "pk": 145, "fields": {"name": "Can add problem", "content_type": 37, "codename": "add_problem"}}, {"model": "auth.permission", "pk": 146, "fields": {"name": "Can change problem", "content_type": 37, "codename": "change_problem"}}, {"model": "auth.permission", "pk": 147, "fields": {"name": "Can delete problem", "content_type": 37, "codename": "delete_problem"}}, {"model": "auth.permission", "pk": 148, "fields": {"name": "Can view problem", "content_type": 37, "codename": "view_problem"}}, {"model": "auth.permission", "pk": 149, "fields": {"name": "Can add complexity", "content_type": 38, "codename": "add_complexity"}}, {"model": "auth.permission", "pk": 150, "fields": {"name": "Can change complexity", "content_type": 38, "codename": "change_complexity"}}, {"model": "auth.permission", "pk": 151, "fields": {"name": "Can delete complexity", "content_type": 38, "codename": "delete_complexity"}}, {"model": "auth.permission", "pk": 152, "fields": {"name": "Can view complexity", "content_type": 38, "codename": "view_complexity"}}, {"model": "auth.permission", "pk": 153, "fields": {"name": "Can add bug comment", "content_type": 39, "codename": "add_bugcomment"}}, {"model": "auth.permission", "pk": 154, "fields": {"name": "Can change bug comment", "content_type": 39, "codename": "change_bugcomment"}}, {"model": "auth.permission", "pk": 155, "fields": {"name": "Can delete bug comment", "content_type": 39, "codename": "delete_bugcomment"}}, {"model": "auth.permission", "pk": 156, "fields": {"name": "Can view bug comment", "content_type": 39, "codename": "view_bugcomment"}}, {"model": "auth.permission", "pk": 157, "fields": {"name": "Can add feature comment", "content_type": 40, "codename": "add_featurecomment"}}, {"model": "auth.permission", "pk": 158, "fields": {"name": "Can change feature comment", "content_type": 40, "codename": "change_featurecomment"}}, {"model": "auth.permission", "pk": 159, "fields": {"name": "Can delete feature comment", "content_type": 40, "codename": "delete_featurecomment"}}, {"model": "auth.permission", "pk": 160, "fields": {"name": "Can view feature comment", "content_type": 40, "codename": "view_featurecomment"}}, {"model": "auth.permission", "pk": 161, "fields": {"name": "Can add feature forum", "content_type": 41, "codename": "add_featureforum"}}, {"model": "auth.permission", "pk": 162, "fields": {"name": "Can change feature forum", "content_type": 41, "codename": "change_featureforum"}}, {"model": "auth.permission", "pk": 163, "fields": {"name": "Can delete feature forum", "content_type": 41, "codename": "delete_featureforum"}}, {"model": "auth.permission", "pk": 164, "fields": {"name": "Can view feature forum", "content_type": 41, "codename": "view_featureforum"}}, {"model": "auth.permission", "pk": 165, "fields": {"name": "Can add bug forum", "content_type": 42, "codename": "add_bugforum"}}, {"model": "auth.permission", "pk": 166, "fields": {"name": "Can change bug forum", "content_type": 42, "codename": "change_bugforum"}}, {"model": "auth.permission", "pk": 167, "fields": {"name": "Can delete bug forum", "content_type": 42, "codename": "delete_bugforum"}}, {"model": "auth.permission", "pk": 168, "fields": {"name": "Can view bug forum", "content_type": 42, "codename": "view_bugforum"}}, {"model": "auth.permission", "pk": 169, "fields": {"name": "Can add language", "content_type": 43, "codename": "add_language"}}, {"model": "auth.permission", "pk": 170, "fields": {"name": "Can change language", "content_type": 43, "codename": "change_language"}}, {"model": "auth.permission", "pk": 171, "fields": {"name": "Can delete language", "content_type": 43, "codename": "delete_language"}}, {"model": "auth.permission", "pk": 172, "fields": {"name": "Can view language", "content_type": 43, "codename": "view_language"}}, {"model": "auth.permission", "pk": 173, "fields": {"name": "Can add solution", "content_type": 44, "codename": "add_solution"}}, {"model": "auth.permission", "pk": 174, "fields": {"name": "Can change solution", "content_type": 44, "codename": "change_solution"}}, {"model": "auth.permission", "pk": 175, "fields": {"name": "Can delete solution", "content_type": 44, "codename": "delete_solution"}}, {"model": "auth.permission", "pk": 176, "fields": {"name": "Can view solution", "content_type": 44, "codename": "view_solution"}}, {"model": "auth.user", "pk": 1, "fields": {"password": "pbkdf2_sha256$600000$KchrA6ITyrv7n494W7Om1d$05PPp7126WSwiAfeaCJK3KY/6XuJu9nO9uLMc4/QorY=", "last_login": "2025-01-01T09:05:29.860Z", "is_superuser": true, "username": "ukasz", "first_name": "", "last_name": "", "email": "", "is_staff": true, "is_active": true, "date_joined": "2024-04-19T12:01:01.400Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 2, "fields": {"password": "pbkdf2_sha256$600000$gucaPuhyLYJPEuwOO5Nvhf$DyXh3PBPlrxiIZaLrOlgJptLfDZYuZ57AhxcMLg1LEg=", "last_login": null, "is_superuser": false, "username": "krzysztof", "first_name": "", "last_name": "", "email": "", "is_staff": false, "is_active": true, "date_joined": "2024-04-23T11:57:39.814Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 3, "fields": {"password": "!5v5MxqmcB1XlkaEuGxDVT414NCVUKOE6kbCJXm4O", "last_login": "2025-03-17T00:24:03.337Z", "is_superuser": false, "username": "lodyga", "first_name": "", "last_name": "", "email": "", "is_staff": false, "is_active": true, "date_joined": "2024-05-05T14:38:54.568Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 4, "fields": {"password": "!2gJvpwsJN4GqVhhlUGbscPrHaTU0FlPk2WQHPN7Q", "last_login": "2025-03-08T22:49:09.123Z", "is_superuser": false, "username": "krzysztofskorupski", "first_name": "Krzysztof", "last_name": "Skorupski", "email": "", "is_staff": false, "is_active": true, "date_joined": "2024-05-30T22:42:58.998Z", "groups": [], "user_permissions": []}}, {"model": "contenttypes.contenttype", "pk": 19, "fields": {"app_label": "admin", "model": "logentry"}}, {"model": "contenttypes.contenttype", "pk": 20, "fields": {"app_label": "auth", "model": "permission"}}, {"model": "contenttypes.contenttype", "pk": 21, "fields": {"app_label": "auth", "model": "group"}}, {"model": "contenttypes.contenttype", "pk": 22, "fields": {"app_label": "auth", "model": "user"}}, {"model": "contenttypes.contenttype", "pk": 23, "fields": {"app_label": "contenttypes", "model": "contenttype"}}, {"model": "contenttypes.contenttype", "pk": 24, "fields": {"app_label": "sessions", "model": "session"}}, {"model": "contenttypes.contenttype", "pk": 25, "fields": {"app_label": "python_problems", "model": "tag"}}, {"model": "contenttypes.contenttype", "pk": 26, "fields": {"app_label": "python_problems", "model": "problem"}}, {"model": "contenttypes.contenttype", "pk": 27, "fields": {"app_label": "social_django", "model": "association"}}, {"model": "contenttypes.contenttype", "pk": 28, "fields": {"app_label": "social_django", "model": "code"}}, {"model": "contenttypes.contenttype", "pk": 29, "fields": {"app_label": "social_django", "model": "nonce"}}, {"model": "contenttypes.contenttype", "pk": 30, "fields": {"app_label": "social_django", "model": "usersocialauth"}}, {"model": "contenttypes.contenttype", "pk": 31, "fields": {"app_label": "social_django", "model": "partial"}}, {"model": "contenttypes.contenttype", "pk": 32, "fields": {"app_label": "taggit", "model": "tag"}}, {"model": "contenttypes.contenttype", "pk": 33, "fields": {"app_label": "taggit", "model": "taggeditem"}}, {"model": "contenttypes.contenttype", "pk": 34, "fields": {"app_label": "python_problems", "model": "difficulty"}}, {"model": "contenttypes.contenttype", "pk": 35, "fields": {"app_label": "sql_problems", "model": "tag"}}, {"model": "contenttypes.contenttype", "pk": 36, "fields": {"app_label": "sql_problems", "model": "difficulty"}}, {"model": "contenttypes.contenttype", "pk": 37, "fields": {"app_label": "sql_problems", "model": "problem"}}, {"model": "contenttypes.contenttype", "pk": 38, "fields": {"app_label": "python_problems", "model": "complexity"}}, {"model": "contenttypes.contenttype", "pk": 39, "fields": {"app_label": "forums", "model": "bugcomment"}}, {"model": "contenttypes.contenttype", "pk": 40, "fields": {"app_label": "forums", "model": "featurecomment"}}, {"model": "contenttypes.contenttype", "pk": 41, "fields": {"app_label": "forums", "model": "featureforum"}}, {"model": "contenttypes.contenttype", "pk": 42, "fields": {"app_label": "forums", "model": "bugforum"}}, {"model": "contenttypes.contenttype", "pk": 43, "fields": {"app_label": "python_problems", "model": "language"}}, {"model": "contenttypes.contenttype", "pk": 44, "fields": {"app_label": "python_problems", "model": "solution"}}, {"model": "sessions.session", "pk": "09qkejelegyaa669tz6umadxx1fzth8e", "fields": {"session_data": "eyJuZXh0IjoiL2ZvcnVtcy9mZWF0dXJlX2ZvcnVtIiwiZ2l0aHViX3N0YXRlIjoiOENsVGFxeGd6NnBQS1Y3YWZPZzhPcXdVUDJpWkkyMlgifQ:1sd9ZC:2pn-w7IRrhU4rCBxpkudhubStite8Ov4KfyHzaKq9Z0", "expire_date": "2024-08-25T14:29:06.207Z"}}, {"model": "sessions.session", "pk": "0b1oobo045ticz4esun17dsymnmpm9d5", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1sBiEq:owKvbkEQN6sXExoCBTvD_oSd5LYJwRkVgHjD0nfc52E", "expire_date": "2024-06-10T21:50:40.613Z"}}, {"model": "sessions.session", "pk": "0hxs11vihsks794y8pqae1rs8gv2zb3h", "fields": {"session_data": ".eJxVjMsOgjAQRf-la4NteRRc6kLjg6gLg27ItDMR1BQjJRCN_y4kbNyee879MEudYzM2ZRN2LV3R6Lx24KhH-O52ly1J0R7axWOzTvX-fDxB9uTBMrXZqi9yaFyRNzW98hL7RPwzDeZOdhjwBvZaeaay7lVqb1C8ca29XYX0mI_u30EBddHXcaJiCVz6KJLYcBQYRorIxKhEJDWEQgIpP5ARqjBRRoRcBmAS5QufFHH2_QFB5kp2:1s6cf3:suwW4BBW-fWI3KBqK8ZcXYEtkKk2MCHrrt8iw22xIT0", "expire_date": "2024-05-27T20:52:41.928Z"}}, {"model": "sessions.session", "pk": "0tpkv30ytcp0g8du97y61yxsdf3elbnu", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9hcnJhbmdpbmctY29pbnMvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6Ijk4dW9tUVBOSm40OWkwUGJ5NGdkdVZmMDBiT2ZzRVBhIn0:1trzRB:PuAdPYKnvmRNxFXS7rNsU68Cwf4ULqh7e6bEjeEt2AM", "expire_date": "2025-03-25T13:14:25.643Z"}}, {"model": "sessions.session", "pk": "17py8k29i85vpsj8rjg0xqxewx4xwu78", "fields": {"session_data": "eyJuZXh0IjoiL3NxbC8iLCJnaXRodWJfc3RhdGUiOiJkMTVOQnpkVGRNZEpBQzljdmt6MGY3NFljUmMwZVdJOCJ9:1tru7f:LrcjYwfyxC601Vcx8XQvn_W5glqfkZmkafW9ybQeSf0", "expire_date": "2025-03-25T07:33:55.612Z"}}, {"model": "sessions.session", "pk": "18akushdugpl53neder08kmxz4a0e3vr", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvOC91cGRhdGUvIiwiZ2l0aHViX3N0YXRlIjoiM2Zzc1UzNU5lcjVzaGVCbFQ0SktBTmQxNnFJWDRpVTkifQ:1sCbLD:skzM8N89KenSPFiRw-alBVRogNzv-xRkaj6l9Opd9fA", "expire_date": "2024-06-13T08:40:55.153Z"}}, {"model": "sessions.session", "pk": "18mr7gcifnzt6wrt45tn4ot2fycj5j7a", "fields": {"session_data": "eyJuZXh0IjoiL2ZvcnVtcy9mZWF0dXJlX2ZvcnVtLzEiLCJnaXRodWJfc3RhdGUiOiJxczFVOFk1cm5vZXU4S3U0YmFkdWtHYXdSYVIzVU1TbiJ9:1tlt6T:3NcvHqZFpjwJ2oAcY5561ljyspC9JqbFdg0e9Cj1PhI", "expire_date": "2025-03-08T17:15:49.262Z"}}, {"model": "sessions.session", "pk": "1c3m0wy1oxbne9exsil7irbqu63sxk7v", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zaW5nbGUtZWxlbWVudC1pbi1hLXNvcnRlZC1hcnJheS9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6InhZa2VuazJ6RXNOeE1MVHEyMWJmdTF0TmNaeW1Zb0JzIn0:1tnORL:HGW64rf0wuk_Y345MVASCDBBdMamI8jilMcORDZunoI", "expire_date": "2025-03-12T20:55:35.975Z"}}, {"model": "sessions.session", "pk": "1cjzkcqm1guaybcz0jsdxpy9dfq5buje", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zaW5nbGUtZWxlbWVudC1pbi1hLXNvcnRlZC1hcnJheS9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6ImhPNGVTQjczSm00Mm5HNXZ5WlFWVnF0UFVsRUdxZ1VDIn0:1tnOcS:TrQfn2o9ISX1FgHRcgevN-D3HbQ5c8GhzvRE2om85u8", "expire_date": "2025-03-12T21:07:04.996Z"}}, {"model": "sessions.session", "pk": "1d77ohasm7ip3z96v47fxu4pq3zmhyri", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yYW5nZS1zdW0tcXVlcnktaW1tdXRhYmxlL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiM1dPcHBLVFc1T3NHWkM4cW52ejF2NTN1MVRyNFp2a3oifQ:1tltKH:YVS4ztnkkR6KRgasY8lOlN7uKz7LbiZ-nSBBIuNM9DE", "expire_date": "2025-03-08T17:30:05.527Z"}}, {"model": "sessions.session", "pk": "1ep8pgbh4ouzt99f3ik1kp5piv7x3qxx", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9maW5kLW1pbmltdW0taW4tcm90YXRlZC1zb3J0ZWQtYXJyYXkvIiwiZ2l0aHViX3N0YXRlIjoiOFFTOEY1U29MZ1FKdTB3Znd3ZWVuOEFLVkRKb1VGVmQifQ:1sCryc:iRDfQ11zSfwqeFBpWDc9kONtU5mDUMHra8mObvfO39o", "expire_date": "2024-06-14T02:26:42.263Z"}}, {"model": "sessions.session", "pk": "1f54idesyxohz0hyaswdz4ku2a1ioqnb", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sYW5ndWFnZV9hZGQvIiwiZ2l0aHViX3N0YXRlIjoiSDJwdFAwako3eXFKY1ZRc3pVWEhZaWJybzVyQVRGVFMifQ:1trqdc:VeVMSWZuN8PCY4loyo_6KSMRVR_aF55hbchOrhJSLx8", "expire_date": "2025-03-25T03:50:40.895Z"}}, {"model": "sessions.session", "pk": "1k55ob2kzz4hklpeo4izf87nnzgn8dy8", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6InFLdDNxOGZzWTJMampBT1gybnpYbFk5cWFuSTVzc29BIn0:1tltO4:EN_P-ois0LROrxsrEZiaz_LLVOhRZnv6Njk3dmCU2Vg", "expire_date": "2025-03-08T17:34:00.944Z"}}, {"model": "sessions.session", "pk": "1n9ainef91zg040vofhxkc8nzaz9sltg", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLWlpaS9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6InFIMnZTOFQ1dXZjU3hzMGk2S2ZpYk12QkRpQTNNNnB0In0:1tltKa:74Wo7pJYZ8wFYWCyiMGXzTvL-urHDaAvuYIJ-7-Gdso", "expire_date": "2025-03-08T17:30:24.557Z"}}, {"model": "sessions.session", "pk": "1npgwv29r713o03qzy684toy7isecdjh", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyLyIsImdpdGh1Yl9zdGF0ZSI6IlZLSlNQZXdGOVFKOVNSYkpCQW93UDlNcmZCdFJhN01GIn0:1sCt0R:Uvm8AsptI6fFFsegCveWYvkcaIU3s5BJoew1lVKPLkY", "expire_date": "2024-06-14T03:32:39.493Z"}}, {"model": "sessions.session", "pk": "1nwn3gz2nnyd8lphkywnv2myf4ch4b0t", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9kZWxldGUtYW5kLWVhcm4vUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6InRjQkdWTDE5T2ZNOXNpZ2ZMWUR6WWhRZkJtb29wVVRnIn0:1tnU8v:VFbJ-rLNkEn1_4RdhP67EkADhJ0HJanh2i5m_S9Zagk", "expire_date": "2025-03-13T03:00:57.748Z"}}, {"model": "sessions.session", "pk": "2bwi9wwybcwa9igzpv3rfn79too9xzwd", "fields": {"session_data": ".eJxVjstqwzAQRf9F6-LYil7uri0lZJPWhZC0GzEajWITYxNLhkLpv1d5LJrVwBnOvfeHDfSd2CNbsAd26FI7OxsTJMpoPoomhl394j_fQyOet-vX_TB9ladmNJuT_8iGhTm1do402c5nZXnPHOCRhvMjjthBb3GcqLjRWFz7itXlvD1ljd_7LcQ2yzUXlSYZMEjyYLRyOoQqeMMVLrmSWuoq1AqRkwBy6IypSkGSY2nAOZVDb_2X6B5isv146IZ_A69b2O8f5T5bXQ:1thwsh:TrMfUG-owTCD8CpkbBd3JAQilORADD2vqQliVguQ14o", "expire_date": "2025-02-25T20:29:19.660Z"}}, {"model": "sessions.session", "pk": "2ef5um0i19ftd6r2btvf17nnq889m0c1", "fields": {"session_data": ".eJxVjs1OwzAQhN_FZ5QmTvxTbm1BFQIJCcHZWm_WjduQoNiWAoh3x6Q90NNqZ_ebmW820BzZLVu5cUrvYeUIYprILCu7YQcfu2RNiBApv1XbR3uKu89tPd_5-6-5Ljcvr7vjh3prH_BprzJhIMXOpECT8W1G6mvNAp5o-DuEET30BseJiosainNesV_G8yZj_JrvIHQZXvOmUiQcOkEtaCWtcq5yreYSay6FEqpya4nIqQGyaLWuyoYEx1KDtTKbXvIX6x5CNP148MO_gucu7OcXijBjJw:1trCSC:6bvHfeu-l34tJg17226aJmRIrohINzY7XyYkNFUt6WA", "expire_date": "2025-03-23T08:56:12.171Z"}}, {"model": "sessions.session", "pk": "2fnzyxfisuyo97wnbya4mlvjemzoluj1", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi91bmlxdWUtcGF0aHMvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6ImV3bjBpQ1VoY0NHalZyalA3Z1Z1dTBzd2tIZmFHQjBWIn0:1tltCB:a-8yyN_TRzd_1s4ajU-WXo6Q5YujYK3THYmTCjjagGg", "expire_date": "2025-03-08T17:21:43.872Z"}}, {"model": "sessions.session", "pk": "2n5yo7dtc8l6t3f8evq2w1sih2rvdv1e", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90cmlhbmdsZS9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoid2dldndqS2ltcmZVbnN6ZXBqYlg0Z05ZaGxlYmJSNDMifQ:1tltGc:YXz5S9Q9xsemeVppQhEy71_uh2XqEVtOZ3I1hOSYXvY", "expire_date": "2025-03-08T17:26:18.188Z"}}, {"model": "sessions.session", "pk": "2n8zunj4p4st4rooo94v9ewjr1rbsf2a", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMjMvZGVsZXRlLyIsImdpdGh1Yl9zdGF0ZSI6IlI0WXhVNDc4aEFvS0V0V0djQmNNRGtWM1NJWFNrcjh6In0:1sCsvm:3L_93V4YIpdLihDys9I61e8r-v9ffRRrJMZj0_Lw5o0", "expire_date": "2024-06-14T03:27:50.655Z"}}, {"model": "sessions.session", "pk": "2s6r7zvt4rftklxx56cxv863hly5f57y", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMTcvZGVsZXRlLyIsImdpdGh1Yl9zdGF0ZSI6IktXWWhnMDNqaEFPNlJVUk5NZXZXeW1Ta1FIMXNmZ3FrIn0:1sCsvV:hzssIu6R6LFOc_npzhLowP7kmGvmKDkeKLVnY0m3QRk", "expire_date": "2024-06-14T03:27:33.306Z"}}, {"model": "sessions.session", "pk": "33uqkexl2rnu6oh3t9bkupr9e3uk5yui", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1rzBbJ:hwqPlsHW6-MnURwfU1cToZnNBrBZx51mssF2GBpzjZY", "expire_date": "2024-05-07T08:34:05.056Z"}}, {"model": "sessions.session", "pk": "35rxnskyrvz8rz8lxj2t22c4ptyvovl9", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9tYXhpbXVtLXNjb3JlLWFmdGVyLXNwbGl0dGluZy1hLXN0cmluZy9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoiNDVPcFJ2V3o5Vk03SXBqV3l6Zlg0ZmhQZ1haZGc2RUUifQ:1tnhaK:kUpweetoIslB_r4MnlneNj1LwOuwDgzhCF4ircxOn2A", "expire_date": "2025-03-13T17:22:08.590Z"}}, {"model": "sessions.session", "pk": "39rem3wk2wgk7bcapuizk5wldus3ovrt", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jb21iaW5hdGlvbi1zdW0taWkvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6Im1yM3hkVGtnZGVSNVJkU0JOUjB5TDBsSUE4TllQZ0FRIn0:1tnhD9:YDh_sDZ6ONVfcBV8MDejU2BVNMBoESIMOLJl31uhXOs", "expire_date": "2025-03-13T16:58:11.981Z"}}, {"model": "sessions.session", "pk": "3tg8wf1k1do6o8wzmp3404nru5k6j8ov", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9kaXJlY3Rpb25zLXJlZHVjdGlvbi9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoibUxReFp0WnZqQVBPOXlLdmxRVk9hWlY4NVhJMjJTblMifQ:1trtpV:m3vcYW9N1wj9kTi3xQqmlh8XXQ3boQP9Br6bcQ1vikQ", "expire_date": "2025-03-25T07:15:09.965Z"}}, {"model": "sessions.session", "pk": "4c3ix64tp75pa6y0imvzmbfo3pu011d7", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1rzCL2:NvIQWXTKD0GrNhzAweA0llyiehS8Ukp0kP6-TJ8wkOo", "expire_date": "2024-05-07T09:21:20.390Z"}}, {"model": "sessions.session", "pk": "4qe30b9flw754xld2m3kb1782st05gyk", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wZXJtdXRhdGlvbi1pbi1zdHJpbmcvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6InZreTV6elVyMmxqdzRkY3lnYjlIZDkwTXBOYk1UN3NjIn0:1ts2dv:IL4ADiqStApCfuNFzZ3pJSLxudn8USly6Y_g4XCjLI8", "expire_date": "2025-03-25T16:39:47.901Z"}}, {"model": "sessions.session", "pk": "4w5nhzbgchzgn0kizqnply8k3l98n9gi", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMy9kZWxldGUvIiwiZ2l0aHViX3N0YXRlIjoiR2JZWjJnRVpUeUhxV1NvaVZ6U1lSSW9DaGhUMjJHZ0YifQ:1sCrd9:dg5VjhR6DCctGlZrutzjupgIj4_0ePeAWUADmhModos", "expire_date": "2024-06-14T02:04:31.945Z"}}, {"model": "sessions.session", "pk": "59bmgieew1svb9ps8mpjngzpws7tkolx", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jYXItZmxlZXQvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6InVHcmFJZkJxZm44Qlp0RnpyY0RiRWcxeVZHUEJSN1dLIn0:1tnSqD:hTCSo7PmjucFanJrVbvdPo0-2gguk_tJ404Fnd_ZpWU", "expire_date": "2025-03-13T01:37:33.948Z"}}, {"model": "sessions.session", "pk": "5bkgfwy8ey5ey79o5xd9h1egpvic4iuo", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wcm9ibGVtX2NyZWF0ZS8iLCJnaXRodWJfc3RhdGUiOiIwSjA3am95MnBUSlplTTZnR1ZoOXFteU4wV2ZpYmIzeSJ9:1tltAk:xIrOl3CyrUsJaCke6aqW291CrA7s8XTltBZlitXfxtw", "expire_date": "2025-03-08T17:20:14.154Z"}}, {"model": "sessions.session", "pk": "5e9phwm7wfz5jjuhxh4qiknkyga17dh4", "fields": {"session_data": ".eJxVjstOwzAQRf_F6yo0TvwouwipSNCWLgDByhpPxrEhSkrtSAXEv2PaLuhqpDM6995vNtAhsWt2xWasC8lP1sQEiTJ6e9zga7PdLe-fvjar9fNNfbhbdi-8Co3wn9uPbBiYkjdTpL0JbVaqS2YB32n4e8QRA_QGxz0VZxqLU19xezwPTdb4pe8h-iwveF0qEg6doBa0klY5V7pWc4kVl0IJVbqFRORUA1m0WpfzmgTHuQZrZQ499x-je4jJ9GMXhn8DT1vYzy-o5VsZ:1sdbDy:UC9QBTxh_5bph9cHBtA4D6BMmhJI5HQMHlUh1IjG5-k", "expire_date": "2024-08-26T20:01:02.277Z"}}, {"model": "sessions.session", "pk": "5j9shdlw73y2zklkenfxjeauvxwofv0t", "fields": {"session_data": ".eJxVjktPwzAQhP-LzzQPN36kt1QIxKkIIUBcLHuzTqImNq0dqRXiv2OaHuhppdn5ZuabODxFsiH51zn23uWjdx2GuAI_Td6twmwCHmZ0gPnz4iB3pBtiPxsVoo6Y2PfaPnzey200Hx6r81S87nXTvOFp-xR2hxdMhNJz7NUc8KiGNiHrW81o2KP7ewQPgx4V-CNmVzVkS1_2eDm7JmH0lu916BNc06oUyCxYhq2WghthbWlbSTmsKWeCidLWHIBipdGAkbIsKmQUCqmN4Sn02n-JHnWIavTd4P4NXLaQn191vmus:1sX0QM:Aq05Yg1o_pHM5p4GIUP_S6YG-BNFGH7rooLcLfXaww8", "expire_date": "2024-08-08T15:30:34.174Z"}}, {"model": "sessions.session", "pk": "5sqar8pxtp2pc3fwnvrnkal9loxhnf0m", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zaW5nbGUtZWxlbWVudC1pbi1hLXNvcnRlZC1hcnJheS9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IkFXY0taa3RHT01iTlFORnBZUUdMTlhreWdpS29heHg0In0:1tnOGL:KFnHg1zmOHX0VoHpKxIQdlMrq0nj9cWzIwytXIqz9XU", "expire_date": "2025-03-12T20:44:13.916Z"}}, {"model": "sessions.session", "pk": "5wn4cmkoo72kwpfxu5bkw5ss0srm6ugx", "fields": {"session_data": ".eJxVjM0KgkAURt9l1mHO6Hi1pVBgYZts0Uqucy_-FAo6ihG9ewpu2p7vnO8jWp6tOIi92ImyttVY5INFyws6ylOTwvVtk1TTdCvPUD7iKcl0EM_Z5e4vRY6jrfJx4D6vaUnkPyvQPLldB2qwLTvHdK3t68JZFWdbByftiF_x5v4dVDhUSx1GECp0lUcyCo1LknQAzCYkkIEqUEuFDJ6vAgIdgZHaVT6aCDzpMbArvj_Ix0nY:1s6GGh:P0VolaHwPMFqKq4FA7ulxkmOhUIJV5yFF-ELQp2jduI", "expire_date": "2024-05-26T20:58:03.358Z"}}, {"model": "sessions.session", "pk": "65fl062tckih5bva5yoyw8vi3w8h9dwv", "fields": {"session_data": ".eJxVjk1rAjEURf9L1mV0Mvma7kRQVEpLaReuwsubFyftkEGTAWnpf2-qLurqwXmce-83i3TO7JHN2AM7hNxPzqYMmQrabzfrsMP2452WcfX69HYUIX25jdjFl2Z_XhTDwpR7OyU62dAVpblnDvCT4t8jjRhgsDieqLrRVF37qvXlPC-Kxu_9HlJf5JaLWpP06CV1YLRy2vvad4YrbLiSWuratwqRkwBy6Iyp54Ikx7kB51QJvfVfogdI2Q7jIcR_A69b2M8v0YxbSA:1snz8X:XM1JGk4J9mmDcoN-bvG7x8NTMuC2AACiIkuoSViobNI", "expire_date": "2024-09-24T11:34:21.859Z"}}, {"model": "sessions.session", "pk": "6j4bg1tuqf5rshbq335xl6v3f4aehy1z", "fields": {"session_data": "eyJuZXh0IjoiL3NxbC9jb252ZXJzaW9uLyIsImdpdGh1Yl9zdGF0ZSI6Ik9lRjJBUVRrT2ZacVZwM2VIblVsUlc1NmJPUVVITWZxIn0:1tlt28:67lChcvfsavZqk6TDjMzxGR0dXH2jtC-ubRrYB5ALto", "expire_date": "2025-03-08T17:11:20.374Z"}}, {"model": "sessions.session", "pk": "6nielxne0mg6p8g5wdx4w5rk95iq8av6", "fields": {"session_data": "eyJuZXh0IjoiL2ZvcnVtcy9idWdfZm9ydW0vMSIsImdpdGh1Yl9zdGF0ZSI6ImxOeTQxZ2p3NWwxOVRYd3hJcTJJVG9scHZSdFlwUGptIn0:1tlt2B:933sii6-0zU7mvJ-lFGwScBE8VaPBdCBcpCQavr_tck", "expire_date": "2025-03-08T17:11:23.868Z"}}, {"model": "sessions.session", "pk": "6nua2yxyvf7ebmp9t2xt6vegunanxln6", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvNy91cGRhdGUvIiwiZ2l0aHViX3N0YXRlIjoienlGV0l5Q284NGdlZmlacU5CcVZnRGsxSjRNcVFsWXUifQ:1sCbL8:9ibOY2a_3kVfIBNTEQ__pR14hrbci03gqCNHsguCC7A", "expire_date": "2024-06-13T08:40:50.718Z"}}, {"model": "sessions.session", "pk": "7b251roh2xh5wsu9u2otyrnss2vujrss", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zYW1lLXRyZWUvSmF2YVNjcmlwdC8iLCJnaXRodWJfc3RhdGUiOiJwMjJqNTY5VUZoaFNSeVpXVnNNdFY0SjRIZzlQaVoxYSJ9:1tnfbQ:yxdMGnnvaCYCxxWIpWpo4EfdOSyLWjGJgEf0i6hAWEc", "expire_date": "2025-03-13T15:15:08.499Z"}}, {"model": "sessions.session", "pk": "7ea10aw0ft7wq99fav1rejn1kco4jymg", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9ob3VzZS1yb2JiZXIvIiwiZ2l0aHViX3N0YXRlIjoiZHJCblYxMzZKR0J4bDNwck5ZMzVpTmlqcWpwa0xIQ2UifQ:1sCgVc:B-pg4ecUgWC5XJc9d1oOzbnM3_nLDNSBTuX5-wrB-bQ", "expire_date": "2024-06-13T14:12:00.817Z"}}, {"model": "sessions.session", "pk": "7f71t63wd3uszcns27mtpoyitzy0v75q", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6InQ4MG9tSkRmSk5IZlBDdWVhZjlGbDh1OFVqVzc5dU5EIn0:1tlt6M:vckXY0iiBPJj86m2NsnkiFj2wrFKjOh1i72KpFSukXY", "expire_date": "2025-03-08T17:15:42.757Z"}}, {"model": "sessions.session", "pk": "7yvnapkyi3mtxdzca8ez1ttzdi3qu45b", "fields": {"session_data": ".eJxVjstuwjAQRf_Fa5RiEz_SXaW2PDaIir5W1ngyJoGQSNiWihD_XhdYlNVIZ3TuvSfW009kj-yBjdimjU1yNkSIlNFqZ77mjn9-yFk6pkV4Duv99h3Um6hezffsJRsWUmxsCnSwbZ2VyT1zgDvq_x5hwBY6i8OBihsNxbWvmF7O8ilr4t5vIDRZrkTJNUmPXlINRiunvee-NkLhRCippea-UoiCSiCHzhg-LkkKHBtwTuXQW_8luoMQbTds2v7fwOsWdv4FiBda8A:1sKEKe:CKU5OZyut8MiVkorDx6rHfhuravCaoM4GYTf9mS96Yg", "expire_date": "2024-07-04T09:43:52.523Z"}}, {"model": "sessions.session", "pk": "7ztjrj2nfkf3fqax1vhgc1x3oiff9121", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvZ3JhcGgvIiwiZ2l0aHViX3N0YXRlIjoiOVhXbWNXSkV3ZHVpc1hEcGdHOGRUSjg3bDM1eFdEU2cifQ:1tltCY:JAd7UAmxqw1ZGdg1RGUrHxVCXjUwK0FDKDU3y96dVD8", "expire_date": "2025-03-08T17:22:06.818Z"}}, {"model": "sessions.session", "pk": "8k201b4clhuqowbeoego3ed1v9y252eq", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1rzeSY:E0BrtXocovWbXo135fLYCppRdsU51dkP5GhKfesHnrw", "expire_date": "2024-05-08T15:22:58.023Z"}}, {"model": "sessions.session", "pk": "8q2zntes5hzv57bu7pvw0dh2ulppkbz1", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90aW1lLWJhc2VkLWtleS12YWx1ZS1zdG9yZS9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoicnFXaUl5ZFJMSjB3b2dUUnlTNjBJS3ZpS0l4bXB2VEUifQ:1trsFx:eMcPPYHHgBrQ1lkRig9LdzwmQKvj6_ybc7KEJ0uZEaI", "expire_date": "2025-03-25T05:34:21.562Z"}}, {"model": "sessions.session", "pk": "8t5hizow8vz964pgdgc8zuw66n9v919f", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wYXNjYWxzLXRyaWFuZ2xlL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJ3VlJQZ1daZ1V3cnJwRmZKQ1RpYlJIcGFNZFF4WTV6TiJ9:1tltrH:EwXIHVLkNDsNKfsoFgXe4LAvkEHBwVhQhLI077I01Wk", "expire_date": "2025-03-08T18:04:11.624Z"}}, {"model": "sessions.session", "pk": "8z4jj9xgksd5iyqc7h8cnh69z4aoacqv", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLWlpaS8iLCJnaXRodWJfc3RhdGUiOiJsdHdYdDFPako1WGlzWEZXd1JXM2lpNFFtQ1E2WVJPRyJ9:1sCz4x:37rZMsWhQG374aXVPYNuI43uMBPkW_lg0YDWAwjEpOo", "expire_date": "2024-06-14T10:01:43.144Z"}}, {"model": "sessions.session", "pk": "9amstq7wkus9369j63qo90ale2f81n3m", "fields": {"session_data": ".eJxVjstOwzAQRf_F6yrETvwou8KiQmoLrFha48m4STGOWjsVBfHvmLYLuhrpjM6995tF-szsnt2xGdsOuZ-cTRkyFSSPD4unt93r7vTYRL7Z7JcxfLysg1t9NfJ0rIthYcq9nRId7NAVpbllDvCd4t8jjThAsDgeqLrSVF36quX5PC-KJm79HlJf5LlouSbp0UvqwGjltPfcd0YobISSWmru5wpRUAvk0BnD65akwNqAc6qEXvvP0QFStmHcDvHfwMsW9vML5-RbYw:1ttyGx:HYfiwYClyhgafghLxAynaYpvCUnd9-0PPqQgZ8QWMhc", "expire_date": "2025-03-31T00:24:03.504Z"}}, {"model": "sessions.session", "pk": "9jiuljaw57j7nl1n2fjvtddcesgsfwxd", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi92YWxpZC1wZXJmZWN0LXNxdWFyZS9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoieDIxZndOZURiOXpZVDJjckxmeDNPcFE0TEZ5NDFDUGEifQ:1tltFR:LtxFYTfdMxe_oJGsIfDFHaD-GRpePmJe8VbzdkaEtXE", "expire_date": "2025-03-08T17:25:05.074Z"}}, {"model": "sessions.session", "pk": "9ms8s7q72uutnd8i9h8kgja0soe79nrn", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1rzDES:tvjMGqX3E8dsJqHFUSQGV86-gOaQQ9xi5sL00MeHlGo", "expire_date": "2024-05-07T10:18:36.670Z"}}, {"model": "sessions.session", "pk": "abbs3sxp2xqj59br3c8h464grmvu4ymt", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wYWxpbmRyb21pYy1zdWJzdHJpbmdzLyIsImdpdGh1Yl9zdGF0ZSI6IjFmWHgxdWVOWEozeFVicWtaUkVWanFNeVlaVTkzRXJFIn0:1sZuBK:zPdYANxpWuja6mKYIg-XlxIY7SyertpI-KqzJyFGD5M", "expire_date": "2024-08-16T15:27:02.416Z"}}, {"model": "sessions.session", "pk": "ac7mt6wkurs3ow8ygwwjo5hsfsj22jg3", "fields": {"session_data": ".eJyrVspLrShRslLSL6gsycjP00_LzEvRzc3My8wtzdXNzNMtyi9JLElN0S3OLwJRiUVFiZX6ARC1SjpK6ZklGaVJ8cUgRUBTXCpSU8KNkywNfbMtPUNTCpMD8qISS8xNzb0tCpwsDJyVagEUGydV:1sZjiU:Gt0pSc9tNHMZKcVOPFytX6Eh2GIrwTo361stfU7w8xE", "expire_date": "2024-08-16T04:16:34.043Z"}}, {"model": "sessions.session", "pk": "aob3tcbuc2o8iquj5k2shmjj9tfocfy5", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zdW0tb2YtcGFpcnMvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6Im1MMFlKRk1ySG9xNXRhOUNUZTdrczk4UjFwaVQzWnk5In0:1seMYu:4h9hjJqho1wBqSynKG_yrhK-6bncZQGRImcYPf-d0Yo", "expire_date": "2024-08-28T22:33:48.161Z"}}, {"model": "sessions.session", "pk": "artrwl6e8shz7yh9t1f89erhwtejwxmi", "fields": {"session_data": ".eJxVjssKwjAQRf8la6lJG9PGXVUQXCiCG92EyaMmtLS2SUUQ_934WOhq4Azn3ntHrbkFNEdTNEFnF-wohQ8QTER00W9soPXe8f6yDGty3K6up7rPD1yXt-EaDQFjsGL0ZhBOv5R_JkHVpn09fKccNEJ1g0m-1CefvmT9Prsyaum_b8HbKKc5mylGGPBCSsKMzgzWEjJCK45pjnnBK6UhyxmrJCHSYEJnrEix5DTVmsXQb_87ugEfRNOdXfsz8LMFPZ7TIlqd:1t3k6Q:qhzMw8vvY-GlS9_BGjDAwrMoSC6-oF6o-LVqcRsNwQ8", "expire_date": "2024-11-06T22:45:18.521Z"}}, {"model": "sessions.session", "pk": "ayqqvatcm74my3qs6t80v2fijhmq84ao", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jb25jYXRlbmF0aW9uLW9mLWFycmF5L0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiYnh6M01yRmpyQlkzdTZnSW9NMEFUamdQSElldWZSa24ifQ:1ts21u:_hj2b9lj9rKMIE5NZLSGlPCj4OT6qkW9SnuFx0wR7PQ", "expire_date": "2025-03-25T16:00:30.953Z"}}, {"model": "sessions.session", "pk": "b42ng87juijvw34gqy1ju0qjva8zymqh", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMy91cGRhdGUvIiwiZ2l0aHViX3N0YXRlIjoiR0xpSFpsU1RWcDRrVHJOeXQ0ZnVndlp0VHhzR3pTRnoifQ:1sCbL4:k0J8P0gSSvT3O-9FEZJEtt4ppqAiHdjBbnwGw-KH2r8", "expire_date": "2024-06-13T08:40:46.583Z"}}, {"model": "sessions.session", "pk": "b4ladi26pa7ci4roqi5dvc8kdqky8szy", "fields": {"session_data": ".eJxVjsuqwjAURf8lY-lN2jRtnDnwwb2IEwVn4ZwkNa2lgSa9COK_Gx8DHR1Yh7X3vpLBXiKZkx8yI6c2uglViBBtQtvxb_l_4B5KrLp-4w5-6bpL2eF-cVxtfnfJUDBFp6ZgR9WapPBvhqDPdng8gtct9Er70WZvGrJXX7Z-nt0iafm37yC4JOeVKLVgAmSNyIQ1haUGoWC8kZRXVNay0QaKSogGGUNLGS9FnVOUPDdGpNB3_zO6hxBV70_t8DHwtYXc7qp3Wmg:1sCoU7:UtVdBK0FIqpaW_qvwqwFl2JFCEnwMIsbBYwH6yLUACk", "expire_date": "2024-06-13T22:42:59.097Z"}}, {"model": "sessions.session", "pk": "b9ukh31tr2y1j2ydj5zgd0ie3kdl596n", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9pbXBsZW1lbnQtcXVldWUtdXNpbmctc3RhY2tzL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiWG9qdWhROEliM0FuNnBVVlNHYW0zcEZxZkppd1F5WFcifQ:1tltLG:IFpbOV6CFL6p0rP9r-xfrba85P-NvbpdAdMKZUxG0aY", "expire_date": "2025-03-08T17:31:06.895Z"}}, {"model": "sessions.session", "pk": "biep290x5nt6pvx884ejfnga3pg0d98b", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zYW1lLXRyZWUvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6IkczODc3Y0lLVTdHQThSRnR1R25VcnV3bVNOajBseEVNIn0:1tnVCG:PbouvwIQg2fQ9LSTymHsvf2f_Sx-mpoJo9qM_4fKD7A", "expire_date": "2025-03-13T04:08:28.092Z"}}, {"model": "sessions.session", "pk": "bpvvviyyih7iwlsb42l457zyc1v9cj2o", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvNC91cGRhdGUvIiwiZ2l0aHViX3N0YXRlIjoic2lyMk9UcldramZoTTRnNHN0RlR5Ujluem5GZ2VZdkMifQ:1sCbL6:3-p50S0wuoxu2n1wN9LZER2gZVRKfleKqdmAPSnW2DY", "expire_date": "2024-06-13T08:40:48.642Z"}}, {"model": "sessions.session", "pk": "c30294lh4h8nj0itlbsqifnx5pwprfek", "fields": {"session_data": "eyJuZXh0IjoiL3NxbC9wcm9ibGVtLzEvZGVsZXRlLyIsImdpdGh1Yl9zdGF0ZSI6IkZtc0NESWtiSXNjU0MxbGJnOTZUaFZ1QXBqZlRISld1In0:1tlt64:hKwxoYaXnsI9458emGvbbVpoP3Jvc5gBAj-YIi3I3Uo", "expire_date": "2025-03-08T17:15:24.729Z"}}, {"model": "sessions.session", "pk": "cl9zty4ba0dterazzbe8ki6sht92truo", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IjVEWWFNQm11QTE3M0lnejM1U2dUV2JUbWhJald5Z0hsIn0:1trrHK:EZ_WKdL9VG6cMiZb0nNE2FsE4O3dqTyK7GfDZJzD1eY", "expire_date": "2025-03-25T04:31:42.032Z"}}, {"model": "sessions.session", "pk": "clcezy52or1wguybsgndeswmqo8k4rw9", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9vbmxpbmUtc3RvY2stc3Bhbi9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IlpZc3NqOTFDd3k0NUZKaGlpbGQzVXF4dzFobHhma1ZSIn0:1tniE8:ZMNjyTMz6BzJi3qpyH8jEJdrGHlcS63g2mZDCHqyH3U", "expire_date": "2025-03-13T18:03:16.754Z"}}, {"model": "sessions.session", "pk": "cpilefgdkhopybb9t3ky3mmt9gy7pbl7", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9tYXhpbXVtLXByb2R1Y3Qtc3ViYXJyYXkvIiwiZ2l0aHViX3N0YXRlIjoibDU3Ykhyc2wwRlcybDNPSnNHQkxHYkhpekZNM29QVDMifQ:1sCzJg:EBpW9UIdnUf_nVFALFX25dzR1wSrXFX8VDvRk1p1b-k", "expire_date": "2024-06-14T10:16:56.620Z"}}, {"model": "sessions.session", "pk": "cw3lzadwkvk8u38zs1x6lko50c0v1u1k", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9ndWVzcy1udW1iZXItaGlnaGVyLW9yLWxvd2VyL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoib1A1TjVOVFpUTm4zc2g3UkRYRjZMZ2tkTXZoNjJ5ZVMifQ:1tltF5:3ObWXNdDFQPOrpra9PcGM7BsRciD7kFXbl7-apQ63XA", "expire_date": "2025-03-08T17:24:43.547Z"}}, {"model": "sessions.session", "pk": "cyhvwt5eqexvg6zmnd7caxvkf751s8kk", "fields": {"session_data": ".eJxVjDsOwjAQBe_iGlnxZ_2hpM8ZrF2vwQHkSHFSIe4OkVJA-2bmvUTCba1p62VJE4uzUOL0uxHmR2k74Du22yzz3NZlIrkr8qBdjjOX5-Vw_w4q9vqtwzUDZQtusAqiUojEIXhjiGGw2mKMJrC20RhwpJ1Hdt4gqwzZM5B4fwDHeTdB:1ryI0C:Jm9zmlumYKVCpA8Y1SXTuXU29ejZiOFb9JocyTzn90c", "expire_date": "2024-05-04T21:12:04.955Z"}}, {"model": "sessions.session", "pk": "d5xbzkvefd3hq4iuqlm8l31tayw1trst", "fields": {"session_data": ".eJxVjstuwyAQRf-FdeUaYh7uLsrClRq1zSJrBMNgUCxbMbipWvXfQx6LZjXSGZ177y8Z8TuTF_JMnkgfc1isTtlkLOjYbn7o9ti9foXDfjOftt2u7t9O77Gxzn3yVAxtlhz0knDW0RVl9cisgQOOl0eaIJpBwzRjdaepuvVV3fV8rIvGHv1gUihyyxoqkXvwHJ1RUljpPfVOMQErJrjkkvpWADBsDFqwStG6Qc6gVsZaUULv_dfowaSsh6mP47-Bty3k7wwKmluH:1sQX8e:0uihkqUo-5NeCX8KQEXHZygOmiITXZj0Qp2kSnx_MrU", "expire_date": "2024-07-21T19:01:32.115Z"}}, {"model": "sessions.session", "pk": "d6o9f528b1ply7j83kjyfyp4tgshoale", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90cmFwcGluZy1yYWluLXdhdGVyLyIsImdpdGh1Yl9zdGF0ZSI6Im1NWmdJUm43V2FONlBVdVF5N1lNVDlEaDlZOXRzUUhUIn0:1sCrhK:eIOHkTv5utkrXup3BxqNF6GMmwDPdtknTtLekohFcUE", "expire_date": "2024-06-14T02:08:50.981Z"}}, {"model": "sessions.session", "pk": "dbetd5wnrdokrpdidhyigwwb95w3o12o", "fields": {"session_data": ".eJxVjstqwzAQRf9F6-BGE-vh7gIt6aIki9CWrIQ0HllKjQ2RTAyh_141yaJZDZzh3HsvbKA5s2f2xBasizlMzqRsMxW09XAI3DXwOp_n9y5CftkfA-DX4eNzfjtvi2HslIOZEp1MbIuyemTO4jcNf480YrS9wfFE1Z2m6tZXba5nty4aPPrBplDkBmquSHj0glqrlXTKe-5bDRJXIIUSivtGIgLVlhw6rfmyJgG41NY5WULv_dfo3qZs-rGLw7-Bty3s5xf_51uA:1sR7oI:8VL9qYQyiu_4oHW0zyAx_QA2kXBUcWrO9gCD-1jgvUI", "expire_date": "2024-07-23T10:10:58.835Z"}}, {"model": "sessions.session", "pk": "dj1b9g7cjdya4kpdjg0u6meniu86can6", "fields": {"session_data": "eyJuZXh0IjoiL2ZvcnVtcy9mZWF0dXJlX2ZvcnVtLzEiLCJnaXRodWJfc3RhdGUiOiJFc09QaHZ4c0hFQmJaQnZuOEhPQUV2TjdpV3BoWDAwRCJ9:1tltF0:LJ2yXrMap9m7LHxmwkBwkAw9WPGYTRFXSAj-TXw6mmg", "expire_date": "2025-03-08T17:24:38.039Z"}}, {"model": "sessions.session", "pk": "dqk8n9kpz6ootaapuaq36kouaxces98g", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9maW5kLXBpdm90LWluZGV4L0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiRWJOcTJZckloSHdOVTNXT2U2U0x2V1JiSkMySk5lNmUifQ:1tltEG:PTguIZRbnN56aD3E8xu_yDnYoKNNOlXbKsN8BleSPoU", "expire_date": "2025-03-08T17:23:52.000Z"}}, {"model": "sessions.session", "pk": "ds5c3rf1863wj4z6bskd735zfivyulkh", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jb21iaW5hdGlvbi1zdW0taWkvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6IlBRVzFDNGQyV3A3c01Ucjd2dkJLUVVGSm1odlVEZ3hlIn0:1trxOQ:yvrCvM9_NbZHAAoD39M7aJixIJ3TEnnW7yxE3z7N8yg", "expire_date": "2025-03-25T11:03:26.107Z"}}, {"model": "sessions.session", "pk": "du8nnr9qyyte9gpe04yf5zoulbwbieqc", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sb25nZXN0LXBhbGluZHJvbWljLXN1YnN0cmluZy9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IjBwcExqMmtwVnpWZ1FxZXMxSW5SbTJtR1FuUjR6N2RLIn0:1tniKI:LM5fxxdBJDUsXqWvQc3Os4VWZJivC3ViX8NPYa3qRZk", "expire_date": "2025-03-13T18:09:38.616Z"}}, {"model": "sessions.session", "pk": "dv4yvqvzxlytuyvwy4i4o1714bnrcsmu", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMTMvZGVsZXRlLyIsImdpdGh1Yl9zdGF0ZSI6IjdYUXVTc0JZSFptOEtaUloxaEtPdzJIWDlKTnNtejZ4In0:1sCt0L:sf0Lg3T-xjRB_c-vOpkVAoRLw9A6mkkjSr9fHTrSdgo", "expire_date": "2024-06-14T03:32:33.716Z"}}, {"model": "sessions.session", "pk": "dvz4mb1hn9g8gc7ps33hnwte9x2f532m", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJZdEJqNWhiNWZaM3pEa2tTdGc2R0hmV3kya2JqTTJBcSJ9:1ts7WV:z8dMdQNNzA3XaCqYQ56QyxykGNK9RIxE_moG87mLPW0", "expire_date": "2025-03-25T21:52:27.884Z"}}, {"model": "sessions.session", "pk": "e43hz2betzgcpd6ug9dbxp2uafotllig", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9tYXhpbXVtLWZyZXF1ZW5jeS1zdGFjay9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IktMb2RLY0FsNVdweWNqY3NRamp2WnBlUEw0VEhHYm1RIn0:1tlu5z:A-wDctqOf2XyzHrKe9VBXKoTjG0WUg_a_ygPN8bW-AU", "expire_date": "2025-03-08T18:19:23.471Z"}}, {"model": "sessions.session", "pk": "e5fh8d0hq74imb5vuhhovt8g6jy2nhyl", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9maW5kLXBpdm90LWluZGV4L0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiRlNxYTZibG5CMERlMFdJTWY5cXVCNE9RN1V0Y3RxQ1cifQ:1ts853:7EPFZZPQQzwFrnyHqhSqiBSw_2sPudzcsxPr3zWjjiw", "expire_date": "2025-03-25T22:28:09.025Z"}}, {"model": "sessions.session", "pk": "e7obfn8z2gf6rtp9lian2v2hn20dsu62", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9pbXBsZW1lbnQtcXVldWUtdXNpbmctc3RhY2tzL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiV3dmSzMzcXNLVVA1NTJpcWRFMDFiSjBWWlJWa3hVV3EifQ:1trxGj:RkkTyB8iyc2ohhAlXQE7irH2b9GI0jEwC9Y6qPgCXUw", "expire_date": "2025-03-25T10:55:29.992Z"}}, {"model": "sessions.session", "pk": "eqfulle65ynme9dba8xqdxc9xs4q9er9", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jb21iaW5lLXR3by10YWJsZXMvTXlTUUwvIiwiZ2l0aHViX3N0YXRlIjoib29RSnppd0EwQ1VFN3Jaa2VBSjVhM2lwd0ZrOUNLR0oifQ:1tnibc:ky1-qzSPToploIEsE-Ly8D5J4FNUbtzgaI_8s_hmAR4", "expire_date": "2025-03-13T18:27:32.068Z"}}, {"model": "sessions.session", "pk": "euu4tbsjv7nevg7r488q7w76w8g7on3c", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMTMvdXBkYXRlLyIsImdpdGh1Yl9zdGF0ZSI6ImpyenA4V0dHTFA3WWxWZGJDQVZ2MVQyc25UOXluMnBRIn0:1sCbKw:emnFyxIHmpmgMNWgzKBw1le5zekLCpgyOxh11C7GgV0", "expire_date": "2024-06-13T08:40:38.337Z"}}, {"model": "sessions.session", "pk": "exmtq8p46sfbi2i5d139krq4ydkn8d46", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9kZXNpZ24tY29tcHJlc3NlZC1zdHJpbmctaXRlcmF0b3IvSmF2YVNjcmlwdC8iLCJnaXRodWJfc3RhdGUiOiJiQlpRN1lNNGNKOHhGR09IM2xyMEZOeGxoc0RYTkVEZCJ9:1trzVl:82tk4fTb21t1DlAaTR5v4l5JIBzkR6izkeShjTFo8DU", "expire_date": "2025-03-25T13:19:09.902Z"}}, {"model": "sessions.session", "pk": "fiugbd5hblwaflaagm5kty2io2jz8ogt", "fields": {"session_data": "eyJuZXh0IjoiL2ZvcnVtcy9idWdfZm9ydW0iLCJnaXRodWJfc3RhdGUiOiJxSjI4NVpqWmJFcVNjNVZkd1hwUHR5dUUxWDBzUUNPeiJ9:1tlt4L:rKwsAeNMqOnZOPsy5dGsDE3qUspXQvNQpaYZLFBrClM", "expire_date": "2025-03-08T17:13:37.576Z"}}, {"model": "sessions.session", "pk": "fkx052qqmych8t4xjx6xfsyc0dne2k7i", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMjIvdXBkYXRlLyIsImdpdGh1Yl9zdGF0ZSI6Im0yREZVdFY3NlUzVDdhZ1RoNFI3dnVyaktMQThsUXhmIn0:1sCbKu:1eVRYvKM1CjGu9MgthdSIBdRczldj1VsnhK1Hgx28i4", "expire_date": "2024-06-13T08:40:36.271Z"}}, {"model": "sessions.session", "pk": "fvi25gi27pvqbgiv7ruga8ckmnqj97pn", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9leHRyYS1jaGFyYWN0ZXJzLWluLWEtc3RyaW5nL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiMXptODJDM25YUGl2WnFqb3dSSkJWdHVFN0d4OGZuNWYifQ:1tltln:frnoCXPB_FXVcW_HQpdn-kmJsvNGYe2a0MQtnwRkY1c", "expire_date": "2025-03-08T17:58:31.666Z"}}, {"model": "sessions.session", "pk": "g0sw9fnlfjdivmkrtdookm89j65liet5", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9leHRyYS1jaGFyYWN0ZXJzLWluLWEtc3RyaW5nL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiYTNIVEJOeFFUZG5kd2F2M256YkR3VnF1V3RVbTNjVHoifQ:1trs2C:ZbnTMnzf5IlHbNbbUbYjsiVNv_keaVCwUtwNLQAzNyw", "expire_date": "2025-03-25T05:20:08.800Z"}}, {"model": "sessions.session", "pk": "g5d4xnz2z1vatbl5q88rv60sko1u4m36", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6ImdhVEF3WVVtYVJXRHBDZVAycUs4dXB5WnlxWnBMQlZVIn0:1tpcEX:BQh-Z2_I6_vxVN7-4tpUbF0cCzMMrR_kHMyjB28RLQ0", "expire_date": "2025-03-19T00:03:33.992Z"}}, {"model": "sessions.session", "pk": "g8eebg8eprgbewqyrwhqzcqjxzzi4ezr", "fields": {"session_data": "eyJuZXh0IjoiL3NxbC8iLCJnaXRodWJfc3RhdGUiOiIyY2F2SEl3RTFYdHJia1dxM2xXMFBiRlkxT05WNVJuMSJ9:1tlt3X:b6U2Ks7Jw25PYf_BR7rjJRXni16W1-MnztDFHiyJSkQ", "expire_date": "2025-03-08T17:12:47.490Z"}}, {"model": "sessions.session", "pk": "gktnkhedz8gcyzkrgqos8o132n8wxiwz", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZXZlcnNlLXN0cmluZy9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoiYnZTdm5rMXhSUmFmYUZBbEI0elBZZFhaUUZBQk9sME0ifQ:1tltIE:qZRrDlUaVfZl7bm608dSpYZah4EUCMBFX-hd9IjVd2k", "expire_date": "2025-03-08T17:27:58.430Z"}}, {"model": "sessions.session", "pk": "gsqnn8q1edcylcggx52af44nwaogv9kv", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9kaXJlY3Rpb25zLXJlZHVjdGlvbi9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoiSlA5UTNsYmk2N21YRkZtWnBISXplMkRubzZkSDFYam8ifQ:1tltR7:Z_BLdFhbsPXDitTgQIBu4lC2GBSJkGjpu20er9xPfz8", "expire_date": "2025-03-08T17:37:09.728Z"}}, {"model": "sessions.session", "pk": "gt78o9ka02wjgxingll27ycojqpoeybi", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvNS9kZWxldGUvIiwiZ2l0aHViX3N0YXRlIjoiVEtCbmVSTFFEbndDeHZFYmZUb0xSZTliV3NjZVBka0wifQ:1sCrcR:Cs5Zm44DL7KM_DavJZ3hsz9KX6VLiDR1oQIH6D40eCI", "expire_date": "2024-06-14T02:03:47.529Z"}}, {"model": "sessions.session", "pk": "gteyhp2unu5gauv02u7jgqnb6jxm2bok", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sYXN0LXN0b25lLXdlaWdodC9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IlZFdkxXQ1E5UUx4ZGZSeWZxRGZaclBaN2RYMFB4N0dHIn0:1tne3G:tSISw7Al82z9UhPbaghHEXkOSbhO6Ilqeu3Y3_eo8AA", "expire_date": "2025-03-13T13:35:46.763Z"}}, {"model": "sessions.session", "pk": "gu1990nkqzgo5i906j5fu3zadvyw8x1q", "fields": {"session_data": ".eJwVzLEKwjAQANB_udkjdNDBTcShLi0UBV3kmqTmsCTxegar-O_q_OC9IfqnwhpMnjWkaGzw9oY8oAYvHnlCwkIjO8wkysop4pDkz0giNJs9FeqscFYDC7iyhkd_mZTU_9p2c0ztIa2ayjVa2_ur2rr6XPrdqXDslyN8vuanLic:1tltCG:5hdi9j-xjVxoriJ2vWtpeSg6tMzxLkKiRxQyFrUFqF0", "expire_date": "2025-03-08T17:21:48.295Z"}}, {"model": "sessions.session", "pk": "guwhroklv2x97x6xqcfjqj8qnrv4133v", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMjMvdXBkYXRlLyIsImdpdGh1Yl9zdGF0ZSI6IkZOZVMwOWg2dVVYZjVTd0R0bjNOTzRYbDdEWll2U2ZGIn0:1sCbKq:2H8Zy8D5whzN_raLZEXKPi4nc8ZjjkltLuz2NKVJxxM", "expire_date": "2024-06-13T08:40:32.529Z"}}, {"model": "sessions.session", "pk": "gxcvia9sbsrtqsa04qvzujl3whuby00v", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJuN0FFRGxVT21uMUpvaVdQbHE5ZU1lSG1jTWJQbzlaYyJ9:1tltF0:Sm6zX_dsyD6M7b-SpZsjmcucUizUUPzxhC0w8az6zw4", "expire_date": "2025-03-08T17:24:38.539Z"}}, {"model": "sessions.session", "pk": "h05ccjd7m59ylkvshntpxa7ih67irhgu", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sYXN0LXN0b25lLXdlaWdodC9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoiN2xNSmczdUZaczlPNmoycXA1RUZ2OG80SldodVRBSzEifQ:1tltSh:eukKlsoHJUiIvKdnRH7KS1fQpYdJNkHs-v5mlerQ_sk", "expire_date": "2025-03-08T17:38:47.944Z"}}, {"model": "sessions.session", "pk": "h35pg610sl94q5ew46uzl8ng61l42cbx", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zYW1lLXRyZWUvSmF2YVNjcmlwdC8iLCJnaXRodWJfc3RhdGUiOiIwanhRU29rUlhXTHFCSklyd0xxa3I0V0dWVVozVGdRTyJ9:1ts9uW:sXXN70Jj_wv-Y6ef5LpwccciNGdIBg_yDOPQZ6gf1wA", "expire_date": "2025-03-26T00:25:24.734Z"}}, {"model": "sessions.session", "pk": "h4r12z9to17lhd97ks9b9oyfhofqjjfq", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wYXNjYWxzLXRyaWFuZ2xlL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiI5eUVQeWdNRTd2bzlxeWhua05HbnZxUTZPdEROYUNsciJ9:1tluH2:ctSQ64dzL3AiwjO9uOgi-q6UVF_vWyQP1thQleXkRi0", "expire_date": "2025-03-08T18:30:48.469Z"}}, {"model": "sessions.session", "pk": "h82uw2377hba7d4zrogzbpoo6x957elz", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90cmlhbmdsZS9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoiMXVUNEh2NUxUcVZRcTF1b1NHczRRVVN5Vkk1cWRkbnoifQ:1tltRd:hWsBFiCfDbC7-Oqv7Y2hVpJXErK68SKfFa_4-onXcU8", "expire_date": "2025-03-08T17:37:41.814Z"}}, {"model": "sessions.session", "pk": "hnw0i6o45vok6epy0rbiiivgjptecqki", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi92YWxpZC1wYWxpbmRyb21lLWlpL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiNFRQZnQ3eHpueWxxZXU0WndnaGpyT3Y1clYxNGZRNnUifQ:1tnVJS:Nl1KTtzrjgtC9q0p-gPk0u-zjVEOdZNeLBFbufdKdTg", "expire_date": "2025-03-13T04:15:54.795Z"}}, {"model": "sessions.session", "pk": "hv7s60dmp7vkrpqv2zgr9u8pllbgk191", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wYXNjYWxzLXRyaWFuZ2xlL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJJRnVPV2VpelBONFVDZXBJNjZTWEgyemZMdkF3R1NMNCJ9:1tltFn:1OGhTroULFn4TRMiYadQRnBwv0tNLLthBt7jF720rN0", "expire_date": "2025-03-08T17:25:27.174Z"}}, {"model": "sessions.session", "pk": "hz08f8wntnmee13imvsql0g5td4vg4w8", "fields": {"session_data": ".eJxVjk1rAjEURf9L1jKazOTD7koVFy0KhZbiJry8eZkJDhkwGVRK_3tTdVFXD87j3Hu_WaRzZk9szmasC7mfnE0ZMhXU4XBqoz7wt9c97bbn_TrWH-8n-fL1qbeXsCqGhSn3dkp0tKEtSv3IHOCB4t8jjRhgsDgeqbrTVN36qs317J6LJh79HlJf5KVouCbp0UtqwWjltPfct0YorIWSWmrulwpRUAPk0BnDFw1JgQsDzqkSeu-_Rg-Qsh3GLsR_A29b2M8vBaNbew:1sH7CK:umRZslRLBmgXhaOAvY_F9TGji8HW1iS7j1SjaL9a7YQ", "expire_date": "2024-06-25T19:30:24.343Z"}}, {"model": "sessions.session", "pk": "i3rkdsac1mzbahrx50eqqq1mi15498cw", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6Ik50TUJiMkxNZ1kwS0xHc0tVMDllMlR6cGpyaklBdm4xIn0:1trs73:U38pe1GHOwJS4Xv2tyTYbceABBMdRB7VtYpTnCF9bQg", "expire_date": "2025-03-25T05:25:09.742Z"}}, {"model": "sessions.session", "pk": "i8g8a45mhpeql79baobk86ojum9nr6a1", "fields": {"session_data": ".eJxVjstuwjAQRf_F6yolTvyAHQiUBZGyoapYWePJmESkiRQ7FIH67zWPBaxGOqNz772yns6BLdgn-2CHNjSTNT5AoIiKzbb82a-zcaKv6neg1U5fiqXsy5q-L6dsFw0DU2jM5Gk0bR2V7J1ZwCP1t4cfsIXO4DBS8qQ-efQlxf1Uy6jxd78B30R5zvNUkXDoBNWglbTKudTVmkvMuBRKqNTNJSKnHMii1Tqd5SQ4zjRYK2Pos_8e3YEPphsObf8y8LGF_f0DAsdbgQ:1tXNtb:c1Sr4WbOwc6XXxET80d_66zZXCEXQDZjuzppD3gogP0", "expire_date": "2025-01-27T17:06:35.181Z"}}, {"model": "sessions.session", "pk": "iat8vbdcbqa90n5i4icmuw974jxbqzf0", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi91bmlxdWUtcGF0aHMvIiwiZ2l0aHViX3N0YXRlIjoiRmdubHNzWWJBY1dTQ1BhTDhuZk1ka2tHTFh4N0NXSEgifQ:1sCbL2:6tZk7bAlq-H7rMQq5PwYmO4VTlTIxhR4lrpL5flkRhw", "expire_date": "2024-06-13T08:40:44.521Z"}}, {"model": "sessions.session", "pk": "idsnkvw6dkw9f7jheiyzucnxmuen7v4d", "fields": {"session_data": ".eJxVjjtPAzEQhP-La3QP5_w4ulSpgCDRJI1l763jCxf7ZPtEAPHfMUkKUq12dr-Z-SYez5k8knr-zC74eo7BTHhSEFFnrMkDOYzZLUalXPbyiB_dyewb6DdPMT1vm_XrcR48xrf99vy124VCKL1kp5aEUY1DQVb3mtHwjv7vkAKMelIQIlY3NVXXvGpzGS_rgtF73unkCtzTrhXILFiGg5aCG2FtawdJOawoZ4KJ1vYcgGKn0YCRsm06ZBQaqY3hxfSWf7GedMpqCofR_yt47UJ-fgEe12TF:1tcmbk:A4dtMLEIlscsHcqlSLPL3lnrUsD3P6JzQd4jU_gbL-4", "expire_date": "2025-02-11T14:30:28.811Z"}}, {"model": "sessions.session", "pk": "igtif11z59iwynbthbj8xzi61rz5j04m", "fields": {"session_data": ".eJxVjstqwzAQRf9F6-BEsvVwdy2BUFoISUigKzEaj2wT14JIhpTSf6_yWCSrgTOce-8vG-mc2Aubsxlr-9RNzsYEiTIKZhPeywPfHf3nYaXePrah3Nb7zfJrt95_y59sWJhSZ6dIJ9s3WSmfmQM80nh5xIA9DBbDiYo7jcWtr1hdz_o1a-LZ7yB2Wa5FxTVJj15SA0Yrp73nvjFCYSmU1FJzXytEQRWQQ2cMX1QkBS4MOKdy6L3_Gj1ATHYIbT8-DLxtYX__N41anQ:1tIaLh:tQqFveRZWdhsbuOZuE7XjYszNnGC_akmjqTPko1efEk", "expire_date": "2024-12-17T21:22:25.243Z"}}, {"model": "sessions.session", "pk": "ih5op24mtggf4oruzoixldxjkjabd2yb", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sYW5ndWFnZV9hZGQvIiwiZ2l0aHViX3N0YXRlIjoiNTJjYlQ4clo4SmlxeWNqQzJrMHZFY2FWYjlzS3F3N3UifQ:1tltGg:cGIKGVWWp0jG21YlNcmdbQnnHGYUy_YBn3iTPougnjM", "expire_date": "2025-03-08T17:26:22.776Z"}}, {"model": "sessions.session", "pk": "j09j4b2pkls2vattslrgsqliux38bu7b", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1sdqFF:xKFHhoBCYWdEm_OZf8ERT7cSTzR5lAEsMokWF0NgOyM", "expire_date": "2024-08-27T12:03:21.087Z"}}, {"model": "sessions.session", "pk": "j5e539ladn3uphxbk90zw5bnkyw2f62r", "fields": {"session_data": ".eJwNzLEKwjAQANB_udkjQ5fi5lARdRGRjnINZxK0uZBcW6P473Z8y_tC5LfCFkyq6iWalyxcFK2Mo0SkaFdJRnkg4RAi5YqFKVuPmpnNkWa62hySGtiAC-qn4V6UlNez29dB06xdu-v5tpw-jt2zaQ71Iv48tT38_ptkLd4:1ts0MH:RYm-pMVu1VcdUKyGfLfJ68YY8Svr7eYKh7MlFFfnpYY", "expire_date": "2025-03-25T14:13:25.077Z"}}, {"model": "sessions.session", "pk": "jabn4et5i38vo5hyhmie380i4so8fkdf", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zb2x1dGlvbl9jcmVhdGUvIiwiZ2l0aHViX3N0YXRlIjoiUU5IR1JCVVk0YWhTRFNKOWNXR3diTm1oWks5WHN6em4ifQ:1sWYmO:YJD7gdL0lW9U-vSixamAh5RqKn71J0hExOY2bbE74EE", "expire_date": "2024-08-07T09:59:28.275Z"}}, {"model": "sessions.session", "pk": "jdwrcbdgrpo5dh1lhf2l6aggek57jbu5", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9pbXBsZW1lbnQtc3RhY2stdXNpbmctcXVldWVzL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiS2xSSERZMVdqcVlmMU4yQVczUUFzY2p0bERFWGF3cUoifQ:1tltJG:EAIYeyh71yVN_EjA4fVUPAP0RrISzQ8xY8YHF5Z_DQI", "expire_date": "2025-03-08T17:29:02.021Z"}}, {"model": "sessions.session", "pk": "jiwd2wjyo9f8k886m75dperypyb6fea7", "fields": {"session_data": ".eJwVzL0KwjAQAOB3yeyRugg6Fuog4uJgcZEz5ueITdLrtdiK767OH3xvlexL1E7pMkvISZtgTQRyIMGyBRoAYcInPaAgCwnlBC7znwGZcdYHnPBsmIpotVKeJIz32yAo9tdeTvum5eXYtRvf9FTXYcF1tY0Yez9eK6c-X-lGLh4:1tltUH:VWw_zWEYLc3rkD3BYgRr2Aj9j6LG1AvBBqgyao2Oh1w", "expire_date": "2025-03-08T17:40:25.553Z"}}, {"model": "sessions.session", "pk": "jja0qll8pymzunz7h51c43znyjpemuiq", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9scnUtY2FjaGUvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6IjNCZ3U1RTVPa3g5bGpLOWZ0cDVPcGVmaDZxT3J0aEZ3In0:1tltJJ:SvWVFZUID3qt9LA5sX0bx334ile8rWm60tGDtkRLgQE", "expire_date": "2025-03-08T17:29:05.948Z"}}, {"model": "sessions.session", "pk": "jm89eioe7qh0qix3hkiz7tw1oezmf3sy", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMjYvdXBkYXRlLyIsImdpdGh1Yl9zdGF0ZSI6IjJZUE14a0V1eEZaN3FHMDBvT0ZHYVEyVjFaNW5mTFBKIn0:1sCbKy:U945GEqBxBqDnPrPQR51V0nsB9Ua6QT58d7aTwvxdlQ", "expire_date": "2024-06-13T08:40:40.674Z"}}, {"model": "sessions.session", "pk": "k00hzgnrjsvsrty400mlldek9c8lpigd", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wcm9ibGVtX2NyZWF0ZS8iLCJnaXRodWJfc3RhdGUiOiJWRGE4SGZKS2IxRlVvNW5ZRWhKQnRHbjc4ZXlxOU5LNCJ9:1trvhJ:X6L7n3vbZTXqYvS5tdZP_mFsSX1ink9tXZMk8fDzJ7c", "expire_date": "2025-03-25T09:14:49.062Z"}}, {"model": "sessions.session", "pk": "kdudsuz4xn0hma66df358yjys30vsljw", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1sGGM0:WRpCkVk8-9cZewIADodgLQbsEu3Cbox-8ZKaJgDklDg", "expire_date": "2024-06-23T11:04:52.627Z"}}, {"model": "sessions.session", "pk": "ktk2he7z50jxxvr7tegup7mrxberfwx1", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0vUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6InNsNEVlb1BZVEszMm5LV1g4aW5taG5IakhiY3VPSzdvIn0:1tryf1:2lz7BKEiB-zBS-qsDaPaZkzUAcQFbFS2sPo0Qf-H5fs", "expire_date": "2025-03-25T12:24:39.730Z"}}, {"model": "sessions.session", "pk": "kulitj8j4gnlld4apoxx02w9nc29d1r5", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9ndWVzcy1udW1iZXItaGlnaGVyLW9yLWxvd2VyL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJRYThkRWw5OG55WHY3WVVhekZoSFU3OEpJaW1Zek13UCJ9:1tlt5M:6J6HWb-WHuwtRyQko2leCKMIjViiVuNyC_7mdT9AgoU", "expire_date": "2025-03-08T17:14:40.159Z"}}, {"model": "sessions.session", "pk": "l1tg1vl1e3gcv8hclddjhf7yxrhpxpt5", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6IjFTWFl5NlJHbmhvZWhwZno2OWozeEtVVE5nRVRJbW5CIn0:1s2TLw:VwW57aN5mkZhbnbOjaC8wIsNXour1vZrCerXybegr0o", "expire_date": "2024-05-16T10:07:48.362Z"}}, {"model": "sessions.session", "pk": "l6veusjquwjfcgwlws0n4pk8ap8h2n4s", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90aW1lLWJhc2VkLWtleS12YWx1ZS1zdG9yZS9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoibWYzaHcxSDBRbHV1QnM3c0hFdHVyMzFHOVJzaE10Y0sifQ:1tnPCs:z8VbPxmJ7Df8j3bZPujcp_BlJYNbEfVuOU71Onp8gMg", "expire_date": "2025-03-12T21:44:42.801Z"}}, {"model": "sessions.session", "pk": "lh0w812aqxzz0vtp63zcn6djj32y5pro", "fields": {"session_data": ".eJxVjstqwzAQRf9F6-LaivVId4aQhrSQRaDxToxGo9jEsUgkQ0npv1d5LJrVwBnOvfeHjfSd2Bt7ZS9s36dusiYmSJTRVu5acMfL8fMkwrgIuGzbxcfXdu3tqjw1LhsGptSZKdLZ9C4rs2dmAQ80Xh8xYA-DwXCm4kFjce8r3m9n02SNP_sdxC7Lc15XioRHL8iBVtIq7yvvNJc441IooSo_l4icaiCLVuuqrElwLDVYK3Poo_8WPUBMZgj7fvw38L6F_f4BGVFbkw:1sHQ2s:Xm3Ozc2VjCvjO7yz7BeqYBurpbkQ822PERT68auJRSw", "expire_date": "2024-06-26T15:37:54.941Z"}}, {"model": "sessions.session", "pk": "ln4w7uyzn10csh232xutr3bgwoc7ca2s", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZW1vdmUtYWxsLWFkamFjZW50LWR1cGxpY2F0ZXMtaW4tc3RyaW5nLWlpL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiT2lDTTAyQXNYa1FURTloNXVTbkhKVk5TRG5EaFlDYzkifQ:1tltCC:Dz-Z4aZJYybLbQnvrOq0CP1Nc6PEpZvfF1p6_rYnJxk", "expire_date": "2025-03-08T17:21:44.280Z"}}, {"model": "sessions.session", "pk": "lt0j3qyof29p641027d8cf51belx61pv", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1rzF8d:oZzCtISEYea7JLvHNPKI9HTa-fS4QTxtAVPOE4722T8", "expire_date": "2024-05-07T12:20:43.185Z"}}, {"model": "sessions.session", "pk": "lzrz45gwktjva65th3r93swxfhoncg1y", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvNi9kZWxldGUvIiwiZ2l0aHViX3N0YXRlIjoiVmpSMGZ6T0V5NllMNEpMM1dIaWJXR3VndXNWRjJpMGEifQ:1sCt0V:SOhPLpGrCFC7qXwYk890M2dbAVrv5DA5BXjSA9jfUHM", "expire_date": "2024-06-14T03:32:43.947Z"}}, {"model": "sessions.session", "pk": "makfgeat9e2bww1k4qn6wbowh6cidkvn", "fields": {"session_data": ".eJxVjj1vwjAURf-L5yolJv5IN8LQoUPFAt0sv-fn2NRKKuxIiKr_vS4wlOlJ5-nce7_ZROfCXtgze2JjLGEBk4stVNFlD91hM7z1u-08fG3hMH70Lh9BKDekFGI1jF1KMEumk4muKutHBhY_afp75BmjTQbnEzV3mptbX_N6Pe-bqvFHP9gcqtzzrlUkPHpBzmolQXnfeqe5xDWXQgnV-l4icuosAYLW7aojwXGlLYCsoff-a3SyuZg0j3H6N_C2hf38At11W1o:1tp4zN:RklJMQqjJPvsI1oqqYz3HYJVdw71iO90SexvhX1mLzg", "expire_date": "2025-03-17T12:33:41.214Z"}}, {"model": "sessions.session", "pk": "mhusbekkzmzwfnnl0wg6dfh5yu9vokht", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZXZlcnNlLXN0cmluZy9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IlhFMWcxUExyYUJsRU5MbGdsdUR3WHNXRGRQYnhZWEhwIn0:1tlt70:IW9VLtlgW0s_14fanxWpeZ4Wv4JmM9cYhNGkHMfEMig", "expire_date": "2025-03-08T17:16:22.362Z"}}, {"model": "sessions.session", "pk": "mr0urktv11us2pwtszi1ge1keyv5j3nr", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1sKEOq:DEi1sNuTxPyv3D7-UOSOUkZd5RWFhoQu7mV34aj-JGU", "expire_date": "2024-07-04T09:48:12.952Z"}}, {"model": "sessions.session", "pk": "mv12a7c90ots4r7ek4wx9uk8x0uw0v3l", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6IjRyc0hnYjBkalJqcVlxbzJwVjlLOFNQZU5qUm9mN3MzIn0:1tlszJ:9yO2M3_vTqt6ojz3InnAIjnuepkTOXwzESi6uDEhq70", "expire_date": "2025-03-08T17:08:25.681Z"}}, {"model": "sessions.session", "pk": "mvh7szm5iiigestywab8o3oltxai8arh", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJEWWdORFYxTXJnN1lGcmEyak5tR2NuUTJ1d0o2c2NiMyJ9:1tB6rT:TB6F0NKjRNA-RPwHKSGn0N_PEp0y44kwB-NIQaO9498", "expire_date": "2024-11-27T06:28:19.563Z"}}, {"model": "sessions.session", "pk": "mwwil58nb1f2o8z4l9ttdshesko43slb", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9rdGgtbGFyZ2VzdC1lbGVtZW50LWluLWEtc3RyZWFtL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoicWs0Tndyam9KR0hDNm9mUWdlUldudTlqcDRWOHlXQmUifQ:1tltHT:cRRNRG2zrrAHeik_2CalwnCLuhyamGwmhaJ3ePp_pPw", "expire_date": "2025-03-08T17:27:11.329Z"}}, {"model": "sessions.session", "pk": "mz1t0r2ivcpt3pw4ydlbqwmuc8gc6p9q", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zcGxpdC1hLXN0cmluZy1pbi1iYWxhbmNlZC1zdHJpbmdzLyIsImdpdGh1Yl9zdGF0ZSI6Iks4SmRGSFo1bHpsU1NZaGk5VGQ3WGZrN2JGUzZqcXYwIn0:1sCJsP:wz4kwPCGnb_hxNtHnO9D1hDCWWj15NmGx01A-RIRgVU", "expire_date": "2024-06-12T14:02:01.579Z"}}, {"model": "sessions.session", "pk": "nf5107w1po45ff6m21if47bi8c421ba7", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9tZXJnZS1zb3J0ZWQtYXJyYXkvSmF2YVNjcmlwdC8iLCJnaXRodWJfc3RhdGUiOiJrbzJCNk1mbnppaTJKdUU3b1JPVW13THVkNVlqS3pJMiJ9:1tltIC:GQ6TbmrE0wOhOc5rgip4R-QZTF9h8P_AoLFRXAGMLXs", "expire_date": "2025-03-08T17:27:56.844Z"}}, {"model": "sessions.session", "pk": "njui2i7mpezcpfsismshmh8c81fi73wr", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9ndWVzcy1udW1iZXItaGlnaGVyLW9yLWxvd2VyL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoibzlSRnh4Q0s1Wm5PeVJYenBDaDloa0syT0hmN1ZSVEUifQ:1tlt4H:Vx7ULA5Kjg9vAQMhqMROfvj2iFP43RYIXe6wnzayQdc", "expire_date": "2025-03-08T17:13:33.055Z"}}, {"model": "sessions.session", "pk": "njvharrgphtjqf3pc8q3dt8x49gkruoh", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9kaXJlY3Rpb25zLXJlZHVjdGlvbi9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoiVmlIVURNeElxVEpLYVB5cHdMN25YYXYzbXVaSkxNRlAifQ:1tlt4l:xa8_JRV4VzafN-RsetMyG_8QTv8vaAXop_vUdDDfEkg", "expire_date": "2025-03-08T17:14:03.113Z"}}, {"model": "sessions.session", "pk": "o1qnp8wf83ue5c4vt37m0hnk8ylni7jy", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zaW5nbGUtZWxlbWVudC1pbi1hLXNvcnRlZC1hcnJheS9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IkxOTEdFeXR3Q3ZsZVB0WmZ0TU5TQndkYmFjWWU2dWkwIn0:1ts8zt:tWojpIiOgD0BVREf4togs4y5zz7iLhE7QtKeDuW34A8", "expire_date": "2025-03-25T23:26:53.207Z"}}, {"model": "sessions.session", "pk": "oc6kfkiltm42gka0gttsyb53rofpwcg0", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvOC9kZWxldGUvIiwiZ2l0aHViX3N0YXRlIjoiS3lDVlZZd0FQT1Y0NXZ6RzBTaVp1SFBZQnVSTmoxYUMifQ:1sCsve:_0JeN5FpDJcymGJskBwCF0LlXgrzJsFWB1K8BgnDKEs", "expire_date": "2024-06-14T03:27:42.065Z"}}, {"model": "sessions.session", "pk": "oswou1veyhrycjrqcq2ax19kri5hgmt3", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6IkM0cDZGYUJqNnVSdndQWUpYVld6TGlrb1FmZDNaSTNPIn0:1s2UBK:B7idN7v7C2afKDyLSEu0zWZlODRLXT8uHomqpAFSPaw", "expire_date": "2024-05-16T11:00:54.785Z"}}, {"model": "sessions.session", "pk": "p3w52ad8mr9oah1hppx8g5jux3l2d8s6", "fields": {"session_data": ".eJxVjstqwzAQRf9F6-LYivVwd4FACIWm0O7FzGhkixg7RDIklP571SSLZjVwhnPv_RYTX7J4FSvxIvqYhwVdypC5IE9f761823-aSB_pgipfJzz6ZVvvTtj1UAwHSx7ckvjsoi_K-pkh0JGnv0eaKcLoaD5z9aCpuvdVu9s5bIomn_0B0lDkTraNYRUoKPZgjUYTQhO8lZrWUiujTBM6TSS5BUZCa5u6ZSWptoCoS-ij_xY9QspunPs4_Rt43yJ-fgEk8Vup:1sKGeU:AF_3aMfJU1f5uf15quD4Yc8w2Q6dz5hcmZcksBusAUQ", "expire_date": "2024-07-04T12:12:30.734Z"}}, {"model": "sessions.session", "pk": "p86pl6ss26mmbbny741yg06keelhqqb6", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZW1vdmUtYWxsLWFkamFjZW50LWR1cGxpY2F0ZXMtaW4tc3RyaW5nLWlpL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoicEd4amJDWlkzYnVkRHhiOFRmVzViVVZLTnBCbTVWazYifQ:1tlte7:dxXTDq956WH9mTYggmUrhNys_QQZObuSqs7wemhk8Zg", "expire_date": "2025-03-08T17:50:35.505Z"}}, {"model": "sessions.session", "pk": "pauy5hpvej9ifpl1i25grzl01zwcot24", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvY3JlYXRlLyIsImdpdGh1Yl9zdGF0ZSI6InEyeEpPdlM4N3R1VVhQUlMyUTNhMjkwdGRIcXhyWEpnIn0:1tltFN:jHfZNjOFzrjPYc2IEvm40HY9Qad8WuvvdIbprOPVpiY", "expire_date": "2025-03-08T17:25:01.674Z"}}, {"model": "sessions.session", "pk": "pcl25ir4l5ep5r0cn8k9ywbsfwyipqfr", "fields": {"session_data": ".eJwNzDEOwjAMAMC_eMbKxFDGUgRlRUJsyI0MidTEwTGlFeLvdLzlvpB5NtiBK4sFyW6UD1dDLylJRsp-lSjKAwmHmEkXrEzqA5oyuzNNdPEaiznYwDNaeA_3amS8nsc59a1eK2_LodPu1DYl7l_Ux5uNjZ8Ufn-SxC28:1tnVn7:a4aoF1MO_Duokn9cTNP-Qn9yTC7oE22QaEhzek6XTQ8", "expire_date": "2025-03-13T04:46:33.451Z"}}, {"model": "sessions.session", "pk": "piu9x87ibt3fe2x130gu1qv9wsvifohy", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sb25nZXN0LWNvbW1vbi1wcmVmaXgvSmF2YVNjcmlwdC8iLCJnaXRodWJfc3RhdGUiOiJNS294QkxEaTBSb28xT25kYkZTTVdIdVR4bnhpM0R1TyJ9:1tltEG:ohuy27RE-htmA2VJ4nZlBSnxnot_xUKki3UM4FZaDhw", "expire_date": "2025-03-08T17:23:52.484Z"}}, {"model": "sessions.session", "pk": "pszhc1571vnx9x1lftc2js0r1retdizm", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9rb2tvLWVhdGluZy1iYW5hbmFzL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJURHJOem1TcGRQdjhJd3RESDVCTUs3RHo5b3FVYkpnSCJ9:1tce1u:GnftZxBqDrFFohQeHRijPxVaplF34VIJYingZHW4fWc", "expire_date": "2025-02-11T05:20:54.949Z"}}, {"model": "sessions.session", "pk": "pvw1q9wxljn03sovp0pm418dx9b1u287", "fields": {"session_data": ".eJxVjruOwjAQRf_FNQqJiR9st6JYHkWKLRA01ngyJhZRImInQlrtv68JFEs10hmde-8P6-ge2QdbsgW7-NiM1oQIkRKiYw6TzG-a9G36ruisNwdfbcrutN9Ootolw8AYGzMGGoyvk7J6ZxbwSt3jEXr00BrsB8peNGTPvuxrPtVn0vi730BokrzmZaFIOHSCatBKWuVc4WrNJa64FEqowq0lIqcSyKLVushLEhxzDdbKFPrqn6NbCNG0_cV3_wY-t7DfP29XWtc:1sKE59:OqiQMJHB7446hKiFaGeGgAbsJ70wmwUnXL2Bg3iKkLg", "expire_date": "2024-07-04T09:27:51.214Z"}}, {"model": "sessions.session", "pk": "q3284j8x1z6p02awyobv66kxgptkpbrt", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLyIsImdpdGh1Yl9zdGF0ZSI6ImFyV2JIMjltc1ZDSWo3RHZtcHpKOVlEbmZpT2l5UEJ0In0:1sCecS:jxyUrE5RzpkPbBeFeQjbTAtzL6M5Q1DmW8yYapMBsS4", "expire_date": "2024-06-13T12:10:56.833Z"}}, {"model": "sessions.session", "pk": "q4ygd8u3vqgbjfkuop9bha9fuexhtoj3", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90d28tc3VtL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJ2RFNJeWl4U3FrRXVNT2tjOHQ0emZWMTg5anJCMGpYbiJ9:1sZv9W:UHVzdVUghloopK1erwkIQ3ITYL27BRjepobZbo24JiA", "expire_date": "2024-08-16T16:29:14.187Z"}}, {"model": "sessions.session", "pk": "qbgfohcywgtmtantja8ub1sz49uz00qm", "fields": {"session_data": ".eJwVjLEKwjAQQP_lZksQndzERaJgQScXuYZLGihJmrtTi_jvxvW9x_tAorfADkxZZMzJTDkFYulYB5YaU-hesQmVrlIhlD9xI1Z0QpWNxSdeXY1FDKwgtFSHBwsKtafegou2z-o3cX_fzuXU-8NlWtt09rrwEb4_4qcusw:1tnX3A:mscfNpL-HHksXK4Vq5NSgSkR4Gn7mPLBUHTq305lkzA", "expire_date": "2025-03-13T06:07:12.077Z"}}, {"model": "sessions.session", "pk": "qoj7ubqjjsrwafnnzoqevr37l5g19za3", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9mbG9vZC1kZXB0aC8iLCJnaXRodWJfc3RhdGUiOiJyRUV6ZHhGc0pxOFNTRFZkd2Q1OWUzU2hYbUptbHlGSSJ9:1sCrhc:IMVVcqe-Iv73kXED5-W9xZxGTvg0pR6zERKbL6TZbpE", "expire_date": "2024-06-14T02:09:08.826Z"}}, {"model": "sessions.session", "pk": "qyxak9nlk4ibyv07ab1cqa06icdfzn66", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1hcnJheS1paS9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IkhIdnE3MWhLb3FYRnBVWVVkc0ZmYW5CT0w1NFNlVGJlIn0:1tltWA:mkFnmK2jgZxyykkDxvqRfH0FVDk9dLVqPjD9uTmEJSM", "expire_date": "2025-03-08T17:42:22.712Z"}}, {"model": "sessions.session", "pk": "r645kp2aumfi9yab7yv5bftxk1hb2txh", "fields": {"session_data": ".eJxVjruOwjAQRf_F9SokTvyADlHQILFbpIDGGk_GOLuRI2JHWu2Kf8c8CqhGOqNz7_1ngX4TW7EF-2CnPvnZmpggUUYeaiqP07E9tEHi3Daf-104b85ff2E74XeZDQNz8maONJm-y0r9zizgD4XbI47Yw2BwnKh40lg8-ort_ezXWePvvofos7zkTaVIOHSCOtBKWuVc5TrNJdZcCiVU5ZYSkVMDZNFqXZUNCY6lBmtlDn3236MHiMkM46kPLwMfW9jlCjbDW7s:1sGbYC:9jtBFd5cjsdCH9AhmmhpIkJsWH8B6jICzWL6-PCEHMY", "expire_date": "2024-06-24T09:42:52.573Z"}}, {"model": "sessions.session", "pk": "r8dqpn3pmkqmsu50xdh3c5c543g2ltzl", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jb25jYXRlbmF0aW9uLW9mLWFycmF5L0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiVVFlbnZITWg1c3hZd09uYVc5ek5FOUFGYVp3clc1UXcifQ:1tltHB:OR3W0zSv8Uh1HRocsUniCyKyRW7nWwsFOnFFsq6dF_Q", "expire_date": "2025-03-08T17:26:53.742Z"}}, {"model": "sessions.session", "pk": "r8ytrnvb23rd9z0yb3ptjif5ysrrzsem", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6IktZbGdaU09nZm80bTM5WWpZclZLMjRteWNGOGVwbXREIn0:1s2TkU:4KsTNGGisl60JyMZezhxGSkZV74ygCTgz7YV4LFbZIU", "expire_date": "2024-05-16T10:33:10.304Z"}}, {"model": "sessions.session", "pk": "r9g7bpvrlouvrjwsn54et0jxzrxsnxj9", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zcXJ0eC9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoiNnA3OVVMWjVPZU93R3pndzdiU2NmaGd5N3J5Vk1YMEsifQ:1tltFJ:Mp7mHjPAFikNGnomXAbxKe9BRsTKb5x7rkP4HWuG4LI", "expire_date": "2025-03-08T17:24:57.564Z"}}, {"model": "sessions.session", "pk": "rd8iedosiyxkr9e3kyqrtthyrv2i63o4", "fields": {"session_data": ".eJxVjDsOwjAQBe_iGlnxZ_2hpM8ZrF2vwQHkSHFSIe4OkVJA-2bmvUTCba1p62VJE4uzUOL0uxHmR2k74Du22yzz3NZlIrkr8qBdjjOX5-Vw_w4q9vqtwzUDZQtusAqiUojEIXhjiGGw2mKMJrC20RhwpJ1Hdt4gqwzZM5B4fwDHeTdB:1ryUd9:R2QhyUZJ2YBiPDZvQjmO-juFdtMe9qsir6s3TRKqi6U", "expire_date": "2024-05-05T10:41:07.326Z"}}, {"model": "sessions.session", "pk": "rofmjikolgca6l8lnlic9x137fv4299d", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMjYvZGVsZXRlLyIsImdpdGh1Yl9zdGF0ZSI6InF3dVp6N3JhMHBPcjFKbnJoSXRTcWhjTGZ6NDZTYmt6In0:1sCsvv:Xx7x0WW10nSNgNLraDoDaJh10FeVi1UlvMLMoXUGFh0", "expire_date": "2024-06-14T03:27:59.497Z"}}, {"model": "sessions.session", "pk": "s2h0neptxm52l8ld2srxhd0k13hzo6f4", "fields": {"session_data": "eyJuZXh0IjoiL3NxbC9wcm9ibGVtLzEvdXBkYXRlLyIsImdpdGh1Yl9zdGF0ZSI6IjA4WGhYa01ZYmE3djZzbE1wM2FZVlRscU8zaXQwVlljIn0:1tlt7k:ycet730LUG9usfc30Q_iW8-1OP3rayvuuaNdT3fbt3k", "expire_date": "2025-03-08T17:17:08.021Z"}}, {"model": "sessions.session", "pk": "s5fxv2wcws5fianydywnb0me87pm5ocq", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1hcnJheS1paS9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6InZ4bjBNSE1YclVobDBvaGNYWDNzZmwxVXZYUldvdzhqIn0:1tltHd:p3t6XeQXj6EkJTlshNZta_YHYr3QD4yqTAqHtv5cu7Q", "expire_date": "2025-03-08T17:27:21.477Z"}}, {"model": "sessions.session", "pk": "shmti4yr9qvh9bjmttc6uqmbzyfust13", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi8zc3VtLyIsImdpdGh1Yl9zdGF0ZSI6ImJSRjA0Q2JPUDFESVdvRjFDQW9pbzlvOUp2blpOTlNRIn0:1sCrcr:IxDbkUx-OT1oqfV4uo1hJRRY8akwBCzx38F7VdVzmBc", "expire_date": "2024-06-14T02:04:13.999Z"}}, {"model": "sessions.session", "pk": "skbc9ab0mdp50o3z92uhbzqql729rb65", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9sYXJnZXN0LXJlY3RhbmdsZS1pbi1oaXN0b2dyYW0vUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6Im5aOVhiVU5wWm04alhqalQ1UVR2T3FEOEh0a1NwUzRvIn0:1tnhYS:zVRXmK_JAFdlYoceW552j3ICLFf3q73m0I_g01i3_jc", "expire_date": "2025-03-13T17:20:12.915Z"}}, {"model": "sessions.session", "pk": "sv9zzy6aj3n7ycqxjaits83qi0bojqx7", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9tYXhpbXVtLWZyZXF1ZW5jeS1zdGFjay9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6Ilp3a1FyTXRjbWZ5YUhRQTBnSzF2aW5QS3lSMWo0WTVxIn0:1tltpF:dlfdkFPTAA1YWrwiLdNPTruCUaTGobFXp1ZcaZSk2nY", "expire_date": "2025-03-08T18:02:05.117Z"}}, {"model": "sessions.session", "pk": "t16w0qzzxk9pzi7oqbjn1w15eyl9tqz4", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvZ3JhcGgvIiwiZ2l0aHViX3N0YXRlIjoiTFNFWGZxT1lMeFlHbmhUMDRaa3NIMGlSMUI3TVM1SUwifQ:1trwbr:9ZDv-6e5ogc3F_ZTzsGgQ8qGR_azTpKHqSSMzXFkM_g", "expire_date": "2025-03-25T10:13:15.160Z"}}, {"model": "sessions.session", "pk": "t3gn6xn5e5hmuu1ql6zamnzv46ay2bya", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jb21iaW5lLXR3by10YWJsZXMvTXlTUUwvIiwiZ2l0aHViX3N0YXRlIjoiN2UxQnNLVVFMeXVtcnlwVVRlQUxvTkJLdmVoVDlNWWMifQ:1tnj9H:F5xu84bSmkqG-0Fiv6geTOA3ksBV2XcDwV6FnxToq1w", "expire_date": "2025-03-13T19:02:19.941Z"}}, {"model": "sessions.session", "pk": "t6ini6ihnmld7bzkhsjvjen1y2e7cwvl", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wYXNjYWxzLXRyaWFuZ2xlL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiI4b0pIWE11Y2VRMVNWcm9jZDRQQ1NuV1lhRzl1emFTdiJ9:1tlu8K:GN--jhR9ijeToapvO52FEdP9-WFlO4foHUQf2-ZBp08", "expire_date": "2025-03-08T18:21:48.668Z"}}, {"model": "sessions.session", "pk": "teq3am0p7ybi81l4avs8glh038anosyo", "fields": {"session_data": ".eJxVjstuwjAQRf_Fa5TGJn7QXbsIVVWEWCCW1ngyjqNaiYQdVKj673WBRVmNdEbn3vvNRvrK7Jk9sQXrhxxmZ1OGTAUd-vwW6v065tfT-dB-vO_4ibbTvt2B2FzaWAwLcw52TnS0Q1eU5SNzgJ80_j3ShANEi9ORqjtN1a2vWl_P9qVo4tEPkEKRV6LhmqRHL6kDo5XT3nPfGaFwKZTUUnO_UoiCGiCHzhheNyQF1gacUyX03n-NjpCyjVM_jP8G3rawn18YbluU:1sCpJr:C9cPzM67lo0hOO9purl-LFT6T0nIUNK__Wj-luG-zAU", "expire_date": "2024-06-13T23:36:27.836Z"}}, {"model": "sessions.session", "pk": "tnqxe1byywq288h9et75hs4ndl20p23h", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1s5mTL:GarFUhJUU4vDwYJEMSYtln0U6WATzVl6N9jGzZpA7Sw", "expire_date": "2024-05-25T13:09:07.171Z"}}, {"model": "sessions.session", "pk": "u4vw31hq0of17vkdz1aotx1fo7kaqb0l", "fields": {"session_data": ".eJxdjstuwjAQRf_F6yolTvygu7RFLNoKUVasrPFkTAwhQdgRSIh_r3ksoKuRzujce0-so2Nkb-yVvbCVj81gTYgQKSFx-N65TyvrcqN386r4OvjJ78dyMftZD8v3LU-GgSE2Zgi0N75OSvHMLOCGussj9OihNdjvKbvTkN36sun1zKqk_ctsIDRJHvMyVyQcOkE1aCWtci53teYSCy6FEip3Y4nIqQSyaLXORyUJjiMN1soUeu-_RrcQomn7le8eBt62sPMfn2ZbDw:1t7n2o:1m0U4uBDvXgwzlSbnpRT9NOdMVEFVLjt-sdA5XqdR4w", "expire_date": "2024-11-18T02:42:18.188Z"}}, {"model": "sessions.session", "pk": "u6qlyc07fhi1mq1lna1qhsy9eofq2mh0", "fields": {"session_data": ".eJxVjruOwjAURP_FNQrEiR_QbQOiokKIyrq-ucZZogTFDo8g_n29QAHVSDM6M3NnLV0jW7Dp6RZ9107ZhB3q6AdrQoRIKfH6d42j7U-j2xZi3I_L3coVy3J7vMQ1DedEGBiiN0Og3tRVQopvzwIeqf0PQoc1NAa7nrK3G7LXXrZ6yuYnYfyb9xB8gue8zBUJh05QBVpJq5zLXaW5xIJLoYTK3VwiciqBLFqt81lJguNMg7Uylb73n9UNhGia7lC3HwdfX9jjD6EPXvk:1sigoZ:i3kPwcESLAf-dDQULHayghi0uwgXGySafkqFJUmjKcw", "expire_date": "2024-09-09T20:59:51.213Z"}}, {"model": "sessions.session", "pk": "ueqm0927672ebw74qvm66l74pko1iqai", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZXZlcnNlLXN0cmluZy9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6Imxia0VtemtSWmFFUzVaaUt4TWtIdXpEQk5CWDJPM3pnIn0:1ts3ZN:sfj3o-P77INhh6QIi_YtKhhWKy6VqR2Pv6fbNj0le00", "expire_date": "2025-03-25T17:39:09.706Z"}}, {"model": "sessions.session", "pk": "uiu70ztn6vzpix9ed0abl5sdq73ircgp", "fields": {"session_data": ".eJxVjEEOwiAQRe_C2hAGCgMu3XuGZmAmUjU0Ke3KeHdt0oVu_3vvv9RI21rHrcsyTqzOCtTpd8tUHtJ2wHdqt1mXua3LlPWu6IN2fZ1ZnpfD_Tuo1Ou3jgmjJWMdQ4rFMLAPKFIiIwSbyYMlQTfYwOgTFvDGDlQSOnCCYtT7A8IgNuQ:1rzdf2:O9lzFTKtTPzsIAN7KBo7TsA3ORXKeQHVteKn6z7hDdA", "expire_date": "2024-05-08T14:31:48.252Z"}}, {"model": "sessions.session", "pk": "ul8fr1hyybxp2glul6xy1sd4icbti71e", "fields": {"session_data": ".eJxVjstuwjAQRf_F6yq1E2PH7FghJNSuoiYra8Z2cCBK1NiR2iD-HfNYwGqkMzr33jMZ3F8ka_JJPsihi35GHSJEl5BUy2-Y9uNXMdnd_4-XWKl6rpulgiYszTEZGubo9RzcpDubFP7OEMzJDbdHGE0HvTbj5LInDdmjL9vez_cmafm77yH4JOdSrIxgAlSJyISzhaMWoWC8VZRLqkrVGguFFKJFxtBRxleizCkqnlsrUuiz_x7dQ4i6Hw_d8DLwsYVcrmSsWz8:1sGk9a:nydjOvqkzaphtSujrdYuclrKhZa9Sdu_nO6lKVNCGVI", "expire_date": "2024-06-24T18:54:02.294Z"}}, {"model": "sessions.session", "pk": "umorld5u36dllq1fe5vyzgmr02vwjh9o", "fields": {"session_data": ".eJxVjstqwzAQRf9F6-JIsjyyugstCTSE0EIXXYmRNH4QYxdLhial_141yaJZDZzh3Hu_2UhfiT2yFXtgbZ-6xdmYMFFGp0pjDfC80xsq3-bdKeLrfv8h49NLxd8_z9mwuKTOLpFm24esqHvm0B9p_HvEyfc4WD_NVNxoLK59xfZyDuusyXu_w9hlWWqoPAhAUzsngEJJPDgshWoMV5qb2jQ-YKkBGieEIy5UBbXkzigZAuTQW_8lesCY7DC1_fhv4HUL-_kF4npZkg:1tjkzt:LoXTdiksegqRwfXZQR--0fzjYtUk4zQgo7XxaJ0ASQs", "expire_date": "2025-03-02T20:12:13.702Z"}}, {"model": "sessions.session", "pk": "uo8llo7nv94ys3ibfwhf5vblodrp7pp0", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9jb21iaW5lLXR3by10YWJsZXMvTXlTUUwvIiwiZ2l0aHViX3N0YXRlIjoiMFIzbkdFZVc3R3FmejJtZ1lucERISGhJZU1uVm5BZXgifQ:1tnnBF:bSHJmZFyGct7s353B3t_mmk484dXzfHAVgamwIGnNAY", "expire_date": "2025-03-13T23:20:37.914Z"}}, {"model": "sessions.session", "pk": "uoo94e72luj0zitmwp0fela804sxomhx", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6IkFHQ3FkNzkzekhtSHp2TGg2SWhybUFEY0JqVEdtSVhXIn0:1s2UcH:VoaI0w-fftaAntCxwvUs4wlyi6kaTrfe7e4fZbzcFz8", "expire_date": "2024-05-16T11:28:45.331Z"}}, {"model": "sessions.session", "pk": "uq8ia132irildde9p57m70md9um7i4k4", "fields": {"session_data": ".eJxVjstqwzAQRf9F6-LGivVwdg2UEhLShpJmKUbjUSTi2NiSaaH036smWTSrgTOce-836-grsQV7ZA_sGJKfrIkJEmW0HOvNxxA9_9weVqN-G87v_f70vAvdfrXeLYdsGJiSN1Ok0YQmK_N7ZgFP1P09Yo8BWoP9SMWNxuLaV7xczutT1vi97yH6LNe8KhUJh05QA1pJq5wrXaO5xDmXQglVuloicqqALFqty1lFguNMg7Uyh976L9EtxGTa_hi6fwOvW9jPLzPuW7U:1tDUF8:Ig8oFFSnaF8rpjdyMXqoZGr5Y8iG41Gr0rTll0eWDGo", "expire_date": "2024-12-03T19:50:34.531Z"}}, {"model": "sessions.session", "pk": "uvkwha3bqsnlzekcbq79a6c4l0mgehic", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zdW0tb2YtcGFpcnMvIiwiZ2l0aHViX3N0YXRlIjoiTkt6ZjgwRFJKd1J3VWE3TEY5emRBYUM4blNJenM2NDQifQ:1sCszn:HUaK7nWdW706spKXXbmlgOzniVh4duykCLjlW2ikTFg", "expire_date": "2024-06-14T03:31:59.681Z"}}, {"model": "sessions.session", "pk": "ux8anrsqcv79fs18eyadv2eir570bqod", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9kZXNpZ24tY29tcHJlc3NlZC1zdHJpbmctaXRlcmF0b3IvSmF2YVNjcmlwdC8iLCJnaXRodWJfc3RhdGUiOiJibUx6cU5VWFVvUmNQQnUxRXlLYVBkdE12RFFsTU1GOCJ9:1tnWHC:bqMpNy7S8IRWSVF0c6FC_GBLySOncIHFQa6RY192xhU", "expire_date": "2025-03-13T05:17:38.699Z"}}, {"model": "sessions.session", "pk": "v7zuv4m9bt1asywf50squci4cxv8sqtk", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zcXJ0eC9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IlhTeERiMUp5azZiRHk2V2dhclJHNjJCYTJSSG4yZERiIn0:1tltCR:PKdG7yeRTDJiaMp3TKlfpDUvA07ZKBDYE_HNw5VOgDc", "expire_date": "2025-03-08T17:21:59.821Z"}}, {"model": "sessions.session", "pk": "vb2ct66iim3jx3k5v9t2esr6ke2924jk", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi92YWxpZC1wYWxpbmRyb21lLWlpL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiTEFBVURMTkFTWmo2T1ZjeVZYNGg0bWdNaTVyR0ZYM2IifQ:1tnVPJ:icedNKTRIXt3HUpKt_w70Z-1lxJyQCP5YtdEW8QDeUU", "expire_date": "2025-03-13T04:21:57.275Z"}}, {"model": "sessions.session", "pk": "vbvab03zuc7xj376fgaba2xytxjuer9p", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMTkvdXBkYXRlLyIsImdpdGh1Yl9zdGF0ZSI6ImVSZGo0MGNDc0NYS2YzVGNUeFNidDdyWktFVFlWMldDIn0:1sCbL0:VzwunI0OGydIuT1hNS4b-ra5rN5NAnJUsJu_gveoUbw", "expire_date": "2024-06-13T08:40:42.455Z"}}, {"model": "sessions.session", "pk": "vk735n11cak7nax4yvs6vun4jy2oqi0l", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLWlpaS9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IldwUE9JbzhkcnlKVUFQZHhJOVRpYzY2bDNtVU51MUFkIn0:1trqNp:nkzdvpgxD9Zg1z0r4ypGYgaQcx9FDNqDayPz5zASzrs", "expire_date": "2025-03-25T03:34:21.996Z"}}, {"model": "sessions.session", "pk": "vmf7vgyzso9f25u32s1lqwcf3frr8p15", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9rLXRoLXN5bWJvbC1pbi1ncmFtbWFyL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiT05YU2FSVkE0aFlZQW5ic0Z6czVMV1dqcmRHcUd1M2oifQ:1tltDd:9HCEGbFltAiB1IAQw1xlGhlnJe4xeXyltkH3hm43Rp4", "expire_date": "2025-03-08T17:23:13.913Z"}}, {"model": "sessions.session", "pk": "vp792us2aw57qxrjsxj0uwxmh0wpzhqc", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi93b3JkLWJyZWFrL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJUM05VRmZuQXpMQm55WGM0VmxLZ2FoSWlhWTZTeVRpWCJ9:1tHy64:mxAS85_KPV5U4MrYaehqUfH4gI4oL9CeevXvXSZW2Xk", "expire_date": "2024-12-16T04:31:44.942Z"}}, {"model": "sessions.session", "pk": "vu4lv1uzlxh6cyi3cidwjexbnow8bxb3", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9kaXJlY3Rpb25zLXJlZHVjdGlvbi9QeXRob24vIiwiZ2l0aHViX3N0YXRlIjoiOUdBZjBMamlPSHNvM2tGb21tVWlFZ3VKc2ozelBKYTcifQ:1scuV2:SksqymGjfH5QtYqQldB-kW_I_2erOZlxPyT5RfBDePw", "expire_date": "2024-08-24T22:23:48.633Z"}}, {"model": "sessions.session", "pk": "vvuizddd4wylj39lg8cx3cihsscahn78", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9hcnJhbmdpbmctY29pbnMvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6ImRsVzV5bjFsZUptdXBrNmhzeEVNcG5SV0NKTXBPOU5WIn0:1tltBD:CzLwDKYhZtU_Z3VFQbpOpNafobGfNIjtsFsRe-OD6lo", "expire_date": "2025-03-08T17:20:43.691Z"}}, {"model": "sessions.session", "pk": "vxd50p57kjtm1cfagajkricojpzigapb", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi91bmlxdWUtcGF0aHMvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6Ik00NFVYaE5UVnpuZXV2VW83aGYyRncxTFJGMlhiQ3A4In0:1ts1Hw:Ut5pgYuBcEd-7NLLk3TU-xmYTI8cyfaXnqn3Wf1i7yA", "expire_date": "2025-03-25T15:13:00.128Z"}}, {"model": "sessions.session", "pk": "vzixvvtyqhcs378soz6p608ilwzy45qw", "fields": {"session_data": ".eJxVjstqwzAQRf9F6-LYivVwd82igVAwtIu2KzEajywTIxNLDjWl_141yaJZDZzh3Hu_WaCvxB7Zhj2wfkh-sSYmSJQRvLe7pW12n2twb_3LYX4N59OKzx_hPB1r5bNhYEneLJFmM3RZ2d4zC3ik8PeIEw4wGpxmKm40Fte-Yn857VPW-L3vIfosN7yuFAmHTlAHWkmrnKtcp7nELZdCCVW5RiJyqoEsWq2rsibBsdRgrcyht_5L9AgxmXHqh_Bv4HUL-_kFoC5cMQ:1st5gP:TaiAZwlwA82b0UodA5DFad6BmULp5fma6Glq6-yBEm0", "expire_date": "2024-10-08T13:34:25.684Z"}}, {"model": "sessions.session", "pk": "we3l26g4wk2v6899qu1anxikmqsg733e", "fields": {"session_data": ".eJxVjsGKwjAURf8la6lJm6bN7MSCiosigrMML8lrU60tmFQE8d_NqItx9eA8zr33Tga8BfJD5mRG2i64SSsfIGBE0lXnQ_17XfJpP9j2SG_HdV6Z3Qq3ddiYIhoKpuDU5PGiOhsV_s00mBMOfw8_mg56ZcYLJh_qk3dfsnqdehG19Nt34F2U00LkRjABstSaCbQZUqshY7yRlBdUlrIxFrJCiEYzppEynosypVry1FoRQz_9r-gefFD92HbDv4HvLeTxBJukWlg:1tr2yj:Mc1uo0PonLzV_ixR1aaJmL-K0w1JF2Q6v3tRsDOOS68", "expire_date": "2025-03-22T22:49:09.144Z"}}, {"model": "sessions.session", "pk": "wemcgqv7z57cuxlcgxjg1ln6ijvats3p", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi92YWxpZC1hbmFncmFtLyIsImdpdGh1Yl9zdGF0ZSI6ImFKV2hySFpIVHV4RmVtNXBpTzFWYzR1QmxDeXkwRWl3In0:1sCgRq:RXDHipmW15jy3fkxcK_QJTm6dnV2cN9CJGIGTlL8cw8", "expire_date": "2024-06-13T14:08:06.442Z"}}, {"model": "sessions.session", "pk": "wji3zuy1sv6oj1itx1wa76i84qxk473o", "fields": {"session_data": "eyJuZXh0IjoiL3NxbC9hc2NpaS8iLCJnaXRodWJfc3RhdGUiOiJodXZlSXdxVG44SzRUOG9XUmVkOXJIRzJ6MnR1ZVUzWCJ9:1ts3s3:u8lVLtRdMMObxgrh9529xFIG5oqXXTbc2UmoysJxQ7Y", "expire_date": "2025-03-25T17:58:27.891Z"}}, {"model": "sessions.session", "pk": "wno11hcv8uyyuay8461k0225fwlcriyv", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZW1vdmUtbnRoLW5vZGUtZnJvbS1lbmQtb2YtbGlzdC9KYXZhU2NyaXB0LyIsImdpdGh1Yl9zdGF0ZSI6IjFFMWM3Nm4xZXk3RTJoVGo2Yk42Ym9ScXhiRVF6Wno4In0:1tltE8:U-P_EbJekKlUMVdl0GYIyana64xrFHlY7nxIZT7I1yo", "expire_date": "2025-03-08T17:23:44.551Z"}}, {"model": "sessions.session", "pk": "wsoszvuu7u5gwky11kvlzv0kzkk3crgf", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9tZXJnZS1zb3J0ZWQtYXJyYXkvSmF2YVNjcmlwdC8iLCJnaXRodWJfc3RhdGUiOiJOdEp4T0JvSkN4emZ1d3RUMVR1SUpDOWQxTUNERElzdSJ9:1tltbN:K8HOLPRG_yJqAn5H9_Dmg4rFqV1RwwwLUViAbHWx7e8", "expire_date": "2025-03-08T17:47:45.695Z"}}, {"model": "sessions.session", "pk": "xdlqagn0umunueptee57d9x15asvsdi6", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9tYXgtYXJlYS1vZi1pc2xhbmQvSmF2YVNjcmlwdC8iLCJnaXRodWJfc3RhdGUiOiIwRlY5OWVESlN3QXdVM3BRTGFQSEhQOUNPQkZWb0ZYcyJ9:1tnXVg:vqMmM2q-VQ-nceqF3cLjv4MiD-bfBfGqwqMiGYRda6k", "expire_date": "2025-03-13T06:36:40.685Z"}}, {"model": "sessions.session", "pk": "xl6jh5to9s3ihc1wxd1bamqrzbr2u7r5", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9ndWVzcy1udW1iZXItaGlnaGVyLW9yLWxvd2VyL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoiam9rM00yRklHalVmWWZ5OW9iQU1PN3o2bUw0aDlrMGgifQ:1tryse:Zwv8JaORuyODAPu1uaSBMyJCae7r2yQVXwjq6BQBEag", "expire_date": "2025-03-25T12:38:44.658Z"}}, {"model": "sessions.session", "pk": "xm7lganlu0iomc85dr6krxtvwmbrp384", "fields": {"session_data": "eyJuZXh0IjoiLyIsImdpdGh1Yl9zdGF0ZSI6ImxHWVVSNGhBNmlMUFNyVXhmMXM2TmoxcmUzWnNRNmRaIn0:1ts8oc:B1PjrqyjuESpumO9R21bNpEIfCDZUBB_sj17z-VKEB8", "expire_date": "2025-03-25T23:15:14.198Z"}}, {"model": "sessions.session", "pk": "xmndv8ht3vre9ffjt6kru1m3rb0m9368", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi92YWxpZGF0ZS1zdGFjay1zZXF1ZW5jZXMvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6InZKSFZWZ1lHNEluU1Z0NUMyZk9MUmc1cGdNT0RHaFNzIn0:1tnhsI:b5ysRMC72xidwFjzHoVWZP1AMr7ZszHsEiTiyzc9SOg", "expire_date": "2025-03-13T17:40:42.839Z"}}, {"model": "sessions.session", "pk": "xn2yo2r2hknu1grd0uxm6ha9elvm8ck7", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJXRVJSMU1hWkdNU3dIQWxPS2RQTFlMZHk3T2JHckxvbiJ9:1tB7OZ:xzNUmqazfSWm1bTnE2w4dsTPOOTznFKAcWAL2WTDKgc", "expire_date": "2024-11-27T07:02:31.723Z"}}, {"model": "sessions.session", "pk": "xy14htphlxawt6ti96ebuuz64a1zegzf", "fields": {"session_data": ".eJxVjktvwjAQhP-Lz1USm_iR3pBalUMR4lKkXix7s8YpJkaxU_Wh_ve6wKGcVju738x8kxE_Mrkn9ekz-zjWpynagEcNE5qMNbkj-yH72eqUy14eN-GrO6y33fbtefUamvVKiJ2nDyq8uGP7_rgrhDZz9npOOOmhL8jiVrMGDjj-HVKEwQQNccLqqqbqklc9ncdmWTB2y3uTfIE71lKJ3IHj2BslhZXOUdcrJmDBBJdcUtcJAIatQQtWKdq0yBk0ylgriuk1_2wdTMo6xP0w_it46UJ-fgERgmOQ:1tNi3w:LZm6eWoGsGE8GSMVYH67gcAjkKSohVQortOA0kW0BJc", "expire_date": "2025-01-01T00:37:16.856Z"}}, {"model": "sessions.session", "pk": "y16t7c2ouobbd23vjhapp4tlv95sfwg9", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9rdGgtbGFyZ2VzdC1lbGVtZW50LWluLWEtc3RyZWFtL0phdmFTY3JpcHQvIiwiZ2l0aHViX3N0YXRlIjoickFuSnlqSXY5UXRRa21BdDJPS0c2R3BmUmtZb211a1QifQ:1ts87B:Jfd7AOq1yLFMnhBFyN7It-uM4iyTb-dXne0lg27ocOs", "expire_date": "2025-03-25T22:30:21.685Z"}}, {"model": "sessions.session", "pk": "ye3te0xiqvcksithj39dx4btea23cta3", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9kaXJlY3Rpb25zLXJlZHVjdGlvbi8iLCJnaXRodWJfc3RhdGUiOiJVSHlhZE12V0t1dm1qQm83QnFWS1NWS1IxOGlDMnZKZiJ9:1sCecf:4q0xBlNEDjQFX7I7je6ndn84orqSqrb0tDFkx2z_TNM", "expire_date": "2024-06-13T12:11:09.596Z"}}, {"model": "sessions.session", "pk": "yigdpzzy7l2mndhklkpa44rj007kfgd8", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9wZXJtdXRhdGlvbi1pbi1zdHJpbmcvUHl0aG9uLyIsImdpdGh1Yl9zdGF0ZSI6IlVEZmdVNGN1bHFjR204bzc0WWgxWlhLSXVxNjJoZzFGIn0:1tnT5k:xGkST4Jj32_lOFGGlazgzT5ezCWk5neuWoVWWJvBZBY", "expire_date": "2025-03-13T01:53:36.431Z"}}, {"model": "sessions.session", "pk": "yjxe39esawt2gnbng8riufswqscq4sgx", "fields": {"session_data": "eyJuZXh0IjoiL2FjY291bnRzL2xvZ2luLyIsImdpdGh1Yl9zdGF0ZSI6InAwaVdXYWlzRTRrM3BTWndqSXFjUHhhM2xuM3ZiRmhEIn0:1tlt1P:7ciL5Bb-g77yqn1pXfkBx9tA01KiyY3P1GGGMVcC3rU", "expire_date": "2025-03-08T17:10:35.417Z"}}, {"model": "sessions.session", "pk": "yx5mg6itb0hqhys5pt20546aoj44b3oi", "fields": {"session_data": "eyJuZXh0IjoiL3NxbC9hc2NpaS8iLCJnaXRodWJfc3RhdGUiOiI1WE1aS3QycWpuT0taeWlxVkJ4UDV2UkViV0x1ZWxLYiJ9:1tlt1T:BiOcpDV_wKgUrIfhYtsyV2CppzgLXaEnQOZg-fJH6AM", "expire_date": "2025-03-08T17:10:39.409Z"}}, {"model": "sessions.session", "pk": "yy1nzll4sad6hmxin82801s0fxfqk98y", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1saXN0L1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJhRzJqM0F5VWdEQmVEQ1VuSlhsN1NsTWgwUkZsWGFCcyJ9:1tltMq:wIEcijOVoeAG36GOAKo_l-fwgSU3SZQ7InY6CQ8aW7E", "expire_date": "2025-03-08T17:32:44.761Z"}}, {"model": "sessions.session", "pk": "yyihrdidrjb79zjwn9grxdmris9csmyr", "fields": {"session_data": "eyJuZXh0IjoiL2ZvcnVtcy9mZWF0dXJlX2ZvcnVtIiwiZ2l0aHViX3N0YXRlIjoiR1Y0elRwTm9NRUFGeDNSdVdHaXZzcjU4OW5YT3dqZmIifQ:1tltwL:GZzOiVmh6eUysZscpLj6gqcIQS2qi8x4InudL3TeWzI", "expire_date": "2025-03-08T18:09:25.614Z"}}, {"model": "sessions.session", "pk": "z9wi79hw4z8teinzqi4mvteg9m75g1v6", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi9zb2x1dGlvbl9jcmVhdGUvIiwiZ2l0aHViX3N0YXRlIjoiVTNYaFVpakVWR1J2SXQzR3lhdXNJS0JJTDl6MDM1VTQifQ:1tltKY:Z_ZyaQxfDuy0GPmBiyHSd09mOhZThb9rsp7md3_NvRc", "expire_date": "2025-03-08T17:30:22.653Z"}}, {"model": "sessions.session", "pk": "zmhz2mpbxvdgblblvyujbd3nkoghdei0", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvY3JlYXRlLyIsImdpdGh1Yl9zdGF0ZSI6ImhLN2pUUTlZc2Q2WnM3Qm03T3FqdmdncHdmVDRGbml6In0:1ts2hs:wkE2Ib6wN37q7VeY8CllsHCVyD4phEPiZbstuce1hXk", "expire_date": "2025-03-25T16:43:52.796Z"}}, {"model": "sessions.session", "pk": "zqgoiwmczrjcqlnmcbk619d1xfd97wsn", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi90YWcvMi9kZWxldGUvIiwiZ2l0aHViX3N0YXRlIjoibXpwV21sYUlKcTVEYnVadEtPVVk2M29QQlpBOFh0M2UifQ:1sCsze:iZ57yTjs_53U03lDuxb0Qmruh5kfgL7HSjL4krv94ss", "expire_date": "2024-06-14T03:31:50.983Z"}}, {"model": "sessions.session", "pk": "zy4gaungf3hlieejzbvwfskbwtxyh3ib", "fields": {"session_data": "eyJuZXh0IjoiL3B5dGhvbi92YWxpZC1wYWxpbmRyb21lL1B5dGhvbi8iLCJnaXRodWJfc3RhdGUiOiJzNWtDZElFRTd5QXNGRHhaZTN6WjN1R3Z5ZnVQTXVqRSJ9:1tlt5y:M4sfMDVeUIdxiv25DC3qDnvupxX_4Gza0kEAgyUQgd0", "expire_date": "2025-03-08T17:15:18.717Z"}}, {"model": "social_django.usersocialauth", "pk": 1, "fields": {"user": 3, "provider": "github", "uid": "76163659", "extra_data": "{\"auth_time\": 1742171043, \"id\": 76163659, \"expires\": null, \"login\": \"lodyga\", \"access_token\": \"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\", \"token_type\": \"bearer\"}", "created": "2024-05-05T14:38:54.578Z", "modified": "2025-03-17T00:24:03.028Z"}}, {"model": "social_django.usersocialauth", "pk": 2, "fields": {"user": 4, "provider": "github", "uid": "45561955", "extra_data": "{\"auth_time\": 1741474149, \"id\": 45561955, \"expires\": null, \"login\": \"krzysztofskorupski\", \"access_token\": \"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\", \"token_type\": \"bearer\"}", "created": "2024-05-30T22:42:59.012Z", "modified": "2025-03-08T22:49:09.040Z"}}, {"model": "python_problems.tag", "pk": 2, "fields": {"name": "Array"}}, {"model": "python_problems.tag", "pk": 3, "fields": {"name": "Hash Table"}}, {"model": "python_problems.tag", "pk": 4, "fields": {"name": "Two Pointers"}}, {"model": "python_problems.tag", "pk": 5, "fields": {"name": "Binary Search"}}, {"model": "python_problems.tag", "pk": 6, "fields": {"name": "String"}}, {"model": "python_problems.tag", "pk": 7, "fields": {"name": "Stack"}}, {"model": "python_problems.tag", "pk": 8, "fields": {"name": "Math"}}, {"model": "python_problems.tag", "pk": 10, "fields": {"name": "Greedy"}}, {"model": "python_problems.tag", "pk": 11, "fields": {"name": "Counting"}}, {"model": "python_problems.tag", "pk": 13, "fields": {"name": "Combinatorics"}}, {"model": "python_problems.tag", "pk": 14, "fields": {"name": "Dynamic Programming"}}, {"model": "python_problems.tag", "pk": 17, "fields": {"name": "Sorting"}}, {"model": "python_problems.tag", "pk": 18, "fields": {"name": "Divide and Conquer"}}, {"model": "python_problems.tag", "pk": 19, "fields": {"name": "Heap, Priority Queue"}}, {"model": "python_problems.tag", "pk": 20, "fields": {"name": "Bucket Sort"}}, {"model": "python_problems.tag", "pk": 21, "fields": {"name": "Quickselect"}}, {"model": "python_problems.tag", "pk": 22, "fields": {"name": "Union Find"}}, {"model": "python_problems.tag", "pk": 23, "fields": {"name": "Enumeration"}}, {"model": "python_problems.tag", "pk": 24, "fields": {"name": "Sliding Window"}}, {"model": "python_problems.tag", "pk": 25, "fields": {"name": "Monotonic Stack"}}, {"model": "python_problems.tag", "pk": 26, "fields": {"name": "Memoization"}}, {"model": "python_problems.tag", "pk": 27, "fields": {"name": "Breadth-First Search"}}, {"model": "python_problems.tag", "pk": 28, "fields": {"name": "WTF"}}, {"model": "python_problems.tag", "pk": 29, "fields": {"name": "Trie"}}, {"model": "python_problems.tag", "pk": 30, "fields": {"name": "Database"}}, {"model": "python_problems.tag", "pk": 31, "fields": {"name": "Matrix"}}, {"model": "python_problems.tag", "pk": 32, "fields": {"name": "Prefix Sum"}}, {"model": "python_problems.tag", "pk": 33, "fields": {"name": "Queue"}}, {"model": "python_problems.tag", "pk": 34, "fields": {"name": "Monotonic Queue"}}, {"model": "python_problems.tag", "pk": 35, "fields": {"name": "Design"}}, {"model": "python_problems.tag", "pk": 36, "fields": {"name": "Backtracking"}}, {"model": "python_problems.tag", "pk": 37, "fields": {"name": "Linked List"}}, {"model": "python_problems.tag", "pk": 38, "fields": {"name": "Recursion"}}, {"model": "python_problems.tag", "pk": 39, "fields": {"name": "Bit Manipulation"}}, {"model": "python_problems.tag", "pk": 40, "fields": {"name": "Tree"}}, {"model": "python_problems.tag", "pk": 41, "fields": {"name": "Depth-First Search"}}, {"model": "python_problems.tag", "pk": 42, "fields": {"name": "Binary Tree"}}, {"model": "python_problems.tag", "pk": 43, "fields": {"name": "Hash Function"}}, {"model": "python_problems.tag", "pk": 44, "fields": {"name": "Graph"}}, {"model": "python_problems.tag", "pk": 45, "fields": {"name": "Simulation"}}, {"model": "python_problems.tag", "pk": 46, "fields": {"name": "Interactive"}}, {"model": "python_problems.tag", "pk": 47, "fields": {"name": "Data Stream"}}, {"model": "python_problems.tag", "pk": 48, "fields": {"name": "Doubly-Linked List"}}, {"model": "python_problems.tag", "pk": 49, "fields": {"name": "Binary Indexed Tree"}}, {"model": "python_problems.tag", "pk": 50, "fields": {"name": "Binary Search Tree"}}, {"model": "python_problems.tag", "pk": 51, "fields": {"name": "Iterator"}}, {"model": "python_problems.tag", "pk": 52, "fields": {"name": "String Matching"}}, {"model": "python_problems.tag", "pk": 53, "fields": {"name": "Radix Sort"}}, {"model": "python_problems.tag", "pk": 54, "fields": {"name": "Counting Sort"}}, {"model": "python_problems.tag", "pk": 55, "fields": {"name": "Merge Sort"}}, {"model": "python_problems.tag", "pk": 56, "fields": {"name": "Ordered Set"}}, {"model": "python_problems.tag", "pk": 57, "fields": {"name": "Geometry"}}, {"model": "python_problems.tag", "pk": 58, "fields": {"name": "Bitmask"}}, {"model": "python_problems.tag", "pk": 59, "fields": {"name": "Segment Tree"}}, {"model": "python_problems.difficulty", "pk": 1, "fields": {"name": "Easy"}}, {"model": "python_problems.difficulty", "pk": 2, "fields": {"name": "Medium"}}, {"model": "python_problems.difficulty", "pk": 3, "fields": {"name": "Hard"}}, {"model": "python_problems.difficulty", "pk": 4, "fields": {"name": "Impossible"}}, {"model": "python_problems.complexity", "pk": 1, "fields": {"name": "O(1)"}}, {"model": "python_problems.complexity", "pk": 2, "fields": {"name": "O(n)"}}, {"model": "python_problems.complexity", "pk": 3, "fields": {"name": "O(n2)"}}, {"model": "python_problems.complexity", "pk": 4, "fields": {"name": "O(logn)"}}, {"model": "python_problems.complexity", "pk": 5, "fields": {"name": "O(nlogn)"}}, {"model": "python_problems.complexity", "pk": 6, "fields": {"name": "O(2^n)"}}, {"model": "python_problems.complexity", "pk": 7, "fields": {"name": "O(n2^n)"}}, {"model": "python_problems.complexity", "pk": 8, "fields": {"name": "O(n!)"}}, {"model": "python_problems.language", "pk": 1, "fields": {"name": "Python"}}, {"model": "python_problems.language", "pk": 2, "fields": {"name": "JavaScript"}}, {"model": "python_problems.language", "pk": 3, "fields": {"name": "Pandas"}}, {"model": "python_problems.language", "pk": 4, "fields": {"name": "MySQL"}}, {"model": "python_problems.language", "pk": 5, "fields": {"name": "PostgreSQL"}}, {"model": "python_problems.language", "pk": 6, "fields": {"name": "Java"}}, {"model": "python_problems.language", "pk": 7, "fields": {"name": "C++"}}, {"model": "python_problems.problem", "pk": 1, "fields": {"title": "Two Sum", "slug": "two-sum", "difficulty": 1, "url": "https://leetcode.com/problems/two-sum/description/", "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\r\n\r\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\r\n\r\nYou can return the answer in any order.\r\n\r\nExample 1:\r\n\r\nInput: nums = [2,7,11,15], target = 9\r\nOutput: [0,1]\r\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].", "created_at": "2024-02-01T00:00:00Z", "updated_at": "2024-06-19T14:55:31.471Z", "owner": 3, "tags": [2, 3]}}, {"model": "python_problems.problem", "pk": 2, "fields": {"title": "Two Sum II - Input Array Is Sorted", "slug": "two-sum-ii-input-array-is-sorted", "difficulty": 2, "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/", "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\r\n\r\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\r\n\r\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\r\n\r\nYour solution must use only constant extra space.\r\n\r\nExample 1:\r\n\r\nInput: numbers = [2,7,11,15], target = 9\r\nOutput: [1,2]\r\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\r\nExample 2:\r\n\r\nInput: numbers = [2,3,4], target = 6\r\nOutput: [1,3]\r\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\r\nExample 3:\r\n\r\nInput: numbers = [-1,0], target = -1\r\nOutput: [1,2]\r\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].", "created_at": "2024-02-04T11:04:36.923Z", "updated_at": "2024-06-19T20:32:28.256Z", "owner": 3, "tags": [2, 5, 4]}}, {"model": "python_problems.problem", "pk": 3, "fields": {"title": "Valid Parentheses", "slug": "valid-parentheses", "difficulty": 1, "url": "https://leetcode.com/problems/valid-parentheses/description/", "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\r\n\r\nAn input string is valid if:\r\n\r\nOpen brackets must be closed by the same type of brackets.\r\nOpen brackets must be closed in the correct order.\r\nEvery close bracket has a corresponding open bracket of the same type.\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"()\"\r\nOutput: true\r\nExample 2:\r\n\r\nInput: s = \"()[]{}\"\r\nOutput: true\r\nExample 3:\r\n\r\nInput: s = \"(]\"\r\nOutput: false", "created_at": "2024-02-07T22:09:13.846Z", "updated_at": "2024-06-19T20:32:37.616Z", "owner": 3, "tags": [7, 6]}}, {"model": "python_problems.problem", "pk": 4, "fields": {"title": "Directions Reduction", "slug": "directions-reduction", "difficulty": 1, "url": "https://www.codewars.com/kata/550f22f4d758534c1100025a", "description": "Once upon a time, on a way through the old wild mountainous west,\r\n a man was given directions to go from one point to another. The directions were \"NORTH\", \"SOUTH\", \"WEST\", \"EAST\". Clearly \"NORTH\" and \"SOUTH\" are opposite, \"WEST\" and \"EAST\" too.\r\n\r\nGoing to one direction and coming back the opposite direction right away is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it's important to save yourself some energy, otherwise you might die of thirst!\r\n\r\nHow I crossed a mountainous desert the smart way.\r\nThe directions given to the man are, for example, the following (depending on the language):\r\n\r\n[\"NORTH\", \"SOUTH\", \"SOUTH\", \"EAST\", \"WEST\", \"NORTH\", \"WEST\"].\r\nor\r\n{ \"NORTH\", \"SOUTH\", \"SOUTH\", \"EAST\", \"WEST\", \"NORTH\", \"WEST\" };\r\nor\r\n[North, South, South, East, West, North, West]\r\nYou can immediatly see that going \"NORTH\" and immediately \"SOUTH\" is not reasonable, better stay to the same place! So the task is to give to the man a simplified version of the plan. A better plan in this case is simply:\r\n\r\n[\"WEST\"]\r\nor\r\n{ \"WEST\" }\r\nor\r\n[West]\r\nOther examples:\r\nIn [\"NORTH\", \"SOUTH\", \"EAST\", \"WEST\"], the direction \"NORTH\" + \"SOUTH\" is going north and coming back right away.\r\n\r\nThe path becomes [\"EAST\", \"WEST\"], now \"EAST\" and \"WEST\" annihilate each other, therefore, the final result is [] (nil in Clojure).\r\n\r\nIn [\"NORTH\", \"EAST\", \"WEST\", \"SOUTH\", \"WEST\", \"WEST\"], \"NORTH\" and \"SOUTH\" are not directly opposite but they become directly opposite after the reduction of \"EAST\" and \"WEST\" so the whole path is reducible to [\"WEST\", \"WEST\"].\r\n\r\nTask\r\nWrite a function dirReduc which will take an array of strings and returns an array of strings with the needless directions removed (W<->E or S<->N side by side).\r\n\r\nThe Haskell version takes a list of directions with data Direction = North | East | West | South.\r\nThe Clojure version returns nil when the path is reduced to nothing.\r\nThe Rust version takes a slice of enum Direction {North, East, West, South}.\r\nSee more examples in \"Sample Tests:\"\r\nNotes\r\nNot all paths can be made simpler. The path [\"NORTH\", \"WEST\", \"SOUTH\", \"EAST\"] is not reducible. \"NORTH\" and \"WEST\", \"WEST\" and \"SOUTH\", \"SOUTH\" and \"EAST\" are not directly opposite of each other and can't become such. Hence the result path is itself : [\"NORTH\", \"WEST\", \"SOUTH\", \"EAST\"].\r\nif you want to translate, please ask before translating.", "created_at": "2024-02-11T09:13:50.769Z", "updated_at": "2024-06-19T20:32:51.104Z", "owner": 3, "tags": [7, 6]}}, {"model": "python_problems.problem", "pk": 6, "fields": {"title": "Valid Palindrome", "slug": "valid-palindrome", "difficulty": 1, "url": "https://leetcode.com/problems/valid-palindrome/description/", "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\r\n\r\nGiven a string s, return true if it is a palindrome, or false otherwise.\r\n\r\nExample 1:\r\n\r\nInput: s = \"A man, a plan, a canal: Panama\"\r\nOutput: true\r\nExplanation: \"amanaplanacanalpanama\" is a palindrome.", "created_at": "2024-02-14T20:18:27.692Z", "updated_at": "2024-06-19T20:33:02.074Z", "owner": 3, "tags": [6, 4]}}, {"model": "python_problems.problem", "pk": 7, "fields": {"title": "Split a String in Balanced Strings", "slug": "split-a-string-in-balanced-strings", "difficulty": 1, "url": "https://leetcode.com/problems/split-a-string-in-balanced-strings/description/", "description": "Balanced strings are those that have an equal quantity of 'L' and 'R' characters.\r\n\r\nGiven a balanced string s, split it into some number of substrings such that:\r\n\r\nEach substring is balanced.\r\nReturn the maximum number of balanced strings you can obtain.\r\n\r\nExample 1:\r\n\r\nInput: s = \"RLRRLLRLRL\"\r\nOutput: 4\r\nExplanation: s can be split into \"RL\", \"RRLL\", \"RL\", \"RL\", each substring contains same number of 'L' and 'R'.\r\nExample 2:\r\n\r\nInput: s = \"RLRRRLLRLL\"\r\nOutput: 2\r\nExplanation: s can be split into \"RL\", \"RRRLLRLL\", each substring contains same number of 'L' and 'R'.\r\nNote that s cannot be split into \"RL\", \"RR\", \"RL\", \"LR\", \"LL\", because the 2nd and 5th substrings are not balanced.\r\nExample 3:\r\n\r\nInput: s = \"LLLLRRRR\"\r\nOutput: 1\r\nExplanation: s can be split into \"LLLLRRRR\".", "created_at": "2024-02-18T07:23:04.615Z", "updated_at": "2024-08-08T15:04:15.606Z", "owner": 3, "tags": [11, 10, 7, 6]}}, {"model": "python_problems.problem", "pk": 8, "fields": {"title": "Sum of Pairs", "slug": "sum-of-pairs", "difficulty": 1, "url": "https://www.codewars.com/kata/54d81488b981293527000c8f", "description": "Given a list of integers and a single sum value, return the first two values (parse from the left please) in order of appearance that add up to form the sum.\r\n\r\nsum_pairs([11, 3, 7, 5],         10)\r\n#              ^--^      3 + 7 = 10\r\n== [3, 7]\r\n\r\nsum_pairs([4, 3, 2, 3, 4],         6)\r\n#          ^-----^         4 + 2 = 6, indices: 0, 2 *\r\n#             ^-----^      3 + 3 = 6, indices: 1, 3\r\n#                ^-----^   2 + 4 = 6, indices: 2, 4\r\n#  * entire pair is earlier, and therefore is the correct answer\r\n== [4, 2]\r\n\r\nsum_pairs([0, 0, -2, 3], 2)\r\n#  there are no pairs of values that can be added to produce 2.\r\n== None/nil/undefined (Based on the language)\r\n\r\nsum_pairs([10, 5, 2, 3, 7, 5],         10)\r\n#              ^-----------^   5 + 5 = 10, indices: 1, 5\r\n#                    ^--^      3 + 7 = 10, indices: 3, 4 *\r\n#  * entire pair is earlier, and therefore is the correct answer\r\n== [3, 7]\r\nNegative numbers and duplicate numbers can and will appear.\r\n\r\nNOTE: There will also be lists tested of lengths upwards of 10,000,000 elements. Be sure your code doesn't time out.", "created_at": "2024-02-21T18:27:41.538Z", "updated_at": "2024-06-19T20:36:10.787Z", "owner": 3, "tags": [2, 3]}}, {"model": "python_problems.problem", "pk": 10, "fields": {"title": "Unique Paths", "slug": "unique-paths", "difficulty": 2, "url": "https://leetcode.com/problems/unique-paths/description/", "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\r\n\r\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\r\n\r\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\r\n\r\nExample 1:\r\n\r\nInput: m = 3, n = 7\r\nOutput: 28\r\n\r\nExample 2:\r\n\r\nInput: m = 3, n = 2\r\nOutput: 3\r\n\r\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\r\n1. Right -> Down -> Down\r\n2. Down -> Down -> Right\r\n3. Down -> Right -> Down", "created_at": "2024-02-25T05:32:18.461Z", "updated_at": "2024-07-09T10:11:59.424Z", "owner": 3, "tags": [13, 14, 8]}}, {"model": "python_problems.problem", "pk": 11, "fields": {"title": "Contains Duplicate", "slug": "contains-duplicate", "difficulty": 1, "url": "https://leetcode.com/problems/contains-duplicate/", "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1, 2, 3, 1]\r\nOutput: true\r\n\r\nExample 2:\r\n\r\nInput: nums = [1, 2, 3, 4]\r\nOutput: false\r\n\r\nExample 3:\r\n\r\nInput: nums = [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]\r\nOutput: true", "created_at": "2024-02-28T16:36:55.384Z", "updated_at": "2024-06-19T20:39:43.911Z", "owner": 3, "tags": [2, 3, 17]}}, {"model": "python_problems.problem", "pk": 12, "fields": {"title": "Valid Anagram", "slug": "valid-anagram", "difficulty": 1, "url": "https://leetcode.com/problems/valid-anagram/description/", "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\r\n\r\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\r\n\r\nExample 1:\r\n\r\nInput: s = \"anagram\", t = \"nagaram\"\r\nOutput: true\r\nExample 2:\r\n\r\nInput: s = \"rat\", t = \"car\"\r\nOutput: false", "created_at": "2024-03-03T03:41:32.307Z", "updated_at": "2024-06-19T20:39:58.740Z", "owner": 3, "tags": [3, 17, 6]}}, {"model": "python_problems.problem", "pk": 13, "fields": {"title": "Group Anagrams", "slug": "group-anagrams", "difficulty": 2, "url": "https://leetcode.com/problems/group-anagrams/description/", "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\r\n\r\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\r\n\r\nExample 1:\r\n\r\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\r\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]", "created_at": "2024-03-06T14:46:09.230Z", "updated_at": "2024-06-19T20:40:14.712Z", "owner": 3, "tags": [2, 3, 17, 6]}}, {"model": "python_problems.problem", "pk": 14, "fields": {"title": "Top K Frequent Elements", "slug": "top-k-frequent-elements", "difficulty": 2, "url": "https://leetcode.com/problems/top-k-frequent-elements/description/", "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,1,2,2,3], k = 2\r\nOutput: [1,2]\r\nExample 2:\r\n\r\nInput: nums = [1], k = 1\r\nOutput: [1]", "created_at": "2024-03-10T01:50:46.153Z", "updated_at": "2024-06-19T20:40:26.887Z", "owner": 3, "tags": [2, 20, 11, 18, 3, 19, 21, 17]}}, {"model": "python_problems.problem", "pk": 15, "fields": {"title": "Longest Consecutive Sequence", "slug": "longest-consecutive-sequence", "difficulty": 2, "url": "https://leetcode.com/problems/longest-consecutive-sequence/description/", "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\r\n\r\nYou must write an algorithm that runs in O(n) time.\r\n\r\nExample 1:\r\n\r\nInput: nums = [100,4,200,1,3,2]\r\nOutput: 4\r\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\r\nExample 2:\r\n\r\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\r\nOutput: 9", "created_at": "2024-03-13T12:55:23.076Z", "updated_at": "2024-06-19T20:40:35.242Z", "owner": 3, "tags": [2, 3, 22]}}, {"model": "python_problems.problem", "pk": 16, "fields": {"title": "3Sum", "slug": "3sum", "difficulty": 2, "url": "https://leetcode.com/problems/3sum/description/", "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\r\n\r\nNotice that the solution set must not contain duplicate triplets.\r\n\r\nExample 1:\r\n\r\nInput: nums = [-1,0,1,2,-1,-4]\r\nOutput: [[-1,-1,2],[-1,0,1]]\r\nExplanation: \r\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\r\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\r\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\r\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\r\nNotice that the order of the output and the order of the triplets does not matter.\r\n\r\nExample 2:\r\n\r\nInput: nums = [0,1,1]\r\nOutput: []\r\nExplanation: The only possible triplet does not sum up to 0.\r\n\r\nExample 3:\r\n\r\nInput: nums = [0,0,0]\r\nOutput: [[0,0,0]]\r\nExplanation: The only possible triplet sums up to 0.", "created_at": "2024-03-17T00:00:00Z", "updated_at": "2024-06-19T20:40:45.572Z", "owner": 3, "tags": [2, 17, 4]}}, {"model": "python_problems.problem", "pk": 17, "fields": {"title": "Container With Most Water", "slug": "container-with-most-water", "difficulty": 2, "url": "https://leetcode.com/problems/container-with-most-water/", "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\r\n\r\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\r\n\r\nReturn the maximum amount of water a container can store.\r\n\r\nNotice that you may not slant the container.\r\n\r\nExample 1:\r\n\r\nInput: height = [1,8,6,2,5,4,8,3,7]\r\nOutput: 49\r\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\r\nExample 2:\r\n\r\nInput: height = [1,1]\r\nOutput: 1", "created_at": "2024-03-20T11:04:36.923Z", "updated_at": "2024-06-19T20:43:23.041Z", "owner": 3, "tags": [2, 10, 4]}}, {"model": "python_problems.problem", "pk": 18, "fields": {"title": "Count Pairs Whose Sum is Less than Target", "slug": "count-pairs-whose-sum-is-less-than-target", "difficulty": 1, "url": "https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/", "description": "Given a 0-indexed integer array nums of length n and an integer target, return the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] < target.\r\n \r\nExample 1:\r\n\r\nInput: nums = [-1,1,2,3,1], target = 2\r\nOutput: 3\r\nExplanation: There are 3 pairs of indices that satisfy the conditions in the statement:\r\n- (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target\r\n- (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target \r\n- (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target\r\nNote that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.\r\n\r\nExample 2:\r\n\r\nInput: nums = [-6,2,5,-2,-7,-1,3], target = -2\r\nOutput: 10\r\nExplanation: There are 10 pairs of indices that satisfy the conditions in the statement:\r\n- (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target\r\n- (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target\r\n- (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target\r\n- (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target\r\n- (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target\r\n- (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target\r\n- (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target\r\n- (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target\r\n- (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target\r\n- (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target", "created_at": "2024-03-23T22:09:13.846Z", "updated_at": "2024-06-19T20:43:32.081Z", "owner": 3, "tags": [2, 5, 17, 4]}}, {"model": "python_problems.problem", "pk": 19, "fields": {"title": "Reverse Prefix of Word", "slug": "reverse-prefix-of-word", "difficulty": 1, "url": "https://leetcode.com/problems/reverse-prefix-of-word/", "description": "Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\r\n\r\nFor example, if word = \"abcdefd\" and ch = \"d\", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \"dcbaefd\".\r\nReturn the resulting string.\r\n\r\nExample 1:\r\n\r\nInput: word = \"abcdefd\", ch = \"d\"\r\nOutput: \"dcbaefd\"\r\nExplanation: The first occurrence of \"d\" is at index 3. \r\nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\".\r\nExample 2:\r\n\r\nInput: word = \"xyxzxe\", ch = \"z\"\r\nOutput: \"zxyxxe\"\r\nExplanation: The first and only occurrence of \"z\" is at index 3.\r\nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\".\r\nExample 3:\r\n\r\nInput: word = \"abcd\", ch = \"z\"\r\nOutput: \"abcd\"\r\nExplanation: \"z\" does not exist in word.\r\nYou should not do any reverse operation, the resulting string is \"abcd\".", "created_at": "2024-03-27T09:13:50.769Z", "updated_at": "2024-06-19T20:43:57.869Z", "owner": 3, "tags": [6, 4]}}, {"model": "python_problems.problem", "pk": 20, "fields": {"title": "Find First Palindromic String in the Array", "slug": "find-first-palindromic-string-in-the-array", "difficulty": 1, "url": "https://leetcode.com/problems/find-first-palindromic-string-in-the-array/", "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\r\n\r\nA string is palindromic if it reads the same forward and backward.\r\n\r\nExample 1:\r\n\r\nInput: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\r\nOutput: \"ada\"\r\nExplanation: The first string that is palindromic is \"ada\".\r\nNote that \"racecar\" is also palindromic, but it is not the first.\r\nExample 2:\r\n\r\nInput: words = [\"notapalindrome\",\"racecar\"]\r\nOutput: \"racecar\"\r\nExplanation: The first and only string that is palindromic is \"racecar\".\r\nExample 3:\r\n\r\nInput: words = [\"def\",\"ghi\"]\r\nOutput: \"\"\r\nExplanation: There are no palindromic strings, so the empty string is returned.", "created_at": "2024-03-30T20:18:27.692Z", "updated_at": "2024-06-19T20:44:43.883Z", "owner": 3, "tags": [2, 6, 4]}}, {"model": "python_problems.problem", "pk": 21, "fields": {"title": "Number of Arithmetic Triplets", "slug": "number-of-arithmetic-triplets", "difficulty": 1, "url": "https://leetcode.com/problems/number-of-arithmetic-triplets/", "description": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\r\n\r\ni < j < k,\r\nnums[j] - nums[i] == diff, and\r\nnums[k] - nums[j] == diff.\r\nReturn the number of unique arithmetic triplets.\r\n\r\nExample 1:\r\n\r\nInput: nums = [0,1,4,6,7,10], diff = 3\r\nOutput: 2\r\nExplanation:\r\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\r\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. \r\n\r\nExample 2:\r\n\r\nInput: nums = [4,5,6,7,8,9], diff = 2\r\nOutput: 2\r\nExplanation:\r\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\r\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.", "created_at": "2024-04-03T07:23:04.615Z", "updated_at": "2024-06-19T20:49:16.720Z", "owner": 3, "tags": [2, 23, 3, 4]}}, {"model": "python_problems.problem", "pk": 22, "fields": {"title": "Reverse Words in a String III", "slug": "reverse-words-in-a-string-iii", "difficulty": 1, "url": "https://leetcode.com/problems/reverse-words-in-a-string-iii/", "description": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\r\n\r\nExample 1:\r\n\r\nInput: s = \"Let's take LeetCode contest\"\r\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\r\nExample 2:\r\n\r\nInput: s = \"Mr Ding\"\r\nOutput: \"rM gniD\"", "created_at": "2024-04-06T18:27:41.538Z", "updated_at": "2024-06-19T20:49:28.825Z", "owner": 3, "tags": [6, 4]}}, {"model": "python_problems.problem", "pk": 23, "fields": {"title": "Best Time to Buy and Sell Stock", "slug": "best-time-to-buy-and-sell-stock", "difficulty": 1, "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/", "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\r\n\r\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\r\n\r\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\r\n\r\nExample 1:\r\n\r\nInput: prices = [7,1,5,3,6,4]\r\nOutput: 5\r\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\r\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\r\nExample 2:\r\n\r\nInput: prices = [7,6,4,3,1]\r\nOutput: 0\r\nExplanation: In this case, no transactions are done and the max profit = 0.", "created_at": "2024-04-10T05:32:18.461Z", "updated_at": "2024-06-19T20:49:46.380Z", "owner": 3, "tags": [2, 14, 24]}}, {"model": "python_problems.problem", "pk": 24, "fields": {"title": "Longest Substring Without Repeating Characters", "slug": "longest-substring-without-repeating-characters", "difficulty": 2, "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/", "description": "Given a string s, find the length of the longest \r\nsubstring without repeating characters.\r\n\r\nExample 1:\r\n\r\nInput: s = \"abcabcbb\"\r\nOutput: 3\r\nExplanation: The answer is \"abc\", with the length of 3.\r\nExample 2:\r\n\r\nInput: s = \"bbbbb\"\r\nOutput: 1\r\nExplanation: The answer is \"b\", with the length of 1.\r\nExample 3:\r\n\r\nInput: s = \"pwwkew\"\r\nOutput: 3\r\nExplanation: The answer is \"wke\", with the length of 3.\r\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.", "created_at": "2024-04-13T16:36:55.384Z", "updated_at": "2024-08-10T10:42:04.103Z", "owner": 3, "tags": [3, 24, 6]}}, {"model": "python_problems.problem", "pk": 25, "fields": {"title": "Substrings of Size Three with Distinct Characters", "slug": "substrings-of-size-three-with-distinct-characters", "difficulty": 1, "url": "https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/", "description": "A string is good if there are no repeated characters.\r\n\r\nGiven a string s, return the number of good substrings of length three in s.\r\n\r\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\r\n\r\nA substring is a contiguous sequence of characters in a string.\r\n\r\nExample 1:\r\n\r\nInput: s = \"xyzzaz\"\r\nOutput: 1\r\nExplanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \r\nThe only good substring of length 3 is \"xyz\".\r\nExample 2:\r\n\r\nInput: s = \"aababcabc\"\r\nOutput: 4\r\nExplanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\r\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\".", "created_at": "2024-04-17T03:41:32.307Z", "updated_at": "2024-06-19T20:50:10.189Z", "owner": 3, "tags": [11, 3, 24, 6]}}, {"model": "python_problems.problem", "pk": 26, "fields": {"title": "Find Minimum in Rotated Sorted Array", "slug": "find-minimum-in-rotated-sorted-array", "difficulty": 2, "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/", "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\r\n\r\n[4,5,6,7,0,1,2] if it was rotated 4 times.\r\n[0,1,2,4,5,6,7] if it was rotated 7 times.\r\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\r\n\r\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\r\n\r\nYou must write an algorithm that runs in O(log n) time.\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,4,5,1,2]\r\nOutput: 1\r\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\r\nExample 2:\r\n\r\nInput: nums = [4,5,6,7,0,1,2]\r\nOutput: 0\r\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\r\nExample 3:\r\n\r\nInput: nums = [11,13,15,17]\r\nOutput: 11\r\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times.", "created_at": "2024-04-20T14:46:09.230Z", "updated_at": "2024-08-25T17:24:29.113Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 27, "fields": {"title": "Longest Password", "slug": "longest-password", "difficulty": 1, "url": "https://app.codility.com/programmers/trainings/1/longest_password/", "description": "You would like to set a password for a bank account. However, there are three restrictions on the format of the password:\r\n\r\nit has to contain only alphanumerical characters (az, AZ, 09);\r\nthere should be an even number of letters;\r\nthere should be an odd number of digits.\r\nYou are given a string S consisting of N characters. String S can be divided into words by splitting it at, and removing, the spaces. The goal is to choose the longest word that is a valid password. You can assume that if there are K spaces in string S then there are exactly K + 1 words.\r\n\r\nFor example, given \"test 5 a0A pass007 ?xy1\", there are five words and three of them are valid passwords: \"5\", \"a0A\" and \"pass007\". Thus the longest password is \"pass007\" and its length is 7. Note that neither \"test\" nor \"?xy1\" is a valid password, because \"?\" is not an alphanumerical character and \"test\" contains an even number of digits (zero).\r\n\r\nWrite a function:\r\n\r\ndef solution(S)\r\n\r\nthat, given a non-empty string S consisting of N characters, returns the length of the longest word from the string that is a valid password. If there is no such word, your function should return 1.\r\n\r\nFor example, given S = \"test 5 a0A pass007 ?xy1\", your function should return 7, as explained above.", "created_at": "2024-04-24T01:50:46.153Z", "updated_at": "2024-06-19T20:50:50.593Z", "owner": 3, "tags": [6]}}, {"model": "python_problems.problem", "pk": 28, "fields": {"title": "Flood Depth", "slug": "flood-depth", "difficulty": 2, "url": "https://app.codility.com/programmers/trainings/1/flood_depth/", "description": "You are helping a geologist friend investigate an area with mountain lakes. A recent heavy rainfall has flooded these lakes and their water levels have reached the highest possible point. Your friend is interested to know the maximum depth in the deepest part of these lakes.\r\n\r\nWe simplify the problem in 2-D dimensions. The whole landscape can be divided into small blocks and described by an array A of length N. Each element of A is the altitude of the rock floor of a block (i.e. the height of this block when there is no water at all). After the rainfall, all the low-lying areas (i.e. blocks that have higher blocks on both sides) are holding as much water as possible. You would like to know the maximum depth of water after this entire area is flooded. You can assume that the altitude outside this area is zero and the outside area can accommodate infinite amount of water.\r\n\r\nFor example, consider array A such that:\r\n\r\n    A[0] = 1\r\n    A[1] = 3\r\n    A[2] = 2\r\n    A[3] = 1\r\n    A[4] = 2\r\n    A[5] = 1\r\n    A[6] = 5\r\n    A[7] = 3\r\n    A[8] = 3\r\n    A[9] = 4\r\n    A[10] = 2\r\nThe following picture illustrates the landscape after it has flooded:\r\n\r\n# ____\r\n#   |    _____\r\n#   |____|   |\r\n# ____________|\r\n# flood_depth([3, 1, 2])\r\n\r\nThe gray area is the rock floor described by the array A above and the blue area with dashed lines represents the water filling the low-lying areas with maximum possible volume. Thus, blocks 3 and 5 have a water depth of 2 while blocks 2, 4, 7 and 8 have a water depth of 1. Therefore, the maximum water depth of this area is 2.\r\n\r\nWrite a function:\r\n\r\nclass Solution { public int solution(int[] A); }\r\n\r\nthat, given a non-empty array A consisting of N integers, returns the maximum depth of water.\r\n\r\nGiven array A shown above, the function should return 2, as explained above.\r\n\r\nFor the following array:\r\n\r\n    A[0] = 5\r\n    A[1] = 8\r\nthe function should return 0, because this landscape cannot hold any water.", "created_at": "2024-04-27T12:55:23.076Z", "updated_at": "2024-06-19T20:51:00.479Z", "owner": 3, "tags": [2, 14, 25, 7, 4]}}, {"model": "python_problems.problem", "pk": 29, "fields": {"title": "Trapping Rain Water", "slug": "trapping-rain-water", "difficulty": 3, "url": "https://leetcode.com/problems/trapping-rain-water/", "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\r\n\r\nExample 1:\r\n\r\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\r\n              _\r\n      _      | |_   _\r\n  _  | |~ ~ ~|   |~| |_\r\n_| |~|   |~|           |\r\nOutput: 6\r\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (~ section) are being trapped.\r\nExample 2:\r\n\r\nInput: height = [4,2,0,3,2,5]\r\nOutput: 9", "created_at": "2024-05-01T00:00:00Z", "updated_at": "2024-11-19T19:51:40.266Z", "owner": 3, "tags": [2, 14, 25, 7, 4]}}, {"model": "python_problems.problem", "pk": 30, "fields": {"title": "Climbing Stairs", "slug": "climbing-stairs", "difficulty": 1, "url": "https://leetcode.com/problems/climbing-stairs/", "description": "You are climbing a staircase. It takes n steps to reach the top.\r\n\r\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\r\n\r\nExample 1:\r\n\r\nInput: n = 2\r\nOutput: 2\r\nExplanation: There are two ways to climb to the top.\r\n1. 1 step + 1 step\r\n2. 2 steps\r\nExample 2:\r\n\r\nInput: n = 3\r\nOutput: 3\r\nExplanation: There are three ways to climb to the top.\r\n1. 1 step + 1 step + 1 step\r\n2. 1 step + 2 steps\r\n3. 2 steps + 1 step", "created_at": "2024-05-04T11:04:36.923Z", "updated_at": "2024-06-19T20:51:18.802Z", "owner": 3, "tags": [14, 8, 26]}}, {"model": "python_problems.problem", "pk": 31, "fields": {"title": "House Robber", "slug": "house-robber", "difficulty": 2, "url": "https://leetcode.com/problems/house-robber/", "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\r\n\r\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,1]\r\nOutput: 4\r\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\r\nTotal amount you can rob = 1 + 3 = 4.\r\nExample 2:\r\n\r\nInput: nums = [2,7,9,3,1]\r\nOutput: 12\r\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\r\nTotal amount you can rob = 2 + 9 + 1 = 12.", "created_at": "2024-05-07T22:09:13.846Z", "updated_at": "2024-06-19T20:51:26.779Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 32, "fields": {"title": "House Robber II", "slug": "house-robber-ii", "difficulty": 2, "url": "https://leetcode.com/problems/house-robber-ii/", "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\r\n\r\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\r\n\r\nExample 1:\r\n\r\nInput: nums = [2,3,2]\r\nOutput: 3\r\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\r\nExample 2:\r\n\r\nInput: nums = [1,2,3,1]\r\nOutput: 4\r\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\r\nTotal amount you can rob = 1 + 3 = 4.\r\nExample 3:\r\n\r\nInput: nums = [1,2,3]\r\nOutput: 3", "created_at": "2024-05-11T09:13:50.769Z", "updated_at": "2024-06-19T20:51:34.353Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 33, "fields": {"title": "Longest Palindromic Substring", "slug": "longest-palindromic-substring", "difficulty": 2, "url": "https://leetcode.com/problems/longest-palindromic-substring/", "description": "Given a string s, return the longest \r\npalindromic \r\nsubstring\r\n in s.\r\n\r\nExample 1:\r\n\r\nInput: s = \"babad\"\r\nOutput: \"bab\"\r\nExplanation: \"aba\" is also a valid answer.\r\nExample 2:\r\n\r\nInput: s = \"cbbd\"\r\nOutput: \"bb\"", "created_at": "2024-05-14T20:18:27.692Z", "updated_at": "2024-06-19T20:51:43.799Z", "owner": 3, "tags": [14, 6, 4]}}, {"model": "python_problems.problem", "pk": 34, "fields": {"title": "Palindromic Substrings", "slug": "palindromic-substrings", "difficulty": 2, "url": "https://leetcode.com/problems/palindromic-substrings/", "description": "Given a string s, return the number of palindromic substrings in it.\r\n\r\nA string is a palindrome when it reads the same backward as forward.\r\n\r\nA substring is a contiguous sequence of characters within the string.\r\n\r\nExample 1:\r\n\r\nInput: s = \"abc\"\r\nOutput: 3\r\nExplanation: Three palindromic strings: \"a\", \"b\", \"c\".\r\nExample 2:\r\n\r\nInput: s = \"aaa\"\r\nOutput: 6\r\nExplanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".", "created_at": "2024-05-18T07:23:04.615Z", "updated_at": "2024-06-19T20:51:53.036Z", "owner": 3, "tags": [14, 6, 4]}}, {"model": "python_problems.problem", "pk": 35, "fields": {"title": "Coin Change", "slug": "coin-change", "difficulty": 2, "url": "https://leetcode.com/problems/coin-change/", "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\r\n\r\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\r\n\r\nYou may assume that you have an infinite number of each kind of coin.\r\n\r\nExample 1:\r\n\r\nInput: coins = [1,2,5], amount = 11\r\nOutput: 3\r\nExplanation: 11 = 5 + 5 + 1\r\nExample 2:\r\n\r\nInput: coins = [2], amount = 3\r\nOutput: -1\r\nExample 3:\r\n\r\nInput: coins = [1], amount = 0\r\nOutput: 0", "created_at": "2024-05-21T18:27:41.538Z", "updated_at": "2024-06-19T20:52:16.556Z", "owner": 3, "tags": [2, 27, 14]}}, {"model": "python_problems.problem", "pk": 36, "fields": {"title": "Maximum Product Subarray", "slug": "maximum-product-subarray", "difficulty": 2, "url": "https://leetcode.com/problems/maximum-product-subarray/", "description": "Given an integer array nums, find a subarray that has the largest product, and return the product.\r\n\r\nExample 1:\r\n\r\nInput: nums = [2,3,-2,4]\r\nOutput: 6\r\nExplanation: [2,3] has the largest product 6.\r\n\r\nExample 2:\r\n\r\nInput: nums = [-2,0,-1]\r\nOutput: 0\r\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.", "created_at": "2024-05-25T05:32:18.461Z", "updated_at": "2024-09-12T13:05:21.636Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 37, "fields": {"title": "Hedgehog", "slug": "hedgehog", "difficulty": 4, "url": "https://www.rd.com/wp-content/uploads/2021/04/GettyImages-178918471-scaled.jpg?__cf_chl_f_tk=..Fi.oYcWxgh5EdsPxTSW7VAt6QcWQYE1jKsEhpMdcM-1717111857-0.0.1.1-3604", "description": "Create a hedgehog in ASCII.", "created_at": "2024-05-28T16:36:55.384Z", "updated_at": "2024-06-19T20:52:42.259Z", "owner": 4, "tags": [28]}}, {"model": "python_problems.problem", "pk": 38, "fields": {"title": "Word Break", "slug": "word-break", "difficulty": 2, "url": "https://leetcode.com/problems/word-break/", "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\r\n\r\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\r\n\r\nExample 1:\r\n\r\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\r\nOutput: true\r\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\r\nExample 2:\r\n\r\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\r\nOutput: true\r\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\r\nNote that you are allowed to reuse a dictionary word.\r\nExample 3:\r\n\r\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\r\nOutput: false", "created_at": "2024-06-01T03:41:32.307Z", "updated_at": "2024-06-19T20:52:50.663Z", "owner": 3, "tags": [2, 14, 3, 26, 6, 29]}}, {"model": "python_problems.problem", "pk": 39, "fields": {"title": "Longest Increasing Subsequence", "slug": "longest-increasing-subsequence", "difficulty": 2, "url": "https://leetcode.com/problems/longest-increasing-subsequence/", "description": "Given an integer array nums, return the length of the longest strictly increasing \r\nsubsequence\r\n\r\nExample 1:\r\n\r\nInput: nums = [10,9,2,5,3,7,101,18]\r\nOutput: 4\r\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\r\nExample 2:\r\n\r\nInput: nums = [0,1,0,3,2,3]\r\nOutput: 4\r\nExample 3:\r\n\r\nInput: nums = [7,7,7,7,7,7,7]\r\nOutput: 1", "created_at": "2024-06-04T14:46:09.230Z", "updated_at": "2024-06-19T20:53:01.083Z", "owner": 3, "tags": [2, 5, 14]}}, {"model": "python_problems.problem", "pk": 40, "fields": {"title": "Partition Equal Subset Sum", "slug": "partition-equal-subset-sum", "difficulty": 2, "url": "https://leetcode.com/problems/partition-equal-subset-sum", "description": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,5,11,5]\r\nOutput: true\r\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\r\n\r\nExample 2:\r\n\r\nInput: nums = [1,2,3,5]\r\nOutput: false\r\nExplanation: The array cannot be partitioned into equal sum subsets.", "created_at": "2024-06-08T01:50:46.153Z", "updated_at": "2024-06-19T20:53:09.321Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 41, "fields": {"title": "Longest Common Subsequence", "slug": "longest-common-subsequence", "difficulty": 2, "url": "https://leetcode.com/problems/longest-common-subsequence/", "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\r\n\r\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\r\n\r\nFor example, \"ace\" is a subsequence of \"abcde\".\r\nA common subsequence of two strings is a subsequence that is common to both strings.\r\n\r\nExample 1:\r\n\r\nInput: text1 = \"abcde\", text2 = \"ace\" \r\nOutput: 3  \r\nExplanation: The longest common subsequence is \"ace\" and its length is 3.\r\nExample 2:\r\n\r\nInput: text1 = \"abc\", text2 = \"abc\"\r\nOutput: 3\r\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\r\nExample 3:\r\n\r\nInput: text1 = \"abc\", text2 = \"def\"\r\nOutput: 0\r\nExplanation: There is no such common subsequence, so the result is 0.", "created_at": "2024-06-11T12:55:23.076Z", "updated_at": "2024-06-19T20:53:20.141Z", "owner": 3, "tags": [14, 6]}}, {"model": "python_problems.problem", "pk": 42, "fields": {"title": "Maximum Subarray", "slug": "maximum-subarray", "difficulty": 2, "url": "https://leetcode.com/problems/maximum-subarray/", "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\r\n\r\nExample 1:\r\n\r\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\r\nOutput: 6\r\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\r\nExample 2:\r\n\r\nInput: nums = [1]\r\nOutput: 1\r\nExplanation: The subarray [1] has the largest sum 1.\r\nExample 3:\r\n\r\nInput: nums = [5,4,-1,7,8]\r\nOutput: 23\r\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.", "created_at": "2024-06-15T00:00:00Z", "updated_at": "2024-06-19T20:53:26.927Z", "owner": 3, "tags": [2, 18, 14]}}, {"model": "python_problems.problem", "pk": 46, "fields": {"title": "Combine Two Tables", "slug": "combine-two-tables", "difficulty": 1, "url": "https://leetcode.com/problems/combine-two-tables/", "description": "Write a solution to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead.\r\n\r\nReturn the result table in any order.\r\n\r\nInput: \r\nPerson table:\r\n+----------+----------+-----------+\r\n| personId | lastName | firstName |\r\n+----------+----------+-----------+\r\n| 1        | Wang     | Allen     |\r\n| 2        | Alice    | Bob       |\r\n+----------+----------+-----------+\r\nAddress table:\r\n+-----------+----------+---------------+------------+\r\n| addressId | personId | city          | state      |\r\n+-----------+----------+---------------+------------+\r\n| 1         | 2        | New York City | New York   |\r\n| 2         | 3        | Leetcode      | California |\r\n+-----------+----------+---------------+------------+\r\n\r\nOutput: \r\n+-----------+----------+---------------+----------+\r\n| firstName | lastName | city          | state    |\r\n+-----------+----------+---------------+----------+\r\n| Allen     | Wang     | Null          | Null     |\r\n| Bob       | Alice    | New York City | New York |\r\n+-----------+----------+---------------+----------+", "created_at": "2024-06-20T12:25:57.993Z", "updated_at": "2024-06-20T12:25:58.008Z", "owner": 3, "tags": [30]}}, {"model": "python_problems.problem", "pk": 47, "fields": {"title": "Binary Search", "slug": "binary-search", "difficulty": 1, "url": "https://leetcode.com/problems/binary-search/", "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\nExample 1:\r\n\r\nInput: nums = [-1,0,3,5,9,12], target = 9\r\nOutput: 4\r\nExplanation: 9 exists in nums and its index is 4\r\n\r\nExample 2:\r\n\r\nInput: nums = [-1,0,3,5,9,12], target = 2\r\nOutput: -1\r\nExplanation: 2 does not exist in nums so return -1", "created_at": "2024-07-16T20:33:45.722Z", "updated_at": "2024-07-16T20:33:45.729Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 48, "fields": {"title": "Search a 2D Matrix", "slug": "search-a-2d-matrix", "difficulty": 2, "url": "https://leetcode.com/problems/search-a-2d-matrix/", "description": "You are given an m x n integer matrix matrix with the following two properties:\r\n\r\nEach row is sorted in non-decreasing order.\r\nThe first integer of each row is greater than the last integer of the previous row.\r\nGiven an integer target, return true if target is in matrix or false otherwise.\r\n\r\nYou must write a solution in O(log(m * n)) time complexity.\r\n\r\nExample 1:\r\n\r\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\r\nOutput: true\r\n\r\nExample 2:\r\n\r\n\r\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\r\nOutput: false", "created_at": "2024-07-22T21:17:37.489Z", "updated_at": "2024-07-22T21:17:37.502Z", "owner": 3, "tags": [2, 5, 31]}}, {"model": "python_problems.problem", "pk": 49, "fields": {"title": "Koko Eating Bananas", "slug": "koko-eating-bananas", "difficulty": 2, "url": "https://leetcode.com/problems/koko-eating-bananas/", "description": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\r\n\r\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\r\n\r\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\r\n\r\nReturn the minimum integer k such that she can eat all the bananas within h hours.\r\n\r\nExample 1:\r\n\r\nInput: piles = [3,6,7,11], h = 8\r\nOutput: 4\r\n\r\nExample 2:\r\n\r\nInput: piles = [30,11,23,4,20], h = 5\r\nOutput: 30\r\n\r\nExample 3:\r\n\r\nInput: piles = [30,11,23,4,20], h = 6\r\nOutput: 23", "created_at": "2024-07-22T23:42:04.819Z", "updated_at": "2024-07-22T23:42:04.841Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 50, "fields": {"title": "Search in Rotated Sorted Array", "slug": "search-in-rotated-sorted-array", "difficulty": 2, "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/", "description": "There is an integer array nums sorted in ascending order (with distinct values).\r\n\r\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\r\n\r\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\nExample 1:\r\n\r\nInput: nums = [4,5,6,7,0,1,2], target = 0\r\nOutput: 4\r\n\r\nExample 2:\r\n\r\nInput: nums = [4,5,6,7,0,1,2], target = 3\r\nOutput: -1\r\nExample 3:", "created_at": "2024-07-23T19:50:23.896Z", "updated_at": "2024-07-23T19:50:23.910Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 51, "fields": {"title": "Valid Sudoku", "slug": "valid-sudoku", "difficulty": 2, "url": "https://leetcode.com/problems/valid-sudoku/", "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\r\n\r\nEach row must contain the digits 1-9 without repetition.\r\nEach column must contain the digits 1-9 without repetition.\r\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\r\nNote:\r\n\r\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\r\nOnly the filled cells need to be validated according to the mentioned rules.\r\n \r\n\r\nExample 1:\r\n\r\nInput: board = \r\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\r\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\r\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\r\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\r\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\r\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\r\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\r\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\r\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\r\nOutput: true\r\n\r\nExample 2:\r\n\r\nInput: board = \r\n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\r\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\r\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\r\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\r\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\r\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\r\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\r\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\r\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\r\nOutput: false\r\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.", "created_at": "2024-07-24T22:32:22.249Z", "updated_at": "2024-07-24T22:32:22.264Z", "owner": 3, "tags": [2, 3, 31]}}, {"model": "python_problems.problem", "pk": 52, "fields": {"title": "Product of Array Except Self", "slug": "product-of-array-except-self", "difficulty": 2, "url": "https://leetcode.com/problems/product-of-array-except-self/", "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\r\n\r\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\r\n\r\nYou must write an algorithm that runs in O(n) time and without using the division operation.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,4]\r\nOutput: [24,12,8,6]", "created_at": "2024-07-25T12:09:21.318Z", "updated_at": "2024-08-22T11:57:31.693Z", "owner": 3, "tags": [2, 32]}}, {"model": "python_problems.problem", "pk": 53, "fields": {"title": "Encode and Decode Strings", "slug": "encode-and-decode-strings", "difficulty": 2, "url": "https://www.lintcode.com/problem/659/", "description": "Description\r\nDesign an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\r\n\r\nPlease implement encode and decode\r\n\r\nBecause the string may contain any of the 256 legal ASCII characters, your algorithm must be able to handle any character that may appear\r\n\r\nDo not rely on any libraries, the purpose of this problem is to implement the \"encode\" and \"decode\" algorithms on your own", "created_at": "2024-07-25T22:37:31.541Z", "updated_at": "2024-07-25T22:37:31.553Z", "owner": 3, "tags": [2, 6]}}, {"model": "python_problems.problem", "pk": 54, "fields": {"title": "Longest Repeating Character Replacement", "slug": "longest-repeating-character-replacement", "difficulty": 2, "url": "https://leetcode.com/problems/longest-repeating-character-replacement/", "description": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character.\r\nYou can perform this operation at most k times.\r\n\r\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\r\n\r\nExample 1:\r\n\r\nInput: s = \"ABAB\", k = 2\r\nOutput: 4\r\nExplanation: Replace the two 'A's with two 'B's or vice versa.\r\n\r\nExample 2:\r\n\r\nInput: s = \"AABABBA\", k = 1\r\nOutput: 4\r\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\r\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\r\nThere may exists other ways to achieve this answer too.", "created_at": "2024-07-26T23:15:51.461Z", "updated_at": "2024-07-26T23:15:51.474Z", "owner": 3, "tags": [3, 24, 6]}}, {"model": "python_problems.problem", "pk": 55, "fields": {"title": "Permutation in String", "slug": "permutation-in-string", "difficulty": 2, "url": "https://leetcode.com/problems/permutation-in-string/", "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\r\n\r\nIn other words, return true if one of s1's permutations is the substring of s2.\r\n\r\nExample 1:\r\n\r\nInput: s1 = \"ab\", s2 = \"eidbaooo\"\r\nOutput: true\r\nExplanation: s2 contains one permutation of s1 (\"ba\").\r\n\r\nExample 2:\r\n\r\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\r\nOutput: false", "created_at": "2024-07-27T23:31:59.111Z", "updated_at": "2024-11-24T11:33:13.572Z", "owner": 3, "tags": [3, 24, 6, 4]}}, {"model": "python_problems.problem", "pk": 56, "fields": {"title": "Minimum Window Substring", "slug": "minimum-window-substring", "difficulty": 3, "url": "https://leetcode.com/problems/minimum-window-substring/", "description": "Given two strings s and t of lengths m and n respectively, return the minimum window \r\nsubstring\r\n of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\r\n\r\nThe testcases will be generated such that the answer is unique.\r\n\r\nExample 1:\r\n\r\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\r\nOutput: \"BANC\"\r\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\r\n\r\nExample 2:\r\n\r\nInput: s = \"a\", t = \"a\"\r\nOutput: \"a\"\r\nExplanation: The entire string s is the minimum window.\r\n\r\nExample 3:\r\n\r\nInput: s = \"a\", t = \"aa\"\r\nOutput: \"\"\r\nExplanation: Both 'a's from t must be included in the window.\r\nSince the largest window of s only has one 'a', return empty string.", "created_at": "2024-08-06T14:10:29.004Z", "updated_at": "2024-08-06T14:10:29.022Z", "owner": 3, "tags": [3, 24, 6]}}, {"model": "python_problems.problem", "pk": 57, "fields": {"title": "Sliding Window Maximum", "slug": "sliding-window-maximum", "difficulty": 3, "url": "https://leetcode.com/problems/sliding-window-maximum/", "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\r\n\r\nReturn the max sliding window.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\r\nOutput: [3,3,5,5,6,7]\r\nExplanation: \r\nWindow position                Max\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       3\r\n 1 [3  -1  -3] 5  3  6  7       3\r\n 1  3 [-1  -3  5] 3  6  7       5\r\n 1  3  -1 [-3  5  3] 6  7       5\r\n 1  3  -1  -3 [5  3  6] 7       6\r\n 1  3  -1  -3  5 [3  6  7]      7\r\n\r\nExample 2:\r\n\r\nInput: nums = [1], k = 1\r\nOutput: [1]", "created_at": "2024-08-08T14:29:21.623Z", "updated_at": "2024-08-08T14:29:21.638Z", "owner": 3, "tags": [2, 19, 34, 33, 24]}}, {"model": "python_problems.problem", "pk": 58, "fields": {"title": "Min Stack", "slug": "min-stack", "difficulty": 2, "url": "https://leetcode.com/problems/min-stack/", "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\r\n\r\nImplement the MinStack class:\r\n\r\nMinStack() initializes the stack object.\r\nvoid push(int val) pushes the element val onto the stack.\r\nvoid pop() removes the element on the top of the stack.\r\nint top() gets the top element of the stack.\r\nint getMin() retrieves the minimum element in the stack.\r\nYou must implement a solution with O(1) time complexity for each function.\r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\r\n[[],[-2],[0],[-3],[],[],[],[]]\r\n\r\nOutput\r\n[null,null,null,null,-3,null,0,-2]\r\n\r\nExplanation\r\nMinStack minStack = new MinStack();\r\nminStack.push(-2);\r\nminStack.push(0);\r\nminStack.push(-3);\r\nminStack.getMin(); // return -3\r\nminStack.pop();\r\nminStack.top();    // return 0\r\nminStack.getMin(); // return -2\r\n\r\n\r\n\r\n# Python:\r\nclass MinStack:\r\n\r\n    def __init__(self):\r\n        \r\n\r\n    def push(self, val: int) -> None:\r\n        \r\n\r\n    def pop(self) -> None:\r\n        \r\n\r\n    def top(self) -> int:\r\n        \r\n\r\n    def getMin(self) -> int:\r\n        \r\n\r\n\r\n# Your MinStack object will be instantiated and called as such:\r\n# obj = MinStack()\r\n# obj.push(val)\r\n# obj.pop()\r\n# param_3 = obj.top()\r\n# param_4 = obj.getMin()\r\n\r\n\r\n\r\n// JavaScript:\r\nvar MinStack = function() {\r\n    \r\n};\r\n\r\n/** \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nMinStack.prototype.push = function(val) {\r\n    \r\n};\r\n\r\n/**\r\n * @return {void}\r\n */\r\nMinStack.prototype.pop = function() {\r\n    \r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMinStack.prototype.top = function() {\r\n    \r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMinStack.prototype.getMin = function() {\r\n    \r\n};\r\n\r\n/** \r\n * Your MinStack object will be instantiated and called as such:\r\n * var obj = new MinStack()\r\n * obj.push(val)\r\n * obj.pop()\r\n * var param_3 = obj.top()\r\n * var param_4 = obj.getMin()\r\n */", "created_at": "2024-08-08T20:22:23.555Z", "updated_at": "2024-08-23T19:15:10.238Z", "owner": 3, "tags": [35, 7]}}, {"model": "python_problems.problem", "pk": 59, "fields": {"title": "Evaluate Reverse Polish Notation", "slug": "evaluate-reverse-polish-notation", "difficulty": 2, "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/", "description": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\r\n\r\nEvaluate the expression. Return an integer that represents the value of the expression.\r\n\r\nNote that:\r\n\r\nThe valid operators are '+', '-', '*', and '/'.\r\nEach operand may be an integer or another expression.\r\nThe division between two integers always truncates toward zero.\r\nThere will not be any division by zero.\r\nThe input represents a valid arithmetic expression in a reverse polish notation.\r\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.\r\n\r\nExample 1:\r\n\r\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\r\nOutput: 9\r\nExplanation: ((2 + 1) * 3) = 9\r\nExample 2:\r\n\r\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\r\nOutput: 6\r\nExplanation: (4 + (13 / 5)) = 6\r\nExample 3:\r\n\r\nInput: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\r\nOutput: 22\r\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\r\n= ((10 * (6 / (12 * -11))) + 17) + 5\r\n= ((10 * (6 / -132)) + 17) + 5\r\n= ((10 * 0) + 17) + 5\r\n= (0 + 17) + 5\r\n= 17 + 5\r\n= 22", "created_at": "2024-08-08T21:30:02.363Z", "updated_at": "2024-08-08T21:30:02.377Z", "owner": 3, "tags": [2, 8, 7]}}, {"model": "python_problems.problem", "pk": 60, "fields": {"title": "Daily Temperatures", "slug": "daily-temperatures", "difficulty": 2, "url": "https://leetcode.com/problems/daily-temperatures/", "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\r\n\r\nExample 1:\r\n\r\nInput: temperatures = [73,74,75,71,69,72,76,73]\r\nOutput: [1,1,4,2,1,1,0,0]\r\n\r\nExample 2:\r\n\r\nInput: temperatures = [30,40,50,60]\r\nOutput: [1,1,1,0]\r\n\r\nExample 3:\r\n\r\nInput: temperatures = [30,60,90]\r\nOutput: [1,1,0]", "created_at": "2024-08-09T14:33:17.053Z", "updated_at": "2024-08-09T14:33:17.070Z", "owner": 3, "tags": [2, 25, 7]}}, {"model": "python_problems.problem", "pk": 61, "fields": {"title": "Car Fleet", "slug": "car-fleet", "difficulty": 2, "url": "https://leetcode.com/problems/car-fleet/", "description": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.\r\n\r\nYou are given two integer array position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.\r\n\r\nA car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.\r\n\r\nA car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.\r\n\r\nIf a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.\r\n\r\nReturn the number of car fleets that will arrive at the destination.\r\n\r\nExample 1:\r\n\r\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\r\n\r\nOutput: 3\r\n\r\nExplanation:\r\n\r\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at target.\r\nThe car starting at 0 (speed 1) does not catch up to any other car, so it is a fleet by itself.\r\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\r\n\r\nExample 2:\r\n\r\nInput: target = 10, position = [3], speed = [3]\r\n\r\nOutput: 1\r\n\r\nExplanation:\r\n\r\nThere is only one car, hence there is only one fleet.\r\n\r\nExample 3:\r\n\r\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\r\n\r\nOutput: 1\r\n\r\nExplanation:\r\n\r\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The car starting at 4 (speed 1) travels to 5.\r\nThen, the fleet at 4 (speed 2) and the car at position 5 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.", "created_at": "2024-08-09T16:05:09.022Z", "updated_at": "2024-08-09T16:05:09.044Z", "owner": 3, "tags": [2, 25, 17, 7]}}, {"model": "python_problems.problem", "pk": 62, "fields": {"title": "Subsets", "slug": "subsets", "difficulty": 2, "url": "https://leetcode.com/problems/subsets/", "description": "Given an integer array nums of unique elements, return all possible \r\nsubsets\r\n (the power set).\r\n\r\nThe solution set must not contain duplicate subsets. Return the solution in any order.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3]\r\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\r\n\r\nExample 2:\r\n\r\nInput: nums = [0]\r\nOutput: [[],[0]]", "created_at": "2024-08-12T19:54:25.514Z", "updated_at": "2024-08-12T19:54:35.769Z", "owner": 3, "tags": [2, 36, 39]}}, {"model": "python_problems.problem", "pk": 63, "fields": {"title": "Subsets II", "slug": "subsets-ii", "difficulty": 2, "url": "https://leetcode.com/problems/subsets-ii/", "description": "Given an integer array nums that may contain duplicates, return all possible \r\nsubsets\r\n (the power set).\r\n\r\nThe solution set must not contain duplicate subsets. Return the solution in any order.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,2]\r\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\r\n\r\nExample 2:\r\n\r\nInput: nums = [0]\r\nOutput: [[],[0]]", "created_at": "2024-08-13T11:56:36.659Z", "updated_at": "2024-08-13T11:56:36.673Z", "owner": 3, "tags": [2, 36, 39]}}, {"model": "python_problems.problem", "pk": 64, "fields": {"title": "Combination Sum", "slug": "combination-sum", "difficulty": 2, "url": "https://leetcode.com/problems/combination-sum/", "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\r\n\r\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the \r\nfrequency\r\n of at least one of the chosen numbers is different.\r\n\r\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\r\n\r\nExample 1:\r\n\r\nInput: candidates = [2,3,6,7], target = 7\r\nOutput: [[2,2,3],[7]]\r\nExplanation:\r\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\r\n7 is a candidate, and 7 = 7.\r\nThese are the only two combinations.\r\n\r\nExample 2:\r\n\r\nInput: candidates = [2,3,5], target = 8\r\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\r\n\r\nExample 3:\r\n\r\nInput: candidates = [2], target = 1\r\nOutput: []", "created_at": "2024-08-13T14:44:16.893Z", "updated_at": "2024-08-13T14:44:16.906Z", "owner": 3, "tags": [2, 36]}}, {"model": "python_problems.problem", "pk": 65, "fields": {"title": "Combination Sum II", "slug": "combination-sum-ii", "difficulty": 2, "url": "https://leetcode.com/problems/combination-sum-ii/", "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\r\n\r\nEach number in candidates may only be used once in the combination.\r\n\r\nNote: The solution set must not contain duplicate combinations.\r\n\r\nExample 1:\r\n\r\nInput: candidates = [10,1,2,7,6,1,5], target = 8\r\nOutput: \r\n[\r\n[1,1,6],\r\n[1,2,5],\r\n[1,7],\r\n[2,6]\r\n]\r\n\r\nExample 2:\r\n\r\nInput: candidates = [2,5,2,1,2], target = 5\r\nOutput: \r\n[\r\n[1,2,2],\r\n[5]\r\n]", "created_at": "2024-08-13T19:03:33.039Z", "updated_at": "2024-08-13T19:03:33.054Z", "owner": 3, "tags": [2, 36]}}, {"model": "python_problems.problem", "pk": 66, "fields": {"title": "Permutations", "slug": "permutations", "difficulty": 2, "url": "https://leetcode.com/problems/permutations/", "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3]\r\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\r\n\r\nExample 2:\r\n\r\nInput: nums = [0,1]\r\nOutput: [[0,1],[1,0]]\r\n\r\nExample 3:\r\n\r\nInput: nums = [1]\r\nOutput: [[1]]", "created_at": "2024-08-13T21:53:32.292Z", "updated_at": "2024-08-13T21:53:32.308Z", "owner": 3, "tags": [2, 36]}}, {"model": "python_problems.problem", "pk": 67, "fields": {"title": "Word Search", "slug": "word-search", "difficulty": 2, "url": "https://leetcode.com/problems/word-search/", "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\r\n\r\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\r\n\r\nExample 1:\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\r\nOutput: true\r\n\r\nExample 2:\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\r\nOutput: true\r\n\r\nExample 3:\r\n\r\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\r\nOutput: false", "created_at": "2024-08-14T14:16:25.603Z", "updated_at": "2024-08-14T14:16:25.618Z", "owner": 3, "tags": [2, 36, 31, 6]}}, {"model": "python_problems.problem", "pk": 68, "fields": {"title": "Palindrome Partitioning", "slug": "palindrome-partitioning", "difficulty": 2, "url": "https://leetcode.com/problems/palindrome-partitioning/", "description": "Given a string s, partition s such that every \r\nsubstring\r\n of the partition is a \r\npalindrome\r\n. Return all possible palindrome partitioning of s.\r\n\r\nExample 1:\r\n\r\nInput: s = \"aab\"\r\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\r\n\r\nExample 2:\r\n\r\nInput: s = \"a\"\r\nOutput: [[\"a\"]]", "created_at": "2024-08-14T20:43:13.647Z", "updated_at": "2024-08-14T20:43:13.662Z", "owner": 3, "tags": [36, 14, 6]}}, {"model": "python_problems.problem", "pk": 69, "fields": {"title": "Letter Combinations of a Phone Number", "slug": "letter-combinations-of-a-phone-number", "difficulty": 2, "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/", "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\r\n\r\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\r\n\r\nExample 1:\r\n\r\nInput: digits = \"23\"\r\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\r\nExample 2:\r\n\r\nInput: digits = \"\"\r\nOutput: []\r\nExample 3:\r\n\r\nInput: digits = \"2\"\r\nOutput: [\"a\",\"b\",\"c\"]", "created_at": "2024-08-15T11:05:49.756Z", "updated_at": "2024-08-15T11:05:49.786Z", "owner": 3, "tags": [36, 3, 6]}}, {"model": "python_problems.problem", "pk": 70, "fields": {"title": "N-Queens", "slug": "n-queens", "difficulty": 3, "url": "https://leetcode.com/problems/n-queens/", "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\r\n\r\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\r\n\r\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\r\n\r\nExample 1:\r\n\r\nInput: n = 4\r\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\r\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\r\n\r\nExample 2:\r\n\r\nInput: n = 1\r\nOutput: [[\"Q\"]]", "created_at": "2024-08-15T20:18:14.967Z", "updated_at": "2024-08-15T20:18:14.981Z", "owner": 3, "tags": [2, 36]}}, {"model": "python_problems.problem", "pk": 71, "fields": {"title": "Time Based Key-Value Store", "slug": "time-based-key-value-store", "difficulty": 2, "url": "https://leetcode.com/problems/time-based-key-value-store/", "description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\r\n\r\nImplement the TimeMap class:\r\n\r\nTimeMap() Initializes the object of the data structure.\r\nvoid set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.\r\nString get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns \"\".\r\n\r\nExample 1:\r\n\r\nInput\r\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\r\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\r\nOutput\r\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\r\n\r\nExplanation\r\nTimeMap timeMap = new TimeMap();\r\ntimeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\r\ntimeMap.get(\"foo\", 1);         // return \"bar\"\r\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\r\ntimeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\r\ntimeMap.get(\"foo\", 4);         // return \"bar2\"\r\ntimeMap.get(\"foo\", 5);         // return \"bar2\"", "created_at": "2024-08-26T21:04:07.667Z", "updated_at": "2024-08-26T21:04:07.682Z", "owner": 3, "tags": [5, 35, 3, 6]}}, {"model": "python_problems.problem", "pk": 72, "fields": {"title": "Generate Parentheses", "slug": "generate-parentheses", "difficulty": 2, "url": "https://leetcode.com/problems/generate-parentheses/description/", "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\r\n\r\nExample 1:\r\n\r\nInput: n = 3\r\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\r\n\r\nExample 2:\r\n\r\nInput: n = 1\r\nOutput: [\"()\"]", "created_at": "2024-09-06T19:13:47.109Z", "updated_at": "2024-09-06T19:13:47.127Z", "owner": 3, "tags": [36, 14, 6]}}, {"model": "python_problems.problem", "pk": 73, "fields": {"title": "Min Cost Climbing Stairs", "slug": "min-cost-climbing-stairs", "difficulty": 1, "url": "https://leetcode.com/problems/min-cost-climbing-stairs/", "description": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\r\n\r\nYou can either start from the step with index 0, or the step with index 1.\r\n\r\nReturn the minimum cost to reach the top of the floor.\r\n\r\nExample 1:\r\n\r\nInput: cost = [10,15,20]\r\nOutput: 15\r\nExplanation: You will start at index 1.\r\n- Pay 15 and climb two steps to reach the top.\r\nThe total cost is 15.\r\n\r\nExample 2:\r\n\r\nInput: cost = [1,100,1,1,1,100,1,1,100,1]\r\nOutput: 6\r\nExplanation: You will start at index 0.\r\n- Pay 1 and climb two steps to reach index 2.\r\n- Pay 1 and climb two steps to reach index 4.\r\n- Pay 1 and climb two steps to reach index 6.\r\n- Pay 1 and climb one step to reach index 7.\r\n- Pay 1 and climb two steps to reach index 9.\r\n- Pay 1 and climb one step to reach the top.\r\nThe total cost is 6.", "created_at": "2024-09-07T17:28:15.097Z", "updated_at": "2024-09-07T17:28:15.113Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 74, "fields": {"title": "Decode Ways", "slug": "decode-ways", "difficulty": 2, "url": "https://leetcode.com/problems/decode-ways/description/", "description": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\r\n\r\n\"1\" -> 'A'\r\n\r\n\"2\" -> 'B'\r\n\r\n...\r\n\r\n\"25\" -> 'Y'\r\n\r\n\"26\" -> 'Z'\r\n\r\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\r\n\r\nFor example, \"11106\" can be decoded into:\r\n\r\n\"AAJF\" with the grouping (1, 1, 10, 6)\r\n\"KJF\" with the grouping (11, 10, 6)\r\nThe grouping (1, 11, 06) is invalid because \"06\" is not a valid code (only \"6\" is valid).\r\nNote: there may be strings that are impossible to decode.\r\n\r\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\r\n\r\nExample 1:\r\n\r\nInput: s = \"12\"\r\n\r\nOutput: 2\r\n\r\nExplanation:\r\n\r\n\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"226\"\r\n\r\nOutput: 3\r\n\r\nExplanation:\r\n\r\n\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\r\n\r\n\r\nExample 3:\r\n\r\nInput: s = \"06\"\r\n\r\nOutput: 0\r\n\r\nExplanation:\r\n\r\n\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). In this case, the string is not a valid encoding, so return 0.", "created_at": "2024-09-11T19:53:08.648Z", "updated_at": "2024-09-11T19:53:08.671Z", "owner": 3, "tags": [14, 6]}}, {"model": "python_problems.problem", "pk": 75, "fields": {"title": "Invert Binary Tree", "slug": "invert-binary-tree", "difficulty": 1, "url": "https://leetcode.com/problems/invert-binary-tree/description/", "description": "Given the root of a binary tree, invert the tree, and return its root.\r\n\r\nExample 1:\r\n\r\nInput: root = [4,2,7,1,3,6,9]\r\n    __4__\r\n   /     \\\r\n  2       7\r\n / \\     / \\\r\n1   3   6   9\r\n\r\nOutput: [4,7,2,9,6,3,1]\r\n    __4__\r\n   /     \\\r\n  7       2\r\n / \\     / \\\r\n9   6   3   1\r\n\r\nExample 2:\r\n\r\nInput: root = [2,1,3]\r\nOutput: [2,3,1]\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: []", "created_at": "2024-09-14T11:41:02.896Z", "updated_at": "2024-12-15T22:00:37.462Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 76, "fields": {"title": "Maximum Depth of Binary Tree", "slug": "maximum-depth-of-binary-tree", "difficulty": 1, "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/description/", "description": "Given the root of a binary tree, return its maximum depth.\r\n\r\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\r\n\r\nExample 1:\r\n\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: 3\r\n\r\nExample 2:\r\n\r\nInput: root = [1,null,2]\r\nOutput: 2", "created_at": "2024-09-19T10:30:58.715Z", "updated_at": "2024-09-19T10:30:58.743Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 77, "fields": {"title": "Diameter of Binary Tree", "slug": "diameter-of-binary-tree", "difficulty": 1, "url": "https://leetcode.com/problems/diameter-of-binary-tree/description/", "description": "Given the root of a binary tree, return the length of the diameter of the tree.\r\n\r\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\r\n\r\nThe length of a path between two nodes is represented by the number of edges between them.\r\n\r\nExample 1:\r\n\r\nInput: root = [1,2,3,4,5]\r\n\r\n    __1\r\n   /   \\\r\n  2     3\r\n / \\\r\n4   5\r\n\r\nOutput: 3\r\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\r\n\r\nExample 2:\r\n\r\nInput: root = [1,2]\r\nOutput: 1", "created_at": "2024-09-19T13:47:49.038Z", "updated_at": "2024-09-19T13:47:49.056Z", "owner": 3, "tags": [42, 41, 40]}}, {"model": "python_problems.problem", "pk": 78, "fields": {"title": "Balanced Binary Tree", "slug": "balanced-binary-tree", "difficulty": 1, "url": "https://leetcode.com/problems/balanced-binary-tree/description/", "description": "Given a binary tree, determine if it is \r\nheight-balanced\r\n\r\nExample 1:\r\n\r\nInput: root = [3,9,20,null,null,15,7]\r\n\r\n  3___\r\n /    \\\r\n9     _20\r\n     /   \\\r\n    15    7\r\n\r\nOutput: true\r\n\r\nExample 2:\r\n\r\nInput: root = [1,2,2,3,3,null,null,4,4]\r\n\r\n        __1\r\n       /   \\\r\n    __2     2\r\n   /   \\\r\n  3     3\r\n / \\\r\n4   4\r\n\r\nOutput: false\r\n\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: true", "created_at": "2024-09-19T16:04:57.087Z", "updated_at": "2024-09-19T16:04:57.106Z", "owner": 3, "tags": [42, 41, 40]}}, {"model": "python_problems.problem", "pk": 79, "fields": {"title": "Same Tree", "slug": "same-tree", "difficulty": 1, "url": "https://leetcode.com/problems/same-tree/description/", "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\r\n\r\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\r\n\r\nExample 1:\r\n\r\nInput: p = [1,2,3], q = [1,2,3]\r\nOutput: true\r\n\r\nExample 2:\r\n\r\nInput: p = [1,2], q = [1,null,2]\r\nOutput: false\r\nExample 3:\r\n\r\nInput: p = [1,2,1], q = [1,1,2]\r\nOutput: false", "created_at": "2024-09-20T14:38:28.057Z", "updated_at": "2024-09-20T14:38:28.079Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 80, "fields": {"title": "Subtree of Another Tree", "slug": "subtree-of-another-tree", "difficulty": 1, "url": "https://leetcode.com/problems/subtree-of-another-tree/description/", "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\r\n\r\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\r\n\r\nExample 1:\r\n\r\nInput: root = [3,4,5,1,2], \r\n\r\n    __3\r\n   /   \\\r\n  4     5\r\n / \\\r\n1   2\r\n\r\nsubRoot = [4,1,2]\r\n  4\r\n / \\\r\n1   2\r\n\r\nOutput: true\r\n\r\nExample 2:\r\n\r\nInput: root = [3,4,5,1,2,null,null,null,null,0],\r\n\r\n    ____3\r\n   /     \\\r\n  4__     5\r\n /   \\\r\n1     2\r\n     /\r\n    0\r\n\r\nsubRoot = [4,1,2]\r\n\r\n  4\r\n / \\\r\n1   2\r\n\r\nOutput: false", "created_at": "2024-09-20T15:08:32.442Z", "updated_at": "2024-12-15T23:16:35.956Z", "owner": 3, "tags": [42, 41, 43, 52, 40]}}, {"model": "python_problems.problem", "pk": 81, "fields": {"title": "Lowest Common Ancestor of a Binary Search Tree", "slug": "lowest-common-ancestor-of-a-binary-search-tree", "difficulty": 2, "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/", "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\r\n\r\nAccording to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\r\n\r\nExample 1:\r\n\r\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\r\n\r\n    ______6__\r\n   /         \\\r\n  2__         8\r\n /   \\       / \\\r\n0     4     7   9\r\n     / \\\r\n    3   5\r\n\r\nOutput: 6\r\nExplanation: The LCA of nodes 2 and 8 is 6.\r\n\r\nExample 2:\r\n\r\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\r\n\r\n    ______6__\r\n   /         \\\r\n  2__         8\r\n /   \\       / \\\r\n0     4     7   9\r\n     / \\\r\n    3   5\r\n\r\nOutput: 2\r\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\r\n\r\nExample 3:\r\n\r\nInput: root = [2,1], p = 2, q = 1\r\n\r\n  2\r\n /\r\n1\r\n\r\nOutput: 2", "created_at": "2024-09-21T18:48:40.196Z", "updated_at": "2024-09-21T18:48:40.215Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 82, "fields": {"title": "Binary Tree Level Order Traversal", "slug": "binary-tree-level-order-traversal", "difficulty": 2, "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/description/", "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\r\n\r\nExample 1:\r\n\r\nInput: root = [3,9,20,null,null,15,7]\r\n\r\n  3___\r\n /    \\\r\n9     _20\r\n     /   \\\r\n    15    7\r\n\r\nOutput: [[3],[9,20],[15,7]]\r\nExample 2:\r\n\r\nInput: root = [1]\r\nOutput: [[1]]\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: []", "created_at": "2024-09-21T21:30:57.271Z", "updated_at": "2024-09-21T21:30:57.291Z", "owner": 3, "tags": [42, 27, 40]}}, {"model": "python_problems.problem", "pk": 83, "fields": {"title": "Binary Tree Right Side View", "slug": "binary-tree-right-side-view", "difficulty": 2, "url": "https://leetcode.com/problems/binary-tree-right-side-view/description/", "description": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\r\n\r\nExample 1:\r\n\r\nInput: root = [1,2,3,null,5,null,4]\r\n\r\n  __1\r\n /   \\\r\n2     3\r\n \\     \\\r\n  5     4\r\n\r\nOutput: [1,3,4]\r\n\r\nExample 2:\r\n\r\nInput: root = [1,null,3]\r\n\r\n1\r\n \\\r\n  3\r\n\r\nOutput: [1,3]\r\n\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: []", "created_at": "2024-09-22T11:52:01.002Z", "updated_at": "2024-09-22T11:52:01.023Z", "owner": 3, "tags": [5, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 84, "fields": {"title": "Count Good Nodes in Binary Tree", "slug": "count-good-nodes-in-binary-tree", "difficulty": 2, "url": "https://leetcode.com/problems/count-good-nodes-in-binary-tree/description/", "description": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\r\n\r\nReturn the number of good nodes in the binary tree.\r\n\r\nExample 1:\r\n\r\nInput: root = [3,1,4,3,null,1,5]\r\n\r\n    3__\r\n   /   \\\r\n  1     4\r\n /     / \\\r\n3     1   5\r\n\r\nOutput: 4\r\nExplanation: Nodes in blue are good.\r\nRoot Node (3) is always a good node.\r\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\r\nNode 5 -> (3,4,5) is the maximum value in the path\r\nNode 3 -> (3,1,3) is the maximum value in the path.\r\n\r\nExample 2:\r\n\r\nInput: root = [3,3,null,4,2]\r\n\r\n    __3\r\n   /\r\n  3\r\n / \\\r\n4   2\r\n\r\nOutput: 3\r\nExplanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.\r\n\r\nExample 3:\r\n\r\nInput: root = [1]\r\nOutput: 1\r\nExplanation: Root is considered as good.", "created_at": "2024-09-23T14:31:14.791Z", "updated_at": "2024-09-23T14:31:14.814Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 85, "fields": {"title": "Validate Binary Search Tree", "slug": "validate-binary-search-tree", "difficulty": 2, "url": "https://leetcode.com/problems/validate-binary-search-tree/description/", "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\r\n\r\nA valid BST is defined as follows:\r\n\r\nThe left \r\nsubtree\r\n of a node contains only nodes with keys less than the node's key.\r\nThe right subtree of a node contains only nodes with keys greater than the node's key.\r\nBoth the left and right subtrees must also be binary search trees.\r\n \r\n\r\nExample 1:\r\n\r\nInput: root = [2,1,3]\r\n\r\n  2\r\n / \\\r\n1   3\r\n\r\nOutput: true\r\n\r\nExample 2:\r\n\r\nInput: root = [5,1,4,null,null,3,6]\r\n\r\n  5__\r\n /   \\\r\n1     4\r\n     / \\\r\n    3   6\r\n\r\nOutput: false\r\nExplanation: The root node's value is 5 but its right child's value is 4.", "created_at": "2024-09-24T14:36:44.902Z", "updated_at": "2024-09-24T14:36:44.922Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 86, "fields": {"title": "Kth Smallest Element in a BST", "slug": "kth-smallest-element-in-a-bst", "difficulty": 2, "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/", "description": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\r\n\r\nExample 1:\r\n\r\nInput: root = [3,1,4,null,2], k = 1\r\n\r\n  __3\r\n /   \\\r\n1     4\r\n \\\r\n  2\r\n\r\nOutput: 1\r\n\r\nExample 2:\r\n\r\nInput: root = [5,3,6,2,4,null,null,1], k = 3\r\n\r\n      __5\r\n     /   \\\r\n    3     6\r\n   / \\\r\n  2   4\r\n /\r\n1\r\n\r\nOutput: 3", "created_at": "2024-09-25T11:58:44.338Z", "updated_at": "2024-09-25T11:58:44.360Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 87, "fields": {"title": "Construct Binary Tree from Preorder and Inorder Traversal", "slug": "construct-binary-tree-from-preorder-and-inorder-traversal", "difficulty": 2, "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/", "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\r\n\r\nExample 1:\r\n\r\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\r\nOutput: [3,9,20,null,null,15,7]\r\n\r\n  3___\r\n /    \\\r\n9     _20\r\n     /   \\\r\n    15    7\r\n\r\nExample 2:\r\n\r\nInput: preorder = [-1], inorder = [-1]\r\nOutput: [-1]", "created_at": "2024-09-25T15:09:23.937Z", "updated_at": "2024-09-25T15:09:23.955Z", "owner": 3, "tags": [2, 42, 18, 3, 40]}}, {"model": "python_problems.problem", "pk": 88, "fields": {"title": "Combination Sum III", "slug": "combination-sum-iii", "difficulty": 2, "url": "https://leetcode.com/problems/combination-sum-iii/description/", "description": "Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\r\n\r\nOnly numbers 1 through 9 are used.\r\nEach number is used at most once.\r\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\r\n\r\nExample 1:\r\n\r\nInput: k = 3, n = 7\r\nOutput: [[1,2,4]]\r\nExplanation:\r\n1 + 2 + 4 = 7\r\nThere are no other valid combinations.\r\nExample 2:\r\n\r\nInput: k = 3, n = 9\r\nOutput: [[1,2,6],[1,3,5],[2,3,4]]\r\nExplanation:\r\n1 + 2 + 6 = 9\r\n1 + 3 + 5 = 9\r\n2 + 3 + 4 = 9\r\nThere are no other valid combinations.\r\nExample 3:\r\n\r\nInput: k = 4, n = 1\r\nOutput: []\r\nExplanation: There are no valid combinations.\r\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.", "created_at": "2024-09-27T19:27:20.138Z", "updated_at": "2024-09-27T19:27:20.160Z", "owner": 3, "tags": [2, 36]}}, {"model": "python_problems.problem", "pk": 89, "fields": {"title": "Combination Sum IV", "slug": "combination-sum-iv", "difficulty": 2, "url": "https://leetcode.com/problems/combination-sum-iv/description/", "description": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\r\n\r\nThe test cases are generated so that the answer can fit in a 32-bit integer.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3], target = 4\r\nOutput: 7\r\nExplanation:\r\nThe possible combination ways are:\r\n(1, 1, 1, 1)\r\n(1, 1, 2)\r\n(1, 2, 1)\r\n(1, 3)\r\n(2, 1, 1)\r\n(2, 2)\r\n(3, 1)\r\nNote that different sequences are counted as different combinations.\r\n\r\nExample 2:\r\n\r\nInput: nums = [9], target = 3\r\nOutput: 0", "created_at": "2024-09-28T22:25:20.767Z", "updated_at": "2024-09-28T22:25:20.783Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 90, "fields": {"title": "Number of Islands", "slug": "number-of-islands", "difficulty": 2, "url": "https://leetcode.com/problems/number-of-islands/description/", "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\r\n\r\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\r\n\r\nExample 1:\r\n\r\nInput: grid = [\r\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\r\n]\r\nOutput: 1\r\nExample 2:\r\n\r\nInput: grid = [\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\r\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\r\n]\r\nOutput: 3", "created_at": "2024-09-29T17:31:13.479Z", "updated_at": "2024-09-29T17:31:13.508Z", "owner": 3, "tags": [2, 27, 41, 31, 22]}}, {"model": "python_problems.problem", "pk": 91, "fields": {"title": "Max Area of Island", "slug": "max-area-of-island", "difficulty": 2, "url": "https://leetcode.com/problems/max-area-of-island/description/", "description": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\r\n\r\nThe area of an island is the number of cells with a value 1 in the island.\r\n\r\nReturn the maximum area of an island in grid. If there is no island, return 0.\r\n\r\nExample 1:\r\n\r\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\r\nOutput: 6\r\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\r\nExample 2:\r\n\r\nInput: grid = [[0,0,0,0,0,0,0,0]]\r\nOutput: 0", "created_at": "2024-09-29T19:55:29.355Z", "updated_at": "2024-09-29T19:55:29.372Z", "owner": 3, "tags": [2, 27, 41, 31, 22]}}, {"model": "python_problems.problem", "pk": 92, "fields": {"title": "Clone Graph", "slug": "clone-graph", "difficulty": 2, "url": "https://leetcode.com/problems/clone-graph/description/", "description": "Given a reference of a node in a connected undirected graph.\r\n\r\nReturn a deep copy (clone) of the graph.\r\n\r\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\r\n\r\nclass Node {\r\n    public int val;\r\n    public List<Node> neighbors;\r\n}\r\n\r\nTest case format:\r\n\r\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\r\n\r\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\r\n\r\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\r\n\r\nExample 1:\r\n\r\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\r\nOutput: [[2,4],[1,3],[2,4],[1,3]]\r\nExplanation: There are 4 nodes in the graph.\r\n1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\r\n2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\r\n3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\r\n4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\r\nExample 2:\r\n\r\n\r\nInput: adjList = [[]]\r\nOutput: [[]]\r\nExplanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\r\nExample 3:\r\n\r\nInput: adjList = []\r\nOutput: []\r\nExplanation: This an empty graph, it does not have any nodes.", "created_at": "2024-09-30T15:04:03.225Z", "updated_at": "2024-09-30T15:04:35.043Z", "owner": 3, "tags": [27, 41, 44, 3]}}, {"model": "python_problems.problem", "pk": 93, "fields": {"title": "Islands and Treasure (Walls and Gates)", "slug": "islands-and-treasure", "difficulty": 2, "url": "https://neetcode.io/problems/islands-and-treasure", "description": "You are given a mn mn 2D grid initialized with these three possible values:\r\n-1 - A water cell that can not be traversed.\r\n0 - A treasure chest.\r\nINF - A land cell that can be traversed. We use the integer 2^31 - 1 = 2147483647 to represent INF.\r\nFill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest than the value should remain INF.\r\n\r\nAssume the grid can only be traversed up, down, left, or right.\r\n\r\nExample 1:\r\n\r\nInput: [\r\n  [2147483647,-1,0,2147483647],\r\n  [2147483647,2147483647,2147483647,-1],\r\n  [2147483647,-1,2147483647,-1],\r\n  [0,-1,2147483647,2147483647]\r\n]\r\n\r\nOutput: [\r\n  [3,-1,0,1],\r\n  [2,2,1,-1],\r\n  [1,-1,2,-1],\r\n  [0,-1,3,4]\r\n]\r\nExample 2:\r\n\r\nInput: [\r\n  [0,-1],\r\n  [2147483647,2147483647]\r\n]\r\n\r\nOutput: [\r\n  [0,-1],\r\n  [1,2]\r\n]", "created_at": "2024-10-01T19:41:10.975Z", "updated_at": "2025-01-30T16:40:06.111Z", "owner": 3, "tags": [2, 27, 41, 31]}}, {"model": "python_problems.problem", "pk": 94, "fields": {"title": "Rotting Oranges", "slug": "rotting-oranges", "difficulty": 2, "url": "https://leetcode.com/problems/rotting-oranges/description/", "description": "You are given an m x n grid where each cell can have one of three values:\r\n\r\n0 representing an empty cell,\r\n1 representing a fresh orange, or\r\n2 representing a rotten orange.\r\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\r\n\r\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\r\n\r\nExample 1:\r\n\r\nInput: grid = [[2,1,1],[1,1,0],[0,1,1]]\r\nOutput: 4\r\nExample 2:\r\n\r\nInput: grid = [[2,1,1],[0,1,1],[1,0,1]]\r\nOutput: -1\r\nExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\r\nExample 3:\r\n\r\nInput: grid = [[0,2]]\r\nOutput: 0\r\nExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.", "created_at": "2024-10-02T14:59:55.608Z", "updated_at": "2024-10-02T14:59:55.626Z", "owner": 3, "tags": [2, 27, 31]}}, {"model": "python_problems.problem", "pk": 95, "fields": {"title": "Reverse Linked List", "slug": "reverse-linked-list", "difficulty": 1, "url": "https://leetcode.com/problems/reverse-linked-list/description/", "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.\r\n\r\nExample 1:\r\n\r\nInput: head = [1,2,3,4,5]\r\nOutput: [5,4,3,2,1]\r\n\r\nExample 2:\r\n\r\nInput: head = [1,2]\r\nOutput: [2,1]\r\n\r\nExample 3:\r\n\r\nInput: head = []\r\nOutput: []", "created_at": "2024-11-11T22:40:40.801Z", "updated_at": "2024-11-11T22:40:40.821Z", "owner": 3, "tags": [37, 38]}}, {"model": "python_problems.problem", "pk": 96, "fields": {"title": "Largest Rectangle in Histogram", "slug": "largest-rectangle-in-histogram", "difficulty": 3, "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/description/", "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\r\n\r\nExample 1:\r\n\r\nInput: heights = [2,1,5,6,2,3]\r\n      _\r\n     _x|\r\n    |xx|\r\n    |xx|  _\r\n _  |xx|_| |\r\n| |_|xx    |\r\n|    xx    |\r\n\r\nOutput: 10\r\nExplanation: The above is a histogram where width of each bar is 1.\r\nThe largest rectangle is shown in the red area, which has an area = 10 units.\r\n\r\nExample 2:\r\n\r\nInput: heights = [2,4]\r\nOutput: 4", "created_at": "2024-11-20T22:27:52.248Z", "updated_at": "2024-11-20T22:27:52.268Z", "owner": 3, "tags": [2, 25, 7]}}, {"model": "python_problems.problem", "pk": 97, "fields": {"title": "Concatenation of Array", "slug": "concatenation-of-array", "difficulty": 1, "url": "https://leetcode.com/problems/concatenation-of-array/description/", "description": "Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).\r\n\r\nSpecifically, ans is the concatenation of two nums arrays.\r\n\r\nReturn the array ans.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,1]\r\nOutput: [1,2,1,1,2,1]\r\nExplanation: The array ans is formed as follows:\r\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\r\n- ans = [1,2,1,1,2,1]\r\nExample 2:\r\n\r\nInput: nums = [1,3,2,1]\r\nOutput: [1,3,2,1,1,3,2,1]\r\nExplanation: The array ans is formed as follows:\r\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\r\n- ans = [1,3,2,1,1,3,2,1]", "created_at": "2024-11-21T13:25:23.405Z", "updated_at": "2024-11-21T13:25:23.425Z", "owner": 3, "tags": [2, 45]}}, {"model": "python_problems.problem", "pk": 98, "fields": {"title": "Valid Palindrome II", "slug": "valid-palindrome-ii", "difficulty": 1, "url": "https://leetcode.com/problems/valid-palindrome-ii/description/", "description": "Given a string s, return true if the s can be palindrome after deleting at most one character from it.\r\n\r\nExample 1:\r\n\r\nInput: s = \"aba\"\r\nOutput: true\r\nExample 2:\r\n\r\nInput: s = \"abca\"\r\nOutput: true\r\nExplanation: You could delete the character 'c'.\r\nExample 3:\r\n\r\nInput: s = \"abc\"\r\nOutput: false", "created_at": "2024-11-21T15:38:51.345Z", "updated_at": "2024-11-21T15:38:51.365Z", "owner": 3, "tags": [10, 6, 4]}}, {"model": "python_problems.problem", "pk": 99, "fields": {"title": "Baseball Game", "slug": "baseball-game", "difficulty": 1, "url": "https://leetcode.com/problems/baseball-game/description/", "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\r\n\r\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\r\n\r\nAn integer x.\r\nRecord a new score of x.\r\n'+'.\r\nRecord a new score that is the sum of the previous two scores.\r\n'D'.\r\nRecord a new score that is the double of the previous score.\r\n'C'.\r\nInvalidate the previous score, removing it from the record.\r\nReturn the sum of all the scores on the record after applying all the operations.\r\n\r\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\r\nOutput: 30\r\nExplanation:\r\n\"5\" - Add 5 to the record, record is now [5].\r\n\"2\" - Add 2 to the record, record is now [5, 2].\r\n\"C\" - Invalidate and remove the previous score, record is now [5].\r\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\r\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\r\nThe total sum is 5 + 10 + 15 = 30.\r\nExample 2:\r\n\r\nInput: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\r\nOutput: 27\r\nExplanation:\r\n\"5\" - Add 5 to the record, record is now [5].\r\n\"-2\" - Add -2 to the record, record is now [5, -2].\r\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\r\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\r\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\r\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\r\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\r\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\r\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\r\nExample 3:\r\n\r\nInput: ops = [\"1\",\"C\"]\r\nOutput: 0\r\nExplanation:\r\n\"1\" - Add 1 to the record, record is now [1].\r\n\"C\" - Invalidate and remove the previous score, record is now [].\r\nSince the record is empty, the total sum is 0.", "created_at": "2024-11-21T16:12:44.106Z", "updated_at": "2024-11-21T16:12:44.127Z", "owner": 3, "tags": [2, 45, 7]}}, {"model": "python_problems.problem", "pk": 100, "fields": {"title": "Replace Elements with Greatest Element on Right Side", "slug": "replace-elements-with-greatest-element-on-right-side", "difficulty": 1, "url": "https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/description/", "description": "Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.\r\n\r\nAfter doing so, return the array.\r\n\r\nExample 1:\r\n\r\nInput: arr = [17,18,5,4,6,1]\r\nOutput: [18,6,6,6,1,-1]\r\nExplanation: \r\n- index 0 --> the greatest element to the right of index 0 is index 1 (18).\r\n- index 1 --> the greatest element to the right of index 1 is index 4 (6).\r\n- index 2 --> the greatest element to the right of index 2 is index 4 (6).\r\n- index 3 --> the greatest element to the right of index 3 is index 4 (6).\r\n- index 4 --> the greatest element to the right of index 4 is index 5 (1).\r\n- index 5 --> there are no elements to the right of index 5, so we put -1.\r\nExample 2:\r\n\r\nInput: arr = [400]\r\nOutput: [-1]\r\nExplanation: There are no elements to the right of index 0.", "created_at": "2024-11-23T11:33:50.439Z", "updated_at": "2024-11-23T11:33:50.460Z", "owner": 3, "tags": [2]}}, {"model": "python_problems.problem", "pk": 101, "fields": {"title": "Minimum Difference Between Highest and Lowest of K Scores", "slug": "minimum-difference-between-highest-and-lowest-of-k-scores", "difficulty": 1, "url": "https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/description/", "description": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\r\n\r\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\r\n\r\nReturn the minimum possible difference.\r\n\r\nExample 1:\r\n\r\nInput: nums = [90], k = 1\r\nOutput: 0\r\nExplanation: There is one way to pick score(s) of one student:\r\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\r\nThe minimum possible difference is 0.\r\nExample 2:\r\n\r\nInput: nums = [9,4,1,7], k = 2\r\nOutput: 2\r\nExplanation: There are six ways to pick score(s) of two students:\r\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\r\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\r\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\r\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\r\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\r\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\r\nThe minimum possible difference is 2.", "created_at": "2024-11-23T22:04:33.551Z", "updated_at": "2024-11-23T22:04:33.573Z", "owner": 3, "tags": [2, 24, 17]}}, {"model": "python_problems.problem", "pk": 102, "fields": {"title": "Merge Strings Alternately", "slug": "merge-strings-alternately", "difficulty": 1, "url": "https://leetcode.com/problems/merge-strings-alternately/description/", "description": "You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.\r\n\r\nReturn the merged string.\r\n\r\nExample 1:\r\n\r\nInput: word1 = \"abc\", word2 = \"pqr\"\r\nOutput: \"apbqcr\"\r\nExplanation: The merged string will be merged as so:\r\nword1:  a   b   c\r\nword2:    p   q   r\r\nmerged: a p b q c r\r\nExample 2:\r\n\r\nInput: word1 = \"ab\", word2 = \"pqrs\"\r\nOutput: \"apbqrs\"\r\nExplanation: Notice that as word2 is longer, \"rs\" is appended to the end.\r\nword1:  a   b \r\nword2:    p   q   r   s\r\nmerged: a p b q   r   s\r\nExample 3:\r\n\r\nInput: word1 = \"abcd\", word2 = \"pq\"\r\nOutput: \"apbqcd\"\r\nExplanation: Notice that as word1 is longer, \"cd\" is appended to the end.\r\nword1:  a   b   c   d\r\nword2:    p   q \r\nmerged: a p b q c   d", "created_at": "2024-11-24T00:23:05.371Z", "updated_at": "2024-11-24T00:23:05.391Z", "owner": 3, "tags": [6, 4]}}, {"model": "python_problems.problem", "pk": 103, "fields": {"title": "Implement Stack using Queues", "slug": "implement-stack-using-queues", "difficulty": 1, "url": "https://leetcode.com/problems/implement-stack-using-queues/description/", "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\r\n\r\nImplement the MyStack class:\r\n\r\nvoid push(int x) Pushes element x to the top of the stack.\r\nint pop() Removes the element on the top of the stack and returns it.\r\nint top() Returns the element on the top of the stack.\r\nboolean empty() Returns true if the stack is empty, false otherwise.\r\nNotes:\r\n\r\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.\r\nDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\nOutput\r\n[null, null, null, 2, 2, false]\r\n\r\nExplanation\r\nMyStack myStack = new MyStack();\r\nmyStack.push(1);\r\nmyStack.push(2);\r\nmyStack.top(); // return 2\r\nmyStack.pop(); // return 2\r\nmyStack.empty(); // return False", "created_at": "2024-11-24T01:53:18.383Z", "updated_at": "2024-11-24T01:53:18.397Z", "owner": 3, "tags": [35, 33, 7]}}, {"model": "python_problems.problem", "pk": 104, "fields": {"title": "Is Subsequence", "slug": "is-subsequence", "difficulty": 1, "url": "https://leetcode.com/problems/is-subsequence/description/", "description": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\r\n\r\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\r\n\r\nExample 1:\r\n\r\nInput: s = \"abc\", t = \"ahbgdc\"\r\nOutput: true\r\nExample 2:\r\n\r\nInput: s = \"axc\", t = \"ahbgdc\"\r\nOutput: false", "created_at": "2024-11-25T01:16:58.803Z", "updated_at": "2024-11-25T01:16:58.821Z", "owner": 3, "tags": [14, 6, 4]}}, {"model": "python_problems.problem", "pk": 105, "fields": {"title": "Length of Last Word", "slug": "length-of-last-word", "difficulty": 1, "url": "https://leetcode.com/problems/length-of-last-word/description/", "description": "Given a string s consisting of words and spaces, return the length of the last word in the string.\r\n\r\nA word is a maximal \r\nsubstring\r\n consisting of non-space characters only.\r\n\r\nExample 1:\r\n\r\nInput: s = \"Hello World\"\r\nOutput: 5\r\nExplanation: The last word is \"World\" with length 5.\r\nExample 2:\r\n\r\nInput: s = \"   fly me   to   the moon  \"\r\nOutput: 4\r\nExplanation: The last word is \"moon\" with length 4.\r\nExample 3:\r\n\r\nInput: s = \"luffy is still joyboy\"\r\nOutput: 6\r\nExplanation: The last word is \"joyboy\" with length 6.", "created_at": "2024-11-25T17:05:34.990Z", "updated_at": "2024-11-25T17:05:35.010Z", "owner": 3, "tags": [6]}}, {"model": "python_problems.problem", "pk": 106, "fields": {"title": "Reverse String", "slug": "reverse-string", "difficulty": 1, "url": "https://leetcode.com/problems/reverse-string/description/", "description": "Write a function that reverses a string. The input string is given as an array of characters s.\r\n\r\nYou must do this by modifying the input array in-place with O(1) extra memory.\r\n\r\nExample 1:\r\n\r\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\r\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\r\nExample 2:\r\n\r\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\r\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]", "created_at": "2024-11-25T21:11:00.273Z", "updated_at": "2024-11-25T21:11:00.291Z", "owner": 3, "tags": [6, 4]}}, {"model": "python_problems.problem", "pk": 107, "fields": {"title": "Contains Duplicate II", "slug": "contains-duplicate-ii", "difficulty": 1, "url": "https://leetcode.com/problems/contains-duplicate-ii/description/", "description": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,1], k = 3\r\nOutput: true\r\nExample 2:\r\n\r\nInput: nums = [1,0,1,1], k = 1\r\nOutput: true\r\nExample 3:\r\n\r\nInput: nums = [1,2,3,1,2,3], k = 2\r\nOutput: false", "created_at": "2024-11-25T22:45:17.508Z", "updated_at": "2024-11-25T22:45:17.526Z", "owner": 3, "tags": [2, 3, 24]}}, {"model": "python_problems.problem", "pk": 108, "fields": {"title": "Implement Queue using Stacks", "slug": "implement-queue-using-stacks", "difficulty": 1, "url": "https://leetcode.com/problems/implement-queue-using-stacks/description/", "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\r\n\r\nImplement the MyQueue class:\r\n\r\nvoid push(int x) Pushes element x to the back of the queue.\r\nint pop() Removes the element from the front of the queue and returns it.\r\nint peek() Returns the element at the front of the queue.\r\nboolean empty() Returns true if the queue is empty, false otherwise.\r\nNotes:\r\n\r\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\r\nDepending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\nOutput\r\n[null, null, null, 1, 1, false]\r\n\r\nExplanation\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false", "created_at": "2024-11-26T00:33:36.618Z", "updated_at": "2024-11-26T00:33:36.636Z", "owner": 3, "tags": [35, 33, 7]}}, {"model": "python_problems.problem", "pk": 109, "fields": {"title": "Longest Common Prefix", "slug": "longest-common-prefix", "difficulty": 1, "url": "https://leetcode.com/problems/longest-common-prefix/description/", "description": "Write a function to find the longest common prefix string amongst an array of strings.\r\n\r\nIf there is no common prefix, return an empty string \"\".\r\n\r\nExample 1:\r\n\r\nInput: strs = [\"flower\",\"flow\",\"flight\"]\r\nOutput: \"fl\"\r\nExample 2:\r\n\r\nInput: strs = [\"dog\",\"racecar\",\"car\"]\r\nOutput: \"\"\r\nExplanation: There is no common prefix among the input strings.", "created_at": "2024-11-27T01:18:05.390Z", "updated_at": "2024-11-27T01:18:05.408Z", "owner": 3, "tags": [6, 29]}}, {"model": "python_problems.problem", "pk": 110, "fields": {"title": "Merge Sorted Array", "slug": "merge-sorted-array", "difficulty": 1, "url": "https://leetcode.com/problems/merge-sorted-array/description/", "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\r\n\r\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\r\n\r\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\r\n\r\nExample 1:\r\n\r\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\r\nOutput: [1,2,2,3,5,6]\r\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\r\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\r\nExample 2:\r\n\r\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\r\nOutput: [1]\r\nExplanation: The arrays we are merging are [1] and [].\r\nThe result of the merge is [1].\r\nExample 3:\r\n\r\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\r\nOutput: [1]\r\nExplanation: The arrays we are merging are [] and [1].\r\nThe result of the merge is [1].\r\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.", "created_at": "2024-11-27T16:32:40.516Z", "updated_at": "2024-11-27T16:32:40.535Z", "owner": 3, "tags": [2, 17, 4]}}, {"model": "python_problems.problem", "pk": 111, "fields": {"title": "Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold", "slug": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold", "difficulty": 2, "url": "https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/", "description": "Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.\r\n\r\nExample 1:\r\n\r\nInput: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\r\nOutput: 3\r\nExplanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).\r\nExample 2:\r\n\r\nInput: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\r\nOutput: 6\r\nExplanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.", "created_at": "2024-11-27T23:40:08.250Z", "updated_at": "2024-11-27T23:40:08.267Z", "owner": 3, "tags": [2, 24]}}, {"model": "python_problems.problem", "pk": 112, "fields": {"title": "Make The String Great", "slug": "make-the-string-great", "difficulty": 1, "url": "https://leetcode.com/problems/make-the-string-great/description/", "description": "Given a string s of lower and upper case English letters.\r\n\r\nA good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:\r\n\r\n0 <= i <= s.length - 2\r\ns[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.\r\nTo make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.\r\n\r\nReturn the string after making it good. The answer is guaranteed to be unique under the given constraints.\r\n\r\nNotice that an empty string is also good.\r\n\r\nExample 1:\r\n\r\nInput: s = \"leEeetcode\"\r\nOutput: \"leetcode\"\r\nExplanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\".\r\nExample 2:\r\n\r\nInput: s = \"abBAcC\"\r\nOutput: \"\"\r\nExplanation: We have many possible scenarios, and all lead to the same answer. For example:\r\n\"abBAcC\" --> \"aAcC\" --> \"cC\" --> \"\"\r\n\"abBAcC\" --> \"abBA\" --> \"aA\" --> \"\"\r\nExample 3:\r\n\r\nInput: s = \"s\"\r\nOutput: \"s\"", "created_at": "2024-11-28T17:40:21.276Z", "updated_at": "2024-11-28T17:40:21.300Z", "owner": 3, "tags": [7, 6]}}, {"model": "python_problems.problem", "pk": 113, "fields": {"title": "Search Insert Position", "slug": "search-insert-position", "difficulty": 1, "url": "https://leetcode.com/problems/search-insert-position/description/", "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,3,5,6], target = 5\r\nOutput: 2\r\nExample 2:\r\n\r\nInput: nums = [1,3,5,6], target = 2\r\nOutput: 1\r\nExample 3:\r\n\r\nInput: nums = [1,3,5,6], target = 7\r\nOutput: 4", "created_at": "2024-11-28T21:55:31.106Z", "updated_at": "2024-11-28T21:55:31.124Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 114, "fields": {"title": "Pascal's Triangle", "slug": "pascals-triangle", "difficulty": 1, "url": "https://leetcode.com/problems/pascals-triangle/description/", "description": "Given an integer numRows, return the first numRows of Pascal's triangle.\r\n\r\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\r\n\r\nExample 1:\r\n\r\nInput: numRows = 5\r\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\r\nExample 2:\r\n\r\nInput: numRows = 1\r\nOutput: [[1]]", "created_at": "2024-11-28T23:59:27.641Z", "updated_at": "2024-11-28T23:59:27.659Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 115, "fields": {"title": "Move Zeroes", "slug": "move-zeroes", "difficulty": 1, "url": "https://leetcode.com/problems/move-zeroes/description/", "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\r\n\r\nNote that you must do this in-place without making a copy of the array.\r\n\r\nExample 1:\r\n\r\nInput: nums = [0,1,0,3,12]\r\nOutput: [1,3,12,0,0]\r\nExample 2:\r\n\r\nInput: nums = [0]\r\nOutput: [0]", "created_at": "2024-11-29T01:45:53.996Z", "updated_at": "2024-11-29T01:45:54.014Z", "owner": 3, "tags": [2, 4]}}, {"model": "python_problems.problem", "pk": 116, "fields": {"title": "Frequency of the Most Frequent Element", "slug": "frequency-of-the-most-frequent-element", "difficulty": 2, "url": "https://leetcode.com/problems/frequency-of-the-most-frequent-element/description/", "description": "The frequency of an element is the number of times it occurs in an array.\r\n\r\nYou are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.\r\n\r\nReturn the maximum possible frequency of an element after performing at most k operations.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,4], k = 5\r\nOutput: 3\r\nExplanation: Increment the first element three times and the second element two times to make nums = [4,4,4].\r\n4 has a frequency of 3.\r\nExample 2:\r\n\r\nInput: nums = [1,4,8,13], k = 5\r\nOutput: 2\r\nExplanation: There are multiple optimal solutions:\r\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\r\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\r\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\r\nExample 3:\r\n\r\nInput: nums = [3,9,6], k = 2\r\nOutput: 1", "created_at": "2024-11-29T13:31:49.091Z", "updated_at": "2024-11-29T13:31:49.113Z", "owner": 3, "tags": [2, 5, 10, 32, 24, 17]}}, {"model": "python_problems.problem", "pk": 117, "fields": {"title": "Removing Stars From a String", "slug": "removing-stars-from-a-stringv", "difficulty": 2, "url": "https://leetcode.com/problems/removing-stars-from-a-string/description/", "description": "You are given a string s, which contains stars *.\r\n\r\nIn one operation, you can:\r\n\r\nChoose a star in s.\r\nRemove the closest non-star character to its left, as well as remove the star itself.\r\nReturn the string after all stars have been removed.\r\n\r\nNote:\r\n\r\nThe input will be generated such that the operation is always possible.\r\nIt can be shown that the resulting string will always be unique.\r\n\r\nExample 1:\r\n\r\nInput: s = \"leet**cod*e\"\r\nOutput: \"lecoe\"\r\nExplanation: Performing the removals from left to right:\r\n- The closest character to the 1st star is 't' in \"leet**cod*e\". s becomes \"lee*cod*e\".\r\n- The closest character to the 2nd star is 'e' in \"lee*cod*e\". s becomes \"lecod*e\".\r\n- The closest character to the 3rd star is 'd' in \"lecod*e\". s becomes \"lecoe\".\r\nThere are no more stars, so we return \"lecoe\".\r\nExample 2:\r\n\r\nInput: s = \"erase*****\"\r\nOutput: \"\"\r\nExplanation: The entire string is removed, so we return an empty string.", "created_at": "2024-11-29T14:50:09.580Z", "updated_at": "2024-11-29T16:20:32.848Z", "owner": 3, "tags": [45, 7, 6]}}, {"model": "python_problems.problem", "pk": 118, "fields": {"title": "Guess Number Higher or Lower", "slug": "guess-number-higher-or-lower", "difficulty": 1, "url": "https://leetcode.com/problems/guess-number-higher-or-lower/description/", "description": "We are playing the Guess Game. The game is as follows:\r\n\r\nI pick a number from 1 to n. You have to guess which number I picked.\r\n\r\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\r\n\r\nYou call a pre-defined API int guess(int num), which returns three possible results:\r\n\r\n-1: Your guess is higher than the number I picked (i.e. num > pick).\r\n1: Your guess is lower than the number I picked (i.e. num < pick).\r\n0: your guess is equal to the number I picked (i.e. num == pick).\r\nReturn the number that I picked.\r\n\r\nExample 1:\r\n\r\nInput: n = 10, pick = 6\r\nOutput: 6\r\nExample 2:\r\n\r\nInput: n = 1, pick = 1\r\nOutput: 1\r\nExample 3:\r\n\r\nInput: n = 2, pick = 1\r\nOutput: 1", "created_at": "2024-11-29T16:22:19.779Z", "updated_at": "2024-11-29T16:22:54.533Z", "owner": 3, "tags": [5, 46]}}, {"model": "python_problems.problem", "pk": 119, "fields": {"title": "Remove Element", "slug": "remove-element", "difficulty": 1, "url": "https://leetcode.com/problems/remove-element/description/", "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\r\n\r\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\r\n\r\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\r\nReturn k.\r\nCustom Judge:\r\n\r\nThe judge will test your solution with the following code:\r\n\r\nint[] nums = [...]; // Input array\r\nint val = ...; // Value to remove\r\nint[] expectedNums = [...]; // The expected answer with correct length.\r\n                            // It is sorted with no values equaling val.\r\n\r\nint k = removeElement(nums, val); // Calls your implementation\r\n\r\nassert k == expectedNums.length;\r\nsort(nums, 0, k); // Sort the first k elements of nums\r\nfor (int i = 0; i < actualLength; i++) {\r\n    assert nums[i] == expectedNums[i];\r\n}\r\nIf all assertions pass, then your solution will be accepted.\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,2,2,3], val = 3\r\nOutput: 2, nums = [2,2,_,_]\r\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\r\nIt does not matter what you leave beyond the returned k (hence they are underscores).\r\nExample 2:\r\n\r\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\r\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\r\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\r\nNote that the five elements can be returned in any order.\r\nIt does not matter what you leave beyond the returned k (hence they are underscores).", "created_at": "2024-11-29T21:49:08.529Z", "updated_at": "2024-11-29T21:49:08.549Z", "owner": 3, "tags": [2, 4]}}, {"model": "python_problems.problem", "pk": 120, "fields": {"title": "Merge Two Sorted Lists", "slug": "merge-two-sorted-lists", "difficulty": 1, "url": "https://leetcode.com/problems/merge-two-sorted-lists/description/", "description": "You are given the heads of two sorted linked lists list1 and list2.\r\n\r\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\r\n\r\nReturn the head of the merged linked list.\r\n\r\nExample 1:\r\n\r\n\r\nInput: list1 = [1,2,4], list2 = [1,3,4]\r\nOutput: [1,1,2,3,4,4]\r\nExample 2:\r\n\r\nInput: list1 = [], list2 = []\r\nOutput: []\r\nExample 3:\r\n\r\nInput: list1 = [], list2 = [0]\r\nOutput: [0]", "created_at": "2024-11-29T23:48:28.661Z", "updated_at": "2024-11-29T23:48:28.680Z", "owner": 3, "tags": [37, 38]}}, {"model": "python_problems.problem", "pk": 121, "fields": {"title": "Linked List Cycle", "slug": "linked-list-cycle", "difficulty": 1, "url": "https://leetcode.com/problems/linked-list-cycle/description/", "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\r\n\r\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\r\n\r\nReturn true if there is a cycle in the linked list. Otherwise, return false.\r\n\r\nExample 1:\r\n\r\nInput: head = [3,2,0,-4], pos = 1\r\nOutput: true\r\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\r\nExample 2:\r\n\r\nInput: head = [1,2], pos = 0\r\nOutput: true\r\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\r\nExample 3:\r\n\r\nInput: head = [1], pos = -1\r\nOutput: false\r\nExplanation: There is no cycle in the linked list.", "created_at": "2024-11-30T00:49:04.708Z", "updated_at": "2024-11-30T00:49:04.732Z", "owner": 3, "tags": [3, 37, 4]}}, {"model": "python_problems.problem", "pk": 122, "fields": {"title": "Palindrome Linked List", "slug": "palindrome-linked-list", "difficulty": 1, "url": "https://leetcode.com/problems/palindrome-linked-list/description/", "description": "Given the head of a singly linked list, return true if it is a \r\npalindrome\r\n or false otherwise.\r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [1,2,2,1]\r\nOutput: true\r\nExample 2:\r\n\r\n\r\nInput: head = [1,2]\r\nOutput: false", "created_at": "2024-11-30T16:15:37.592Z", "updated_at": "2024-11-30T16:15:37.612Z", "owner": 3, "tags": [37, 38, 7, 4]}}, {"model": "python_problems.problem", "pk": 123, "fields": {"title": "Remove Linked List Elements", "slug": "remove-linked-list-elements", "difficulty": 1, "url": "https://leetcode.com/problems/remove-linked-list-elements/description/", "description": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\r\n\r\nExample 1:\r\n\r\nInput: head = [1,2,6,3,4,5,6], val = 6\r\nOutput: [1,2,3,4,5]\r\nExample 2:\r\n\r\nInput: head = [], val = 1\r\nOutput: []\r\nExample 3:\r\n\r\nInput: head = [7,7,7,7], val = 7\r\nOutput: []", "created_at": "2024-12-01T15:01:02.863Z", "updated_at": "2024-12-01T15:01:02.895Z", "owner": 3, "tags": [37, 38]}}, {"model": "python_problems.problem", "pk": 124, "fields": {"title": "Unique Email Addresses", "slug": "unique-email-addresses", "difficulty": 1, "url": "https://leetcode.com/problems/unique-email-addresses/description/", "description": "Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\r\n\r\nFor example, in \"alice@leetcode.com\", \"alice\" is the local name, and \"leetcode.com\" is the domain name.\r\nIf you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\r\n\r\nFor example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\r\nIf you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\r\n\r\nFor example, \"m.y+name@email.com\" will be forwarded to \"my@email.com\".\r\nIt is possible to use both of these rules at the same time.\r\n\r\nGiven an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.\r\n\r\nExample 1:\r\n\r\nInput: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\r\nOutput: 2\r\nExplanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails.\r\nExample 2:\r\n\r\nInput: emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\r\nOutput: 3", "created_at": "2024-12-01T23:36:26.410Z", "updated_at": "2024-12-01T23:36:26.431Z", "owner": 3, "tags": [2, 3, 6]}}, {"model": "python_problems.problem", "pk": 125, "fields": {"title": "Remove Duplicates from Sorted Array", "slug": "remove-duplicates-from-sorted-array", "difficulty": 1, "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/", "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\r\n\r\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\r\n\r\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\r\nReturn k.\r\nCustom Judge:\r\n\r\nThe judge will test your solution with the following code:\r\n\r\nint[] nums = [...]; // Input array\r\nint[] expectedNums = [...]; // The expected answer with correct length\r\n\r\nint k = removeDuplicates(nums); // Calls your implementation\r\n\r\nassert k == expectedNums.length;\r\nfor (int i = 0; i < k; i++) {\r\n    assert nums[i] == expectedNums[i];\r\n}\r\nIf all assertions pass, then your solution will be accepted.\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,2]\r\nOutput: 2, nums = [1,2,_]\r\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\r\nIt does not matter what you leave beyond the returned k (hence they are underscores).\r\nExample 2:\r\n\r\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\r\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\r\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\r\nIt does not matter what you leave beyond the returned k (hence they are underscores).", "created_at": "2024-12-02T00:09:56.508Z", "updated_at": "2024-12-02T00:09:56.526Z", "owner": 3, "tags": [2, 4]}}, {"model": "python_problems.problem", "pk": 126, "fields": {"title": "Fruit Into Baskets", "slug": "fruit-into-baskets", "difficulty": 2, "url": "https://leetcode.com/problems/fruit-into-baskets/description/", "description": "You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.\r\n\r\nYou want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\r\n\r\nYou only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.\r\nStarting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\r\nOnce you reach a tree with fruit that cannot fit in your baskets, you must stop.\r\nGiven the integer array fruits, return the maximum number of fruits you can pick.\r\n\r\nExample 1:\r\n\r\nInput: fruits = [1,2,1]\r\nOutput: 3\r\nExplanation: We can pick from all 3 trees.\r\nExample 2:\r\n\r\nInput: fruits = [0,1,2,2]\r\nOutput: 3\r\nExplanation: We can pick from trees [1,2,2].\r\nIf we had started at the first tree, we would only pick from trees [0,1].\r\nExample 3:\r\n\r\nInput: fruits = [1,2,3,2,2]\r\nOutput: 4\r\nExplanation: We can pick from trees [2,3,2,2].\r\nIf we had started at the first tree, we would only pick from trees [1,2].", "created_at": "2024-12-02T13:18:53.551Z", "updated_at": "2024-12-02T13:19:04.825Z", "owner": 3, "tags": [2, 3, 24]}}, {"model": "python_problems.problem", "pk": 127, "fields": {"title": "Validate Stack Sequences", "slug": "validate-stack-sequences", "difficulty": 2, "url": "https://leetcode.com/problems/validate-stack-sequences/description/", "description": "Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.\r\n\r\nExample 1:\r\n\r\nInput: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\r\nOutput: true\r\nExplanation: We might do the following sequence:\r\npush(1), push(2), push(3), push(4),\r\npop() -> 4,\r\npush(5),\r\npop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\r\nExample 2:\r\n\r\nInput: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\r\nOutput: false\r\nExplanation: 1 cannot be popped before 2.", "created_at": "2024-12-02T14:23:50.469Z", "updated_at": "2024-12-02T14:23:50.487Z", "owner": 3, "tags": [2, 45, 7]}}, {"model": "python_problems.problem", "pk": 128, "fields": {"title": "Arranging Coins", "slug": "arranging-coins", "difficulty": 1, "url": "https://leetcode.com/problems/arranging-coins/description/", "description": "You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\r\n\r\nGiven the integer n, return the number of complete rows of the staircase you will build.\r\n\r\nExample 1:\r\n\r\n\r\nInput: n = 5\r\nOutput: 2\r\nExplanation: Because the 3rd row is incomplete, we return 2.\r\nExample 2:\r\n\r\n\r\nInput: n = 8\r\nOutput: 3\r\nExplanation: Because the 4th row is incomplete, we return 3.", "created_at": "2024-12-02T17:00:49.981Z", "updated_at": "2024-12-02T17:00:50.000Z", "owner": 3, "tags": [5, 8]}}, {"model": "python_problems.problem", "pk": 129, "fields": {"title": "Remove Duplicates from Sorted List", "slug": "remove-duplicates-from-sorted-list", "difficulty": 1, "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/", "description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\r\n\r\nExample 1:\r\n\r\nInput: head = [1,1,2]\r\nOutput: [1,2]\r\nExample 2:\r\n\r\n\r\nInput: head = [1,1,2,3,3]\r\nOutput: [1,2,3]", "created_at": "2024-12-02T21:17:29.306Z", "updated_at": "2024-12-02T21:17:29.324Z", "owner": 3, "tags": [37]}}, {"model": "python_problems.problem", "pk": 130, "fields": {"title": "Isomorphic Strings", "slug": "isomorphic-strings", "difficulty": 1, "url": "https://leetcode.com/problems/isomorphic-strings/description/", "description": "Given two strings s and t, determine if they are isomorphic.\r\n\r\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\r\n\r\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\r\n\r\nExample 1:\r\n\r\nInput: s = \"egg\", t = \"add\"\r\n\r\nOutput: true\r\n\r\nExplanation:\r\n\r\nThe strings s and t can be made identical by:\r\n\r\nMapping 'e' to 'a'.\r\nMapping 'g' to 'd'.\r\nExample 2:\r\n\r\nInput: s = \"foo\", t = \"bar\"\r\n\r\nOutput: false\r\n\r\nExplanation:\r\n\r\nThe strings s and t can not be made identical as 'o' needs to be mapped to both 'a' and 'r'.\r\n\r\nExample 3:\r\n\r\nInput: s = \"paper\", t = \"title\"\r\n\r\nOutput: true", "created_at": "2024-12-02T22:37:20.061Z", "updated_at": "2024-12-02T22:37:20.080Z", "owner": 3, "tags": [3, 6]}}, {"model": "python_problems.problem", "pk": 131, "fields": {"title": "Assign Cookies", "slug": "assign-cookies", "difficulty": 1, "url": "https://leetcode.com/problems/assign-cookies/description/", "description": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\r\n\r\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\r\n\r\nExample 1:\r\n\r\nInput: g = [1,2,3], s = [1,1]\r\nOutput: 1\r\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \r\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\r\nYou need to output 1.\r\nExample 2:\r\n\r\nInput: g = [1,2], s = [1,2,3]\r\nOutput: 2\r\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \r\nYou have 3 cookies and their sizes are big enough to gratify all of the children, \r\nYou need to output 2.", "created_at": "2024-12-04T15:58:14.823Z", "updated_at": "2024-12-04T15:58:14.841Z", "owner": 3, "tags": [2, 10, 17, 4]}}, {"model": "python_problems.problem", "pk": 132, "fields": {"title": "Maximum Number of Vowels in a Substring of Given Length", "slug": "maximum-number-of-vowels-in-a-substring-of-given-length", "difficulty": 2, "url": "https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/", "description": "Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.\r\n\r\nVowel letters in English are 'a', 'e', 'i', 'o', and 'u'.\r\n\r\nExample 1:\r\n\r\nInput: s = \"abciiidef\", k = 3\r\nOutput: 3\r\nExplanation: The substring \"iii\" contains 3 vowel letters.\r\nExample 2:\r\n\r\nInput: s = \"aeiou\", k = 2\r\nOutput: 2\r\nExplanation: Any substring of length 2 contains 2 vowels.\r\nExample 3:\r\n\r\nInput: s = \"leetcode\", k = 3\r\nOutput: 2\r\nExplanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels.", "created_at": "2024-12-04T21:09:00.041Z", "updated_at": "2024-12-04T21:09:00.060Z", "owner": 3, "tags": [24, 6]}}, {"model": "python_problems.problem", "pk": 133, "fields": {"title": "Asteroid Collision", "slug": "asteroid-collision", "difficulty": 2, "url": "https://leetcode.com/problems/asteroid-collision/description/", "description": "We are given an array asteroids of integers representing asteroids in a row.\r\n\r\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\r\n\r\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\r\n\r\nExample 1:\r\n\r\nInput: asteroids = [5,10,-5]\r\nOutput: [5,10]\r\nExplanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\r\nExample 2:\r\n\r\nInput: asteroids = [8,-8]\r\nOutput: []\r\nExplanation: The 8 and -8 collide exploding each other.\r\nExample 3:\r\n\r\nInput: asteroids = [10,2,-5]\r\nOutput: [10]\r\nExplanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.", "created_at": "2024-12-05T15:42:31.163Z", "updated_at": "2024-12-05T15:42:31.182Z", "owner": 3, "tags": [2, 45, 7, 6]}}, {"model": "python_problems.problem", "pk": 134, "fields": {"title": "Squares of a Sorted Array", "slug": "squares-of-a-sorted-array", "difficulty": 1, "url": "https://leetcode.com/problems/squares-of-a-sorted-array/description/", "description": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\r\n\r\nExample 1:\r\n\r\nInput: nums = [-4,-1,0,3,10]\r\nOutput: [0,1,9,16,100]\r\nExplanation: After squaring, the array becomes [16,1,0,9,100].\r\nAfter sorting, it becomes [0,1,9,16,100].\r\nExample 2:\r\n\r\nInput: nums = [-7,-3,2,3,11]\r\nOutput: [4,9,9,49,121]", "created_at": "2024-12-06T00:40:25.965Z", "updated_at": "2024-12-06T00:40:25.986Z", "owner": 3, "tags": [2, 17, 4]}}, {"model": "python_problems.problem", "pk": 135, "fields": {"title": "Middle of the Linked List", "slug": "middle-of-the-linked-list", "difficulty": 1, "url": "https://leetcode.com/problems/middle-of-the-linked-list/description/", "description": "Given the head of a singly linked list, return the middle node of the linked list.\r\n\r\nIf there are two middle nodes, return the second middle node.\r\n\r\nExample 1:\r\n\r\nInput: head = [1,2,3,4,5]\r\nOutput: [3,4,5]\r\nExplanation: The middle node of the list is node 3.\r\nExample 2:\r\n\r\nInput: head = [1,2,3,4,5,6]\r\nOutput: [4,5,6]\r\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.", "created_at": "2024-12-06T01:39:21.428Z", "updated_at": "2024-12-06T01:39:21.448Z", "owner": 3, "tags": [37, 4]}}, {"model": "python_problems.problem", "pk": 136, "fields": {"title": "Can Place Flowers", "slug": "can-place-flowers", "difficulty": 1, "url": "https://leetcode.com/problems/can-place-flowers/description/", "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\r\n\r\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\r\n\r\nExample 1:\r\n\r\nInput: flowerbed = [1,0,0,0,1], n = 1\r\nOutput: true\r\nExample 2:\r\n\r\nInput: flowerbed = [1,0,0,0,1], n = 2\r\nOutput: false", "created_at": "2024-12-06T03:18:05.495Z", "updated_at": "2024-12-06T03:18:05.512Z", "owner": 3, "tags": [2, 10]}}, {"model": "python_problems.problem", "pk": 137, "fields": {"title": "Sort Array By Parity", "slug": "sort-array-by-parity", "difficulty": 1, "url": "https://leetcode.com/problems/sort-array-by-parity/description/", "description": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.\r\n\r\nReturn any array that satisfies this condition.\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,1,2,4]\r\nOutput: [2,4,3,1]\r\nExplanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\r\nExample 2:\r\n\r\nInput: nums = [0]\r\nOutput: [0]", "created_at": "2024-12-06T21:31:48.086Z", "updated_at": "2024-12-06T21:31:48.106Z", "owner": 3, "tags": [2, 17, 4]}}, {"model": "python_problems.problem", "pk": 138, "fields": {"title": "Intersection of Two Linked Lists", "slug": "intersection-of-two-linked-lists", "difficulty": 1, "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/description/", "description": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\r\n\r\nFor example, the following two linked lists begin to intersect at node c1:\r\n\r\n\r\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\r\n\r\nNote that the linked lists must retain their original structure after the function returns.\r\n\r\nExample 1:\r\n\r\n\r\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\r\nOutput: Intersected at '8'\r\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\r\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\r\n- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.\r\nExample 2:\r\n\r\n\r\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\nOutput: Intersected at '2'\r\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\r\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\r\nExample 3:\r\n\r\n\r\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\nOutput: No intersection\r\nExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\r\nExplanation: The two lists do not intersect, so return null.", "created_at": "2024-12-06T23:29:27.501Z", "updated_at": "2024-12-06T23:29:27.539Z", "owner": 3, "tags": [3, 37, 4]}}, {"model": "python_problems.problem", "pk": 139, "fields": {"title": "Reorder List", "slug": "reorder-list", "difficulty": 2, "url": "https://leetcode.com/problems/reorder-list/description/", "description": "You are given the head of a singly linked-list. The list can be represented as:\r\n\r\nL0  L1    Ln - 1  Ln\r\nReorder the list to be on the following form:\r\n\r\nL0  Ln  L1  Ln - 1  L2  Ln - 2  \r\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [1,2,3,4]\r\nOutput: [1,4,2,3]\r\nExample 2:\r\n\r\n\r\nInput: head = [1,2,3,4,5]\r\nOutput: [1,5,2,4,3]", "created_at": "2024-12-07T14:14:26.491Z", "updated_at": "2024-12-07T14:14:26.507Z", "owner": 3, "tags": [37, 38, 7, 4]}}, {"model": "python_problems.problem", "pk": 140, "fields": {"title": "Remove Nth Node From End of List", "slug": "remove-nth-node-from-end-of-list", "difficulty": 2, "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/", "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [1,2,3,4,5], n = 2\r\nOutput: [1,2,3,5]\r\nExample 2:\r\n\r\nInput: head = [1], n = 1\r\nOutput: []\r\nExample 3:\r\n\r\nInput: head = [1,2], n = 1\r\nOutput: [1]", "created_at": "2024-12-07T21:38:29.657Z", "updated_at": "2024-12-07T21:38:29.676Z", "owner": 3, "tags": [37, 4]}}, {"model": "python_problems.problem", "pk": 141, "fields": {"title": "Copy List with Random Pointer", "slug": "copy-list-with-random-pointer", "difficulty": 2, "url": "https://leetcode.com/problems/copy-list-with-random-pointer/description/", "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\r\n\r\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\r\n\r\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\r\n\r\nReturn the head of the copied linked list.\r\n\r\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\r\n\r\nval: an integer representing Node.val\r\nrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\r\nYour code will only be given the head of the original linked list.\r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\r\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\r\nExample 2:\r\n\r\n\r\nInput: head = [[1,1],[2,1]]\r\nOutput: [[1,1],[2,1]]\r\nExample 3:\r\n\r\n\r\n\r\nInput: head = [[3,null],[3,0],[3,null]]\r\nOutput: [[3,null],[3,0],[3,null]]", "created_at": "2024-12-07T22:33:41.982Z", "updated_at": "2024-12-07T22:33:42.002Z", "owner": 3, "tags": [3, 37]}}, {"model": "python_problems.problem", "pk": 142, "fields": {"title": "Add Two Numbers", "slug": "add-two-numbers", "difficulty": 2, "url": "https://leetcode.com/problems/add-two-numbers/description/", "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\r\n\r\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\r\n \r\nExample 1:\r\n\r\nInput: l1 = [2,4,3], l2 = [5,6,4]\r\nOutput: [7,0,8]\r\nExplanation: 342 + 465 = 807.\r\nExample 2:\r\n\r\nInput: l1 = [0], l2 = [0]\r\nOutput: [0]\r\nExample 3:\r\n\r\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\r\nOutput: [8,9,9,9,0,0,0,1]", "created_at": "2024-12-07T23:58:21.184Z", "updated_at": "2024-12-07T23:58:21.202Z", "owner": 3, "tags": [37, 8, 38]}}, {"model": "python_problems.problem", "pk": 143, "fields": {"title": "Majority Element", "slug": "majority-element", "difficulty": 1, "url": "https://leetcode.com/problems/majority-element/description/", "description": "Given an array nums of size n, return the majority element.\r\n\r\nThe majority element is the element that appears more than n / 2 times. You may assume that the majority element always exists in the array.\r\n\r\nExample 1:\r\n\r\nInput: nums = [3,2,3]\r\nOutput: 3\r\nExample 2:\r\n\r\nInput: nums = [2,2,1,1,1,2,2]\r\nOutput: 2", "created_at": "2024-12-08T03:18:55.276Z", "updated_at": "2024-12-08T03:18:55.293Z", "owner": 3, "tags": [2, 11, 18, 3, 17]}}, {"model": "python_problems.problem", "pk": 144, "fields": {"title": "Minimum Number of Flips to Make the Binary String Alternating", "slug": "minimum-number-of-flips-to-make-the-binary-string-alternating", "difficulty": 2, "url": "https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/description/", "description": "You are given a binary string s. You are allowed to perform two types of operations on the string in any sequence:\r\n\r\nType-1: Remove the character at the start of the string s and append it to the end of the string.\r\nType-2: Pick any character in s and flip its value, i.e., if its value is '0' it becomes '1' and vice-versa.\r\nReturn the minimum number of type-2 operations you need to perform such that s becomes alternating.\r\n\r\nThe string is called alternating if no two adjacent characters are equal.\r\n\r\nFor example, the strings \"010\" and \"1010\" are alternating, while the string \"0100\" is not.\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"111000\"\r\nOutput: 2\r\nExplanation: Use the first operation two times to make s = \"100011\".\r\nThen, use the second operation on the third and sixth elements to make s = \"101010\".\r\nExample 2:\r\n\r\nInput: s = \"010\"\r\nOutput: 0\r\nExplanation: The string is already alternating.\r\nExample 3:\r\n\r\nInput: s = \"1110\"\r\nOutput: 1\r\nExplanation: Use the second operation on the second element to make s = \"1010\".", "created_at": "2024-12-08T23:36:46.765Z", "updated_at": "2024-12-08T23:36:46.784Z", "owner": 3, "tags": [14, 10, 24, 6]}}, {"model": "python_problems.problem", "pk": 145, "fields": {"title": "Online Stock Span", "slug": "online-stock-span", "difficulty": 2, "url": "https://leetcode.com/problems/online-stock-span/description/", "description": "Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.\r\n\r\nThe span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.\r\n\r\nFor example, if the prices of the stock in the last four days is [7,2,1,2] and the price of the stock today is 2, then the span of today is 4 because starting from today, the price of the stock was less than or equal 2 for 4 consecutive days.\r\nAlso, if the prices of the stock in the last four days is [7,34,1,2] and the price of the stock today is 8, then the span of today is 3 because starting from today, the price of the stock was less than or equal 8 for 3 consecutive days.\r\nImplement the StockSpanner class:\r\n\r\nStockSpanner() Initializes the object of the class.\r\nint next(int price) Returns the span of the stock's price given that today's price is price.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"StockSpanner\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\", \"next\"]\r\n[[], [100], [80], [60], [70], [60], [75], [85]]\r\nOutput\r\n[null, 1, 1, 1, 2, 1, 4, 6]\r\n\r\nExplanation\r\nStockSpanner stockSpanner = new StockSpanner();\r\nstockSpanner.next(100); // return 1\r\nstockSpanner.next(80);  // return 1\r\nstockSpanner.next(60);  // return 1\r\nstockSpanner.next(70);  // return 2\r\nstockSpanner.next(60);  // return 1\r\nstockSpanner.next(75);  // return 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price.\r\nstockSpanner.next(85);  // return 6", "created_at": "2024-12-09T19:28:23.922Z", "updated_at": "2024-12-09T19:28:23.945Z", "owner": 3, "tags": [47, 35, 25, 7]}}, {"model": "python_problems.problem", "pk": 146, "fields": {"title": "Valid Perfect Square", "slug": "valid-perfect-square", "difficulty": 1, "url": "https://leetcode.com/problems/valid-perfect-square/description/", "description": "Given a positive integer num, return true if num is a perfect square or false otherwise.\r\n\r\nA perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\r\n\r\nYou must not use any built-in library function, such as sqrt.\r\n\r\nExample 1:\r\n\r\nInput: num = 16\r\nOutput: true\r\nExplanation: We return true because 4 * 4 = 16 and 4 is an integer.\r\nExample 2:\r\n\r\nInput: num = 14\r\nOutput: false\r\nExplanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.", "created_at": "2024-12-09T23:01:20.461Z", "updated_at": "2024-12-09T23:01:20.478Z", "owner": 3, "tags": [5, 8]}}, {"model": "python_problems.problem", "pk": 147, "fields": {"title": "Merge In Between Linked Lists", "slug": "merge-in-between-linked-lists", "difficulty": 2, "url": "https://leetcode.com/problems/merge-in-between-linked-lists/description/", "description": "You are given two linked lists: list1 and list2 of sizes n and m respectively.\r\n\r\nRemove list1's nodes from the ath node to the bth node, and put list2 in their place.\r\n\r\nThe blue edges and nodes in the following figure indicate the result:\r\n\r\nBuild the result list and return its head.\r\n\r\nExample 1:\r\n\r\nInput: list1 = [10,1,13,6,9,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]\r\nOutput: [10,1,13,1000000,1000001,1000002,5]\r\nExplanation: We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.\r\nExample 2:\r\n\r\n\r\nInput: list1 = [0,1,2,3,4,5,6], a = 2, b = 5, list2 = [1000000,1000001,1000002,1000003,1000004]\r\nOutput: [0,1,1000000,1000001,1000002,1000003,1000004,6]\r\nExplanation: The blue edges and nodes in the above figure indicate the result.", "created_at": "2024-12-10T01:17:19.598Z", "updated_at": "2024-12-10T01:17:19.619Z", "owner": 3, "tags": [37]}}, {"model": "python_problems.problem", "pk": 148, "fields": {"title": "Next Greater Element I", "slug": "next-greater-element-i", "difficulty": 1, "url": "https://leetcode.com/problems/next-greater-element-i/description/", "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\r\n\r\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\r\n\r\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\r\n\r\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2]\r\nOutput: [-1,3,-1]\r\nExplanation: The next greater element for each value of nums1 is as follows:\r\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\r\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\r\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\r\nExample 2:\r\n\r\nInput: nums1 = [2,4], nums2 = [1,2,3,4]\r\nOutput: [3,-1]\r\nExplanation: The next greater element for each value of nums1 is as follows:\r\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\r\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.", "created_at": "2024-12-10T21:07:55.420Z", "updated_at": "2024-12-10T21:07:55.440Z", "owner": 3, "tags": [2, 3, 25, 7]}}, {"model": "python_problems.problem", "pk": 149, "fields": {"title": "Minimum Size Subarray Sum", "slug": "minimum-size-subarray-sum", "difficulty": 2, "url": "https://leetcode.com/problems/minimum-size-subarray-sum/description/", "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a \r\nsubarray\r\n whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\r\n\r\nExample 1:\r\n\r\nInput: target = 7, nums = [2,3,1,2,4,3]\r\nOutput: 2\r\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\r\nExample 2:\r\n\r\nInput: target = 4, nums = [1,4,4]\r\nOutput: 1\r\nExample 3:\r\n\r\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\r\nOutput: 0", "created_at": "2024-12-12T16:12:06.397Z", "updated_at": "2024-12-12T16:12:06.429Z", "owner": 3, "tags": [2, 5, 32, 24]}}, {"model": "python_problems.problem", "pk": 150, "fields": {"title": "Backspace String Compare", "slug": "backspace-string-compare", "difficulty": 1, "url": "https://leetcode.com/problems/backspace-string-compare/description/", "description": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\r\n\r\nNote that after backspacing an empty text, the text will continue empty.\r\n\r\nExample 1:\r\n\r\nInput: s = \"ab#c\", t = \"ad#c\"\r\nOutput: true\r\nExplanation: Both s and t become \"ac\".\r\nExample 2:\r\n\r\nInput: s = \"ab##\", t = \"c#d#\"\r\nOutput: true\r\nExplanation: Both s and t become \"\".\r\nExample 3:\r\n\r\nInput: s = \"a#c\", t = \"b\"\r\nOutput: false\r\nExplanation: s becomes \"c\" while t becomes \"b\".", "created_at": "2024-12-12T17:05:28.056Z", "updated_at": "2024-12-12T17:05:28.075Z", "owner": 3, "tags": [45, 7, 6, 4]}}, {"model": "python_problems.problem", "pk": 151, "fields": {"title": "LRU Cache", "slug": "lru-cache", "difficulty": 2, "url": "https://leetcode.com/problems/lru-cache/description/", "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\r\n\r\nImplement the LRUCache class:\r\n\r\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\r\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\r\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\r\nThe functions get and put must each run in O(1) average time complexity.\r\nInput\r\n[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]\r\n[[2],       [1,1],[2,2],[1],  [3,3],[2],  [4,4], [1]  ,[3],  [4]]\r\nExpected\r\n[null,       null,null,  1,    null,-1,    null,  -1,   3,    4]\r\n\r\nYour LRUCache object will be instantiated and called as such:\r\nobj = LRUCache(capacity)\r\nparam_1 = obj.get(key)\r\nobj.put(key,value)", "created_at": "2024-12-13T00:02:17.880Z", "updated_at": "2024-12-13T00:02:17.898Z", "owner": 3, "tags": [35, 48, 3, 37]}}, {"model": "python_problems.problem", "pk": 152, "fields": {"title": "Find Pivot Index", "slug": "find-pivot-index", "difficulty": 1, "url": "https://leetcode.com/problems/find-pivot-index/description/", "description": "Given an array of integers nums, calculate the pivot index of this array.\r\n\r\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\r\n\r\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\r\n\r\nReturn the leftmost pivot index. If no such index exists, return -1.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,7,3,6,5,6]\r\nOutput: 3\r\nExplanation:\r\nThe pivot index is 3.\r\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\r\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\r\nExample 2:\r\n\r\nInput: nums = [1,2,3]\r\nOutput: -1\r\nExplanation:\r\nThere is no index that satisfies the conditions in the problem statement.\r\nExample 3:\r\n\r\nInput: nums = [2,1,-1]\r\nOutput: 0\r\nExplanation:\r\nThe pivot index is 0.\r\nLeft sum = 0 (no elements to the left of index 0)\r\nRight sum = nums[1] + nums[2] = 1 + -1 = 0", "created_at": "2024-12-13T01:29:47.712Z", "updated_at": "2024-12-13T01:29:47.733Z", "owner": 3, "tags": [2, 32]}}, {"model": "python_problems.problem", "pk": 153, "fields": {"title": "Range Sum Query - Immutable", "slug": "range-sum-query-immutable", "difficulty": 1, "url": "https://leetcode.com/problems/range-sum-query-immutable/description/", "description": "Given an integer array nums, handle multiple queries of the following type:\r\n\r\nCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\r\nImplement the NumArray class:\r\n\r\nNumArray(int[] nums) Initializes the object with the integer array nums.\r\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\r\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\r\nOutput\r\n[null, 1, -1, -3]\r\n\r\nExplanation\r\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\r\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\r\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\r\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3", "created_at": "2024-12-16T01:08:58.989Z", "updated_at": "2024-12-16T01:08:59.007Z", "owner": 3, "tags": [2, 35, 32]}}, {"model": "python_problems.problem", "pk": 154, "fields": {"title": "Check If Two String Arrays are Equivalent", "slug": "check-if-two-string-arrays-are-equivalent", "difficulty": 1, "url": "https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/description/", "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\r\n\r\nA string is represented by an array if the array elements concatenated in order forms the string.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\r\nOutput: true\r\nExplanation:\r\nword1 represents string \"ab\" + \"c\" -> \"abc\"\r\nword2 represents string \"a\" + \"bc\" -> \"abc\"\r\nThe strings are the same, so return true.\r\nExample 2:\r\n\r\nInput: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\r\nOutput: false\r\nExample 3:\r\n\r\nInput: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\r\nOutput: true", "created_at": "2024-12-16T23:21:13.640Z", "updated_at": "2024-12-16T23:21:13.664Z", "owner": 3, "tags": [2, 6]}}, {"model": "python_problems.problem", "pk": 155, "fields": {"title": "Minimum Operations to Reduce X to Zero", "slug": "minimum-operations-to-reduce-x-to-zero", "difficulty": 2, "url": "https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/description/", "description": "You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.\r\n\r\nReturn the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return -1.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,4,2,3], x = 5\r\nOutput: 2\r\nExplanation: The optimal solution is to remove the last two elements to reduce x to zero.\r\nExample 2:\r\n\r\nInput: nums = [5,6,7,8,9], x = 4\r\nOutput: -1\r\nExample 3:\r\n\r\nInput: nums = [3,2,20,1,1,3], x = 10\r\nOutput: 5\r\nExplanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.", "created_at": "2024-12-17T20:13:48.289Z", "updated_at": "2024-12-17T20:13:48.311Z", "owner": 3, "tags": [2, 5, 3, 32, 24]}}, {"model": "python_problems.problem", "pk": 156, "fields": {"title": "Simplify Path", "slug": "simplify-path", "difficulty": 2, "url": "https://leetcode.com/problems/simplify-path/description/", "description": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path.\r\n\r\nThe rules of a Unix-style file system are as follows:\r\n\r\nA single period '.' represents the current directory.\r\nA double period '..' represents the previous/parent directory.\r\nMultiple consecutive slashes such as '//' and '///' are treated as a single slash '/'.\r\nAny sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, '...' and '....' are valid directory or file names.\r\nThe simplified canonical path should follow these rules:\r\n\r\nThe path must start with a single slash '/'.\r\nDirectories within the path must be separated by exactly one slash '/'.\r\nThe path must not end with a slash '/', unless it is the root directory.\r\nThe path must not have any single or double periods ('.' and '..') used to denote current or parent directories.\r\nReturn the simplified canonical path.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: path = \"/home/\"\r\n\r\nOutput: \"/home\"\r\n\r\nExplanation:\r\n\r\nThe trailing slash should be removed.\r\n\r\nExample 2:\r\n\r\nInput: path = \"/home//foo/\"\r\n\r\nOutput: \"/home/foo\"\r\n\r\nExplanation:\r\n\r\nMultiple consecutive slashes are replaced by a single one.\r\n\r\nExample 3:\r\n\r\nInput: path = \"/home/user/Documents/../Pictures\"\r\n\r\nOutput: \"/home/user/Pictures\"\r\n\r\nExplanation:\r\n\r\nA double period \"..\" refers to the directory up a level (the parent directory).\r\n\r\nExample 4:\r\n\r\nInput: path = \"/../\"\r\n\r\nOutput: \"/\"\r\n\r\nExplanation:\r\n\r\nGoing one level up from the root directory is not possible.\r\n\r\nExample 5:\r\n\r\nInput: path = \"/.../a/../b/c/../d/./\"\r\n\r\nOutput: \"/.../b/d\"\r\n\r\nExplanation:\r\n\r\n\"...\" is a valid name for a directory in this problem.", "created_at": "2024-12-18T00:37:55.233Z", "updated_at": "2024-12-18T00:37:55.254Z", "owner": 3, "tags": [45, 7, 6]}}, {"model": "python_problems.problem", "pk": 157, "fields": {"title": "Sqrt(x)", "slug": "sqrtx", "difficulty": 1, "url": "https://leetcode.com/problems/sqrtx/description/", "description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\r\n\r\nYou must not use any built-in exponent function or operator.\r\n\r\nFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\r\n \r\n\r\nExample 1:\r\n\r\nInput: x = 4\r\nOutput: 2\r\nExplanation: The square root of 4 is 2, so we return 2.\r\nExample 2:\r\n\r\nInput: x = 8\r\nOutput: 2\r\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.", "created_at": "2024-12-18T01:33:05.388Z", "updated_at": "2024-12-18T01:33:05.408Z", "owner": 3, "tags": [5, 8]}}, {"model": "python_problems.problem", "pk": 158, "fields": {"title": "Find All Numbers Disappeared in an Array", "slug": "find-all-numbers-disappeared-in-an-array", "difficulty": 1, "url": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/", "description": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\r\n\r\nExample 1:\r\n\r\nInput: nums = [4,3,2,7,8,2,3,1]\r\nOutput: [5,6]\r\nExample 2:\r\n\r\nInput: nums = [1,1]\r\nOutput: [2]", "created_at": "2024-12-18T20:30:47.208Z", "updated_at": "2024-12-18T20:30:47.228Z", "owner": 3, "tags": [2, 3]}}, {"model": "python_problems.problem", "pk": 159, "fields": {"title": "Binary Tree Inorder Traversal", "slug": "binary-tree-inorder-traversal", "difficulty": 1, "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/description/", "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.\r\n\r\nExample 1:\r\n\r\nInput: root = [1,null,2,3]\r\n\r\nOutput: [1,3,2]\r\n\r\nExplanation:\r\n1__\r\n   \\\r\n    2\r\n   /\r\n  3\r\n\r\n\r\nExample 2:\r\n\r\nInput: root = [1,2,3,4,5,null,8,null,null,6,7,9]\r\n\r\nOutput: [4,2,6,5,7,1,3,9,8]\r\n\r\nExplanation:\r\n    ______1\r\n   /       \\\r\n  2__       3__\r\n /   \\         \\\r\n4     5         8\r\n     / \\       /\r\n    6   7     9\r\n\r\n\r\nExample 3:\r\n\r\nInput: root = []\r\n\r\nOutput: []\r\n\r\nExample 4:\r\n\r\nInput: root = [1]\r\n\r\nOutput: [1]", "created_at": "2024-12-19T01:54:23.109Z", "updated_at": "2024-12-19T01:54:23.126Z", "owner": 3, "tags": [42, 41, 7, 40]}}, {"model": "python_problems.problem", "pk": 160, "fields": {"title": "Maximum Number of Balloons", "slug": "maximum-number-of-balloons", "difficulty": 1, "url": "https://leetcode.com/problems/maximum-number-of-balloons/", "description": "Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\r\n\r\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\r\n\r\nExample 1:\r\n\r\nInput: text = \"nlaebolko\"\r\nOutput: 1\r\nExample 2:\r\n\r\nInput: text = \"loonbalxballpoon\"\r\nOutput: 2\r\nExample 3:\r\n\r\nInput: text = \"leetcode\"\r\nOutput: 0", "created_at": "2024-12-19T04:04:30.380Z", "updated_at": "2024-12-19T04:04:30.403Z", "owner": 3, "tags": [11, 3, 6]}}, {"model": "python_problems.problem", "pk": 161, "fields": {"title": "Binary Tree Preorder Traversal", "slug": "binary-tree-preorder-traversal", "difficulty": 1, "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/description/", "description": "Given the root of a binary tree, return the preorder traversal of its nodes' values.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: root = [1,null,2,3]\r\n\r\nOutput: [1,2,3]\r\n\r\nExplanation:\r\n1__\r\n   \\\r\n    2\r\n   /\r\n  3\r\n\r\n\r\nExample 2:\r\n\r\nInput: root = [1,2,3,4,5,null,8,null,null,6,7,9]\r\n\r\nOutput: [1,2,4,5,6,7,3,8,9]\r\n\r\nExplanation:\r\n    ______1\r\n   /       \\\r\n  2__       3__\r\n /   \\         \\\r\n4     5         8\r\n     / \\       /\r\n    6   7     9\r\n\r\n\r\nExample 3:\r\n\r\nInput: root = []\r\n\r\nOutput: []\r\n\r\nExample 4:\r\n\r\nInput: root = [1]\r\n\r\nOutput: [1]", "created_at": "2024-12-22T06:13:47.704Z", "updated_at": "2024-12-22T06:13:47.727Z", "owner": 3, "tags": [42, 27, 7, 40]}}, {"model": "python_problems.problem", "pk": 162, "fields": {"title": "Binary Tree Postorder Traversal", "slug": "binary-tree-postorder-traversal", "difficulty": 1, "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/description/", "description": "Given the root of a binary tree, return the postorder traversal of its nodes' values.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: root = [1,null,2,3]\r\n\r\nOutput: [3,2,1]\r\n\r\nExplanation:\r\n1__\r\n   \\\r\n    2\r\n   /\r\n  3\r\n\r\n\r\nExample 2:\r\n\r\nInput: root = [1,2,3,4,5,null,8,null,null,6,7,9]\r\n\r\nOutput: [4,6,7,5,2,9,8,3,1]\r\n\r\nExplanation:\r\n    ______1\r\n   /       \\\r\n  2__       3__\r\n /   \\         \\\r\n4     5         8\r\n     / \\       /\r\n    6   7     9\r\n\r\n\r\nExample 3:\r\n\r\nInput: root = []\r\n\r\nOutput: []\r\n\r\nExample 4:\r\n\r\nInput: root = [1]\r\n\r\nOutput: [1]", "created_at": "2024-12-22T08:38:52.037Z", "updated_at": "2024-12-22T08:38:52.056Z", "owner": 3, "tags": [42, 41, 7, 40]}}, {"model": "python_problems.problem", "pk": 163, "fields": {"title": "Word Pattern", "slug": "word-pattern", "difficulty": 1, "url": "https://leetcode.com/problems/word-pattern/description/", "description": "Given a pattern and a string s, find if s follows the same pattern.\r\n\r\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:\r\n\r\nEach letter in pattern maps to exactly one unique word in s.\r\nEach unique word in s maps to exactly one letter in pattern.\r\nNo two letters map to the same word, and no two words map to the same letter.\r\n \r\n\r\nExample 1:\r\n\r\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\r\n\r\nOutput: true\r\n\r\nExplanation:\r\n\r\nThe bijection can be established as:\r\n\r\n'a' maps to \"dog\".\r\n'b' maps to \"cat\".\r\nExample 2:\r\n\r\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\r\n\r\nOutput: false\r\n\r\nExample 3:\r\n\r\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\r\n\r\nOutput: false", "created_at": "2024-12-22T09:34:02.460Z", "updated_at": "2024-12-22T09:34:02.503Z", "owner": 3, "tags": [3, 6]}}, {"model": "python_problems.problem", "pk": 164, "fields": {"title": "Remove Duplicates from Sorted Array II", "slug": "remove-duplicates-from-sorted-array-ii", "difficulty": 2, "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/", "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\r\n\r\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\r\n\r\nReturn k after placing the final result in the first k slots of nums.\r\n\r\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\r\n\r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,1,2,2,3]\r\nOutput: 5, nums = [1,1,2,2,3,_]\r\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\r\nIt does not matter what you leave beyond the returned k (hence they are underscores).\r\nExample 2:\r\n\r\nInput: nums = [0,0,1,1,1,1,2,3,3]\r\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\r\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\r\nIt does not matter what you leave beyond the returned k (hence they are underscores).", "created_at": "2024-12-22T12:48:22.854Z", "updated_at": "2024-12-22T12:48:22.871Z", "owner": 3, "tags": [2, 4]}}, {"model": "python_problems.problem", "pk": 165, "fields": {"title": "Get Equal Substrings Within Budget", "slug": "get-equal-substrings-within-budget", "difficulty": 2, "url": "https://leetcode.com/problems/get-equal-substrings-within-budget/description/", "description": "You are given two strings s and t of the same length and an integer maxCost.\r\n\r\nYou want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).\r\n\r\nReturn the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"abcd\", t = \"bcdf\", maxCost = 3\r\nOutput: 3\r\nExplanation: \"abc\" of s can change to \"bcd\".\r\nThat costs 3, so the maximum length is 3.\r\nExample 2:\r\n\r\nInput: s = \"abcd\", t = \"cdef\", maxCost = 3\r\nOutput: 1\r\nExplanation: Each character in s costs 2 to change to character in t,  so the maximum length is 1.\r\nExample 3:\r\n\r\nInput: s = \"abcd\", t = \"acde\", maxCost = 0\r\nOutput: 1\r\nExplanation: You cannot make any change, so the maximum length is 1.", "created_at": "2024-12-22T20:30:16.859Z", "updated_at": "2024-12-22T20:30:16.880Z", "owner": 3, "tags": [5, 32, 24, 6]}}, {"model": "python_problems.problem", "pk": 166, "fields": {"title": "Decode String", "slug": "decode-string", "difficulty": 2, "url": "https://leetcode.com/problems/decode-string/description/", "description": "Given an encoded string, return its decoded string.\r\n\r\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n\r\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].\r\n\r\nThe test cases are generated so that the length of the output will never exceed 105.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"3[a]2[bc]\"\r\nOutput: \"aaabcbc\"\r\nExample 2:\r\n\r\nInput: s = \"3[a2[c]]\"\r\nOutput: \"accaccacc\"\r\nExample 3:\r\n\r\nInput: s = \"2[abc]3[cd]ef\"\r\nOutput: \"abcabccdcdcdef\"", "created_at": "2024-12-23T08:07:25.783Z", "updated_at": "2024-12-23T08:07:25.806Z", "owner": 3, "tags": [38, 7, 6]}}, {"model": "python_problems.problem", "pk": 167, "fields": {"title": "Single Element in a Sorted Array", "slug": "single-element-in-a-sorted-array", "difficulty": 2, "url": "https://leetcode.com/problems/single-element-in-a-sorted-array/description/", "description": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.\r\n\r\nReturn the single element that appears only once.\r\n\r\nYour solution must run in O(log n) time and O(1) space.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,2,3,3,4,4,8,8]\r\nOutput: 2\r\nExample 2:\r\n\r\nInput: nums = [3,3,7,7,10,11,11]\r\nOutput: 10", "created_at": "2024-12-24T10:45:42.272Z", "updated_at": "2024-12-24T10:45:42.291Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 168, "fields": {"title": "Remove Nodes From Linked List", "slug": "remove-nodes-from-linked-list", "difficulty": 2, "url": "https://leetcode.com/problems/remove-nodes-from-linked-list/description/", "description": "You are given the head of a linked list.\r\n\r\nRemove every node which has a node with a greater value anywhere to the right side of it.\r\n\r\nReturn the head of the modified linked list.\r\n\r\nExample 1:\r\n\r\nInput: head = [5,2,13,3,8]\r\nOutput: [13,8]\r\nExplanation: The nodes that should be removed are 5, 2 and 3.\r\n- Node 13 is to the right of node 5.\r\n- Node 13 is to the right of node 2.\r\n- Node 8 is to the right of node 3.\r\nExample 2:\r\n\r\nInput: head = [1,1,1,1]\r\nOutput: [1,1,1,1]\r\nExplanation: Every node has value 1, so no nodes are removed.", "created_at": "2024-12-25T08:39:43.920Z", "updated_at": "2024-12-25T08:39:43.940Z", "owner": 3, "tags": [37, 25, 38, 7]}}, {"model": "python_problems.problem", "pk": 169, "fields": {"title": "Convert Sorted Array to Binary Search Tree", "slug": "convert-sorted-array-to-binary-search-tree", "difficulty": 1, "url": "https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/", "description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a \r\nheight-balanced\r\n binary search tree.\r\n\r\nExample 1:\r\n____0\r\n  /     \\\r\n-10      5\r\n   \\      \\\r\n    -3     9\r\n\r\nInput: nums = [-10,-3,0,5,9]\r\n\r\nOutput: [0,-3,9,-10,null,5]\r\nExplanation: [0,-10,5,null,-3,null,9] is also accepted:\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: nums = [1,3]\r\nOutput: [3,1]\r\nExplanation: [1,null,3] and [3,1] are both height-balanced BSTs.", "created_at": "2024-12-25T12:41:58.103Z", "updated_at": "2024-12-25T12:41:58.119Z", "owner": 3, "tags": [2, 50, 42, 18, 40]}}, {"model": "python_problems.problem", "pk": 170, "fields": {"title": "Merge Two Binary Trees", "slug": "merge-two-binary-trees", "difficulty": 1, "url": "https://leetcode.com/problems/merge-two-binary-trees/description/", "description": "You are given two binary trees root1 and root2.\r\n\r\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\r\n\r\nReturn the merged tree.\r\n\r\nNote: The merging process must start from the root nodes of both trees.\r\n\r\n \r\n\r\nExample 1:\r\n    1         __2           __3\r\n   / \\       /   \\         /   \\\r\n  3   2  +  1     3   =   4     5\r\n /           \\     \\     / \\     \\\r\n5             4     7   5   4     7\r\n\r\n\r\n\r\nInput: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\r\nOutput: [3,4,5,5,4,null,7]\r\nExample 2:\r\n\r\nInput: root1 = [1], root2 = [1,2]\r\nOutput: [2,2]", "created_at": "2024-12-26T09:41:06.869Z", "updated_at": "2024-12-26T09:41:06.890Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 171, "fields": {"title": "Design HashSet", "slug": "design-hashset", "difficulty": 1, "url": "https://leetcode.com/problems/design-hashset/description/", "description": "Design a HashSet without using any built-in hash table libraries.\r\n\r\nImplement MyHashSet class:\r\n\r\nvoid add(key) Inserts the value key into the HashSet.\r\nbool contains(key) Returns whether the value key exists in the HashSet or not.\r\nvoid remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\r\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\r\nOutput\r\n[null, null, null, true, false, null, true, null, false]\r\n\r\nExplanation\r\nMyHashSet myHashSet = new MyHashSet();\r\nmyHashSet.add(1);      // set = [1]\r\nmyHashSet.add(2);      // set = [1, 2]\r\nmyHashSet.contains(1); // return True\r\nmyHashSet.contains(3); // return False, (not found)\r\nmyHashSet.add(2);      // set = [1, 2]\r\nmyHashSet.contains(2); // return True\r\nmyHashSet.remove(2);   // set = [1]\r\nmyHashSet.contains(2); // return False, (already removed)", "created_at": "2024-12-26T13:50:03.220Z", "updated_at": "2024-12-26T13:50:03.241Z", "owner": 3, "tags": [2, 35, 43, 3, 37]}}, {"model": "python_problems.problem", "pk": 172, "fields": {"title": "4Sum", "slug": "4sum", "difficulty": 2, "url": "https://leetcode.com/problems/4sum/description/", "description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\r\n\r\n0 <= a, b, c, d < n\r\na, b, c, and d are distinct.\r\nnums[a] + nums[b] + nums[c] + nums[d] == target\r\nYou may return the answer in any order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,0,-1,0,-2,2], target = 0\r\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\r\nExample 2:\r\n\r\nInput: nums = [2,2,2,2,2], target = 8\r\nOutput: [[2,2,2,2]]", "created_at": "2024-12-27T06:43:31.608Z", "updated_at": "2024-12-27T06:43:47.567Z", "owner": 3, "tags": [17, 4]}}, {"model": "python_problems.problem", "pk": 173, "fields": {"title": "Implement Trie (Prefix Tree)", "slug": "implement-trie-prefix-tree", "difficulty": 2, "url": "https://leetcode.com/problems/implement-trie-prefix-tree/description/", "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\r\n\r\nImplement the Trie class:\r\n\r\nTrie() Initializes the trie object.\r\nvoid insert(String word) Inserts the string word into the trie.\r\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\r\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\r\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\r\nOutput\r\n[null, null, true, false, true, null, true]\r\n\r\nExplanation\r\nTrie trie = new Trie();\r\ntrie.insert(\"apple\");\r\ntrie.search(\"apple\");   // return True\r\ntrie.search(\"app\");     // return False\r\ntrie.startsWith(\"app\"); // return True\r\ntrie.insert(\"app\");\r\ntrie.search(\"app\");     // return True", "created_at": "2024-12-27T13:13:51.534Z", "updated_at": "2024-12-27T13:13:51.555Z", "owner": 3, "tags": [35, 3, 6, 29]}}, {"model": "python_problems.problem", "pk": 174, "fields": {"title": "Design HashMap", "slug": "design-hashmap", "difficulty": 1, "url": "https://leetcode.com/problems/design-hashmap/description/", "description": "Design a HashMap without using any built-in hash table libraries.\r\n\r\nImplement the MyHashMap class:\r\n\r\nMyHashMap() initializes the object with an empty map.\r\nvoid put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.\r\nint get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\r\nvoid remove(key) removes the key and its corresponding value if the map contains the mapping for the key.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\r\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\r\nOutput\r\n[null, null, null, 1, -1, null, 1, null, -1]\r\n\r\nExplanation\r\nMyHashMap myHashMap = new MyHashMap();\r\nmyHashMap.put(1, 1); // The map is now [[1,1]]\r\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\r\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\r\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\r\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\r\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\r\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\r\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]", "created_at": "2024-12-30T09:39:19.933Z", "updated_at": "2024-12-30T09:39:19.957Z", "owner": 3, "tags": [2, 35, 43, 3, 37]}}, {"model": "python_problems.problem", "pk": 175, "fields": {"title": "Rotate Array", "slug": "rotate-array", "difficulty": 2, "url": "https://leetcode.com/problems/rotate-array/description/", "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,4,5,6,7], k = 3\r\nOutput: [5,6,7,1,2,3,4]\r\nExplanation:\r\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\r\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\r\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\r\nExample 2:\r\n\r\nInput: nums = [-1,-100,3,99], k = 2\r\nOutput: [3,99,-1,-100]\r\nExplanation: \r\nrotate 1 steps to the right: [99,-1,-100,3]\r\nrotate 2 steps to the right: [3,99,-1,-100]", "created_at": "2025-01-01T09:07:18.973Z", "updated_at": "2025-01-01T09:07:18.993Z", "owner": 3, "tags": [2, 8, 4]}}, {"model": "python_problems.problem", "pk": 176, "fields": {"title": "Binary Subarrays With Sum", "slug": "binary-subarrays-with-sum", "difficulty": 2, "url": "https://leetcode.com/problems/binary-subarrays-with-sum/description/", "description": "Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\r\n\r\nA subarray is a contiguous part of the array.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,0,1,0,1], goal = 2\r\nOutput: 4\r\nExplanation: The 4 subarrays are bolded and underlined below:\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]\r\nExample 2:\r\n\r\nInput: nums = [0,0,0,0,0], goal = 0\r\nOutput: 15", "created_at": "2025-01-01T11:03:25.786Z", "updated_at": "2025-01-01T11:03:25.806Z", "owner": 3, "tags": [2, 3, 32, 24]}}, {"model": "python_problems.problem", "pk": 177, "fields": {"title": "Remove K Digits", "slug": "remove-k-digits", "difficulty": 2, "url": "https://leetcode.com/problems/remove-k-digits/description/", "description": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: num = \"1432219\", k = 3\r\nOutput: \"1219\"\r\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\r\nExample 2:\r\n\r\nInput: num = \"10200\", k = 1\r\nOutput: \"200\"\r\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\r\nExample 3:\r\n\r\nInput: num = \"10\", k = 2\r\nOutput: \"0\"\r\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.", "created_at": "2025-01-01T18:31:58.934Z", "updated_at": "2025-01-01T18:31:58.952Z", "owner": 3, "tags": [10, 25, 7, 6]}}, {"model": "python_problems.problem", "pk": 178, "fields": {"title": "Find Peak Element", "slug": "find-peak-element", "difficulty": 4, "url": "https://leetcode.com/problems/find-peak-element/description/", "description": "A peak element is an element that is strictly greater than its neighbors.\r\n\r\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\r\n\r\nYou may imagine that nums[-1] = nums[n] = -. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\r\n\r\nYou must write an algorithm that runs in O(log n) time.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,1]\r\nOutput: 2\r\nExplanation: 3 is a peak element and your function should return the index number 2.\r\nExample 2:\r\n\r\nInput: nums = [1,2,1,3,5,6,4]\r\nOutput: 5\r\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.", "created_at": "2025-01-02T16:56:29.143Z", "updated_at": "2025-01-02T16:56:29.165Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 179, "fields": {"title": "Maximum Twin Sum of a Linked List", "slug": "maximum-twin-sum-of-a-linked-list", "difficulty": 2, "url": "https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/description/", "description": "In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.\r\n\r\nFor example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.\r\nThe twin sum is defined as the sum of a node and its twin.\r\n\r\nGiven the head of a linked list with even length, return the maximum twin sum of the linked list.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [5,4,2,1]\r\nOutput: 6\r\nExplanation:\r\nNodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.\r\nThere are no other nodes with twins in the linked list.\r\nThus, the maximum twin sum of the linked list is 6. \r\nExample 2:\r\n\r\n\r\nInput: head = [4,2,2,3]\r\nOutput: 7\r\nExplanation:\r\nThe nodes with twins present in this linked list are:\r\n- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.\r\n- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.\r\nThus, the maximum twin sum of the linked list is max(7, 4) = 7. \r\nExample 3:\r\n\r\n\r\nInput: head = [1,100000]\r\nOutput: 100001\r\nExplanation:\r\nThere is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.", "created_at": "2025-01-03T00:02:28.264Z", "updated_at": "2025-01-03T00:02:28.283Z", "owner": 3, "tags": [37, 7, 4]}}, {"model": "python_problems.problem", "pk": 180, "fields": {"title": "Path Sum", "slug": "path-sum", "difficulty": 2, "url": "https://leetcode.com/problems/path-sum/description/", "description": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\r\n\r\nA leaf is a node with no children.\r\n\r\n \r\n\r\nExample 1:\r\n         5___\r\n        /    \\\r\n    ___4     _8\r\n   /        /  \\\r\n  11       13   4\r\n /  \\            \\\r\n7    2            1\r\n\r\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\r\nOutput: true\r\nExplanation: The root-to-leaf path with the target sum is shown.\r\nExample 2:\r\n  1\r\n / \\\r\n2   3\r\n\r\nInput: root = [1,2,3], targetSum = 5\r\nOutput: false\r\nExplanation: There are two root-to-leaf paths in the tree:\r\n(1 --> 2): The sum is 3.\r\n(1 --> 3): The sum is 4.\r\nThere is no root-to-leaf path with sum = 5.\r\nExample 3:\r\n\r\nInput: root = [], targetSum = 0\r\nOutput: false\r\nExplanation: Since the tree is empty, there are no root-to-leaf paths.", "created_at": "2025-01-03T07:42:24.673Z", "updated_at": "2025-01-03T07:42:24.696Z", "owner": 3, "tags": [42, 27, 41, 40]}}, {"model": "python_problems.problem", "pk": 181, "fields": {"title": "Sum of All Subset XOR Totals", "slug": "sum-of-all-subset-xor-totals", "difficulty": 1, "url": "https://leetcode.com/problems/sum-of-all-subset-xor-totals/description/", "description": "The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.\r\n\r\nFor example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.\r\nGiven an array nums, return the sum of all XOR totals for every subset of nums. \r\n\r\nNote: Subsets with the same elements should be counted multiple times.\r\n\r\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,3]\r\nOutput: 6\r\nExplanation: The 4 subsets of [1,3] are:\r\n- The empty subset has an XOR total of 0.\r\n- [1] has an XOR total of 1.\r\n- [3] has an XOR total of 3.\r\n- [1,3] has an XOR total of 1 XOR 3 = 2.\r\n0 + 1 + 3 + 2 = 6\r\nExample 2:\r\n\r\nInput: nums = [5,1,6]\r\nOutput: 28\r\nExplanation: The 8 subsets of [5,1,6] are:\r\n- The empty subset has an XOR total of 0.\r\n- [5] has an XOR total of 5.\r\n- [1] has an XOR total of 1.\r\n- [6] has an XOR total of 6.\r\n- [5,1] has an XOR total of 5 XOR 1 = 4.\r\n- [5,6] has an XOR total of 5 XOR 6 = 3.\r\n- [1,6] has an XOR total of 1 XOR 6 = 7.\r\n- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\r\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\r\nExample 3:\r\n\r\nInput: nums = [3,4,5,6,7,8]\r\nOutput: 480\r\nExplanation: The sum of all XOR totals for every subset is 480.", "created_at": "2025-01-03T12:32:05.905Z", "updated_at": "2025-01-03T12:32:05.929Z", "owner": 3, "tags": [2, 36, 39, 13, 23, 8]}}, {"model": "python_problems.problem", "pk": 182, "fields": {"title": "Combinations", "slug": "combinations", "difficulty": 2, "url": "https://leetcode.com/problems/combinations/description/", "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\r\n\r\nYou may return the answer in any order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: n = 4, k = 2\r\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\r\nExplanation: There are 4 choose 2 = 6 total combinations.\r\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\r\nExample 2:\r\n\r\nInput: n = 1, k = 1\r\nOutput: [[1]]\r\nExplanation: There is 1 choose 1 = 1 total combination.", "created_at": "2025-01-03T14:29:16.410Z", "updated_at": "2025-01-03T14:29:16.428Z", "owner": 3, "tags": [36]}}, {"model": "python_problems.problem", "pk": 183, "fields": {"title": "Monotonic Array", "slug": "monotonic-array", "difficulty": 1, "url": "https://leetcode.com/problems/monotonic-array/description/", "description": "An array is monotonic if it is either monotone increasing or monotone decreasing.\r\n\r\nAn array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].\r\n\r\nGiven an integer array nums, return true if the given array is monotonic, or false otherwise.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,2,3]\r\nOutput: true\r\nExample 2:\r\n\r\nInput: nums = [6,5,4,4]\r\nOutput: true\r\nExample 3:\r\n\r\nInput: nums = [1,3,2]\r\nOutput: false", "created_at": "2025-01-04T14:52:34.372Z", "updated_at": "2025-01-04T14:52:34.391Z", "owner": 3, "tags": [2]}}, {"model": "python_problems.problem", "pk": 184, "fields": {"title": "Number of Good Pairs", "slug": "number-of-good-pairs", "difficulty": 1, "url": "https://leetcode.com/problems/number-of-good-pairs/description/", "description": "Given an array of integers nums, return the number of good pairs.\r\n\r\nA pair (i, j) is called good if nums[i] == nums[j] and i < j.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,1,1,3]\r\nOutput: 4\r\nExplanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\r\nExample 2:\r\n\r\nInput: nums = [1,1,1,1]\r\nOutput: 6\r\nExplanation: Each pair in the array are good.\r\nExample 3:\r\n\r\nInput: nums = [1,2,3]\r\nOutput: 0", "created_at": "2025-01-04T17:59:08.751Z", "updated_at": "2025-01-04T17:59:08.767Z", "owner": 3, "tags": [2, 11, 3, 8]}}, {"model": "python_problems.problem", "pk": 185, "fields": {"title": "Number of Subsequences That Satisfy the Given Sum Condition", "slug": "number-of-subsequences-that-satisfy-the-given-sum-condition", "difficulty": 2, "url": "https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/", "description": "You are given an array of integers nums and an integer target.\r\n\r\nReturn the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [3,5,6,7], target = 9\r\nOutput: 4\r\nExplanation: There are 4 subsequences that satisfy the condition.\r\n[3] -> Min value + max value <= target (3 + 3 <= 9)\r\n[3,5] -> (3 + 5 <= 9)\r\n[3,5,6] -> (3 + 6 <= 9)\r\n[3,6] -> (3 + 6 <= 9)\r\nExample 2:\r\n\r\nInput: nums = [3,3,6,8], target = 10\r\nOutput: 6\r\nExplanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).\r\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]\r\nExample 3:\r\n\r\nInput: nums = [2,3,3,4,6,7], target = 12\r\nOutput: 61\r\nExplanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).\r\nNumber of valid subsequences (63 - 2 = 61).", "created_at": "2025-01-05T08:42:05.272Z", "updated_at": "2025-01-05T08:42:05.294Z", "owner": 3, "tags": [2, 5, 17, 4]}}, {"model": "python_problems.problem", "pk": 186, "fields": {"title": "Subarray Product Less Than K", "slug": "subarray-product-less-than-k", "difficulty": 2, "url": "https://leetcode.com/problems/subarray-product-less-than-k/description/", "description": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [10,5,2,6], k = 100\r\nOutput: 8\r\nExplanation: The 8 subarrays that have product less than 100 are:\r\n[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\r\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\r\nExample 2:\r\n\r\nInput: nums = [1,2,3], k = 0\r\nOutput: 0", "created_at": "2025-01-05T11:44:18.946Z", "updated_at": "2025-01-05T11:44:18.964Z", "owner": 3, "tags": [2, 5, 32, 24]}}, {"model": "python_problems.problem", "pk": 187, "fields": {"title": "Remove All Adjacent Duplicates in String II", "slug": "remove-all-adjacent-duplicates-in-string-ii", "difficulty": 2, "url": "https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/description/", "description": "You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.\r\n\r\nWe repeatedly make k duplicate removals on s until we no longer can.\r\n\r\nReturn the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"abcd\", k = 2\r\nOutput: \"abcd\"\r\nExplanation: There's nothing to delete.\r\nExample 2:\r\n\r\nInput: s = \"deeedbbcccbdaa\", k = 3\r\nOutput: \"aa\"\r\nExplanation: \r\nFirst delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\r\nThen delete \"bbb\", get \"dddaa\"\r\nFinally delete \"ddd\", get \"aa\"\r\nExample 3:\r\n\r\nInput: s = \"pbbcggttciiippooaais\", k = 2\r\nOutput: \"ps\"", "created_at": "2025-01-05T13:28:29.343Z", "updated_at": "2025-01-05T13:28:29.359Z", "owner": 3, "tags": [7, 6]}}, {"model": "python_problems.problem", "pk": 188, "fields": {"title": "Successful Pairs of Spells and Potions", "slug": "successful-pairs-of-spells-and-potions", "difficulty": 2, "url": "https://leetcode.com/problems/successful-pairs-of-spells-and-potions/description/", "description": "You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.\r\n\r\nYou are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.\r\n\r\nReturn an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: spells = [5,1,3], potions = [1,2,3,4,5], success = 7\r\nOutput: [4,0,3]\r\nExplanation:\r\n- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.\r\n- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\r\n- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.\r\nThus, [4,0,3] is returned.\r\nExample 2:\r\n\r\nInput: spells = [3,1,2], potions = [8,5,8], success = 16\r\nOutput: [2,0,2]\r\nExplanation:\r\n- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.\r\n- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \r\n- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. \r\nThus, [2,0,2] is returned.", "created_at": "2025-01-05T15:42:29.350Z", "updated_at": "2025-01-05T15:42:29.371Z", "owner": 3, "tags": [2, 5, 17, 4]}}, {"model": "python_problems.problem", "pk": 189, "fields": {"title": "Swapping Nodes in a Linked List", "slug": "swapping-nodes-in-a-linked-list", "difficulty": 2, "url": "https://leetcode.com/problems/swapping-nodes-in-a-linked-list/description/", "description": "You are given the head of a linked list, and an integer k.\r\n\r\nReturn the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [1,2,3,4,5], k = 2\r\nOutput: [1,4,3,2,5]\r\nExample 2:\r\n\r\nInput: head = [7,9,6,6,7,8,3,0,9,5], k = 5\r\nOutput: [7,9,6,6,8,7,3,0,9,5]", "created_at": "2025-01-06T13:37:12.974Z", "updated_at": "2025-01-06T13:37:13.004Z", "owner": 3, "tags": [37, 4]}}, {"model": "python_problems.problem", "pk": 190, "fields": {"title": "Range Sum of BST", "slug": "range-sum-of-bst", "difficulty": 1, "url": "https://leetcode.com/problems/range-sum-of-bst/description/", "description": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\r\n\r\n \r\n\r\nExample 1:\r\n    __10\r\n   /    \\\r\n  5      15\r\n / \\       \\\r\n3   7       18\r\n\r\nInput: root = [10,5,15,3,7,null,18], low = 7, high = 15\r\nOutput: 32\r\nExplanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.\r\nExample 2:\r\n      ____10___\r\n     /         \\\r\n    5__        _15\r\n   /   \\      /   \\\r\n  3     7    13    18\r\n /     /\r\n1     6\r\n\r\nInput: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\r\nOutput: 23\r\nExplanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.", "created_at": "2025-01-06T15:06:10.613Z", "updated_at": "2025-01-06T15:06:10.635Z", "owner": 3, "tags": [50, 42, 41, 40]}}, {"model": "python_problems.problem", "pk": 191, "fields": {"title": "Permutations II", "slug": "permutations-ii", "difficulty": 2, "url": "https://leetcode.com/problems/permutations-ii/description/", "description": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,1,2]\r\nOutput:\r\n[[1,1,2],\r\n [1,2,1],\r\n [2,1,1]]\r\nExample 2:\r\n\r\nInput: nums = [1,2,3]\r\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]", "created_at": "2025-01-06T19:14:14.181Z", "updated_at": "2025-01-06T19:14:14.202Z", "owner": 3, "tags": [2, 36]}}, {"model": "python_problems.problem", "pk": 192, "fields": {"title": "Pascal's Triangle II", "slug": "pascals-triangle-ii", "difficulty": 1, "url": "https://leetcode.com/problems/pascals-triangle-ii/description/", "description": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\r\n\r\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\r\n\r\n\r\nExample 1:\r\n\r\nInput: rowIndex = 3\r\nOutput: [1,3,3,1]\r\nExample 2:\r\n\r\nInput: rowIndex = 0\r\nOutput: [1]\r\nExample 3:\r\n\r\nInput: rowIndex = 1\r\nOutput: [1,1]", "created_at": "2025-01-07T12:20:29.205Z", "updated_at": "2025-01-07T12:20:29.229Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 193, "fields": {"title": "N-th Tribonacci Number", "slug": "n-th-tribonacci-number", "difficulty": 1, "url": "https://leetcode.com/problems/n-th-tribonacci-number/description/", "description": "The Tribonacci sequence Tn is defined as follows: \r\n\r\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\r\n\r\nGiven n, return the value of Tn.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: n = 4\r\nOutput: 4\r\nExplanation:\r\nT_3 = 0 + 1 + 1 = 2\r\nT_4 = 1 + 1 + 2 = 4\r\nExample 2:\r\n\r\nInput: n = 25\r\nOutput: 1389537", "created_at": "2025-01-07T20:40:56.930Z", "updated_at": "2025-01-07T20:40:56.951Z", "owner": 3, "tags": [14, 8, 26]}}, {"model": "python_problems.problem", "pk": 194, "fields": {"title": "Find Words That Can Be Formed by Characters", "slug": "find-words-that-can-be-formed-by-characters", "difficulty": 1, "url": "https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/description/", "description": "You are given an array of strings words and a string chars.\r\n\r\nA string is good if it can be formed by characters from chars (each character can only be used once).\r\n\r\nReturn the sum of lengths of all good strings in words.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\r\nOutput: 6\r\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\r\nExample 2:\r\n\r\nInput: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\r\nOutput: 10\r\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.", "created_at": "2025-01-09T21:44:34.461Z", "updated_at": "2025-01-09T21:44:34.480Z", "owner": 3, "tags": [2, 11, 3, 6]}}, {"model": "python_problems.problem", "pk": 195, "fields": {"title": "Largest 3-Same-Digit Number in String", "slug": "largest-3-same-digit-number-in-string", "difficulty": 1, "url": "https://leetcode.com/problems/largest-3-same-digit-number-in-string/description/", "description": "You are given a string num representing a large integer. An integer is good if it meets the following conditions:\r\n\r\nIt is a substring of num with length 3.\r\nIt consists of only one unique digit.\r\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\r\n\r\nNote:\r\n\r\nA substring is a contiguous sequence of characters within a string.\r\nThere may be leading zeroes in num or a good integer.\r\n \r\n\r\nExample 1:\r\n\r\nInput: num = \"6777133339\"\r\nOutput: \"777\"\r\nExplanation: There are two distinct good integers: \"777\" and \"333\".\r\n\"777\" is the largest, so we return \"777\".\r\nExample 2:\r\n\r\nInput: num = \"2300019\"\r\nOutput: \"000\"\r\nExplanation: \"000\" is the only good integer.\r\nExample 3:\r\n\r\nInput: num = \"42352338\"\r\nOutput: \"\"\r\nExplanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.", "created_at": "2025-01-09T23:41:09.367Z", "updated_at": "2025-01-09T23:41:09.387Z", "owner": 3, "tags": [6]}}, {"model": "python_problems.problem", "pk": 196, "fields": {"title": "Array With Elements Not Equal to Average of Neighbors", "slug": "array-with-elements-not-equal-to-average-of-neighbors", "difficulty": 1, "url": "https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/description/", "description": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\r\n\r\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\r\n\r\nReturn any rearrangement of nums that meets the requirements.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,4,5]\r\nOutput: [1,2,4,5,3]\r\nExplanation:\r\nWhen i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\r\nWhen i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\r\nWhen i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.\r\nExample 2:\r\n\r\nInput: nums = [6,2,0,9,7]\r\nOutput: [9,7,6,2,0]\r\nExplanation:\r\nWhen i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\r\nWhen i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\r\nWhen i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3.", "created_at": "2025-01-10T11:36:27.018Z", "updated_at": "2025-01-10T11:36:27.043Z", "owner": 3, "tags": [2, 10, 17]}}, {"model": "python_problems.problem", "pk": 197, "fields": {"title": "Length of Longest Subarray With at Most K Frequency", "slug": "length-of-longest-subarray-with-at-most-k-frequency", "difficulty": 2, "url": "https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/description/", "description": "You are given an integer array nums and an integer k.\r\n\r\nThe frequency of an element x is the number of times it occurs in an array.\r\n\r\nAn array is called good if the frequency of each element in this array is less than or equal to k.\r\n\r\nReturn the length of the longest good subarray of nums.\r\n\r\nA subarray is a contiguous non-empty sequence of elements within an array.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,1,2,3,1,2], k = 2\r\nOutput: 6\r\nExplanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.\r\nIt can be shown that there are no good subarrays with length more than 6.\r\nExample 2:\r\n\r\nInput: nums = [1,2,1,2,1,2,1,2], k = 1\r\nOutput: 2\r\nExplanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.\r\nIt can be shown that there are no good subarrays with length more than 2.\r\nExample 3:\r\n\r\nInput: nums = [5,5,5,5,5,5,5], k = 4\r\nOutput: 4\r\nExplanation: The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.\r\nIt can be shown that there are no good subarrays with length more than 4.", "created_at": "2025-01-10T13:55:21.475Z", "updated_at": "2025-01-10T13:55:21.499Z", "owner": 3, "tags": [2, 3, 24]}}, {"model": "python_problems.problem", "pk": 198, "fields": {"title": "Capacity To Ship Packages Within D Days", "slug": "capacity-to-ship-packages-within-d-days", "difficulty": 2, "url": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/submissions/1505021062/", "description": "A conveyor belt has packages that must be shipped from one port to another within days days.\r\n\r\nThe ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\r\n\r\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within days days.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: weights = [1,2,3,4,5,6,7,8,9,10], days = 5\r\nOutput: 15\r\nExplanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\r\n1st day: 1, 2, 3, 4, 5\r\n2nd day: 6, 7\r\n3rd day: 8\r\n4th day: 9\r\n5th day: 10\r\n\r\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.\r\nExample 2:\r\n\r\nInput: weights = [3,2,2,4,1,4], days = 3\r\nOutput: 6\r\nExplanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\r\n1st day: 3, 2\r\n2nd day: 2, 4\r\n3rd day: 1, 4\r\nExample 3:\r\n\r\nInput: weights = [1,2,3,1,1], days = 4\r\nOutput: 3\r\nExplanation:\r\n1st day: 1\r\n2nd day: 2\r\n3rd day: 3\r\n4th day: 1, 1", "created_at": "2025-01-11T12:15:22.827Z", "updated_at": "2025-01-11T12:15:22.847Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 199, "fields": {"title": "Design Linked List", "slug": "design-linked-list", "difficulty": 2, "url": "https://leetcode.com/problems/design-linked-list/description/", "description": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list.\r\nA node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.\r\nIf you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.\r\n\r\nImplement the MyLinkedList class:\r\n\r\nMyLinkedList() Initializes the MyLinkedList object.\r\nint get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.\r\nvoid addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\r\nvoid addAtTail(int val) Append a node of value val as the last element of the linked list.\r\nvoid addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.\r\nvoid deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\r\n[[], [1], [3], [1, 2], [1], [1], [1]]\r\nOutput\r\n[null, null, null, null, 2, null, 3]\r\n\r\nExplanation\r\nMyLinkedList myLinkedList = new MyLinkedList();\r\nmyLinkedList.addAtHead(1);\r\nmyLinkedList.addAtTail(3);\r\nmyLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3\r\nmyLinkedList.get(1);              // return 2\r\nmyLinkedList.deleteAtIndex(1);    // now the linked list is 1->3\r\nmyLinkedList.get(1);              // return 3", "created_at": "2025-01-11T13:22:47.485Z", "updated_at": "2025-01-11T13:22:47.506Z", "owner": 3, "tags": [35, 37]}}, {"model": "python_problems.problem", "pk": 200, "fields": {"title": "Leaf-Similar Trees", "slug": "leaf-similar-trees", "difficulty": 1, "url": "https://leetcode.com/problems/leaf-similar-trees/description/", "description": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.\r\n    ______3__\r\n   /         \\\r\n  5__         1\r\n /   \\       / \\\r\n6     2     9   8\r\n     / \\\r\n    7   4\r\n\r\n\r\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\r\n\r\nTwo binary trees are considered leaf-similar if their leaf value sequence is the same.\r\n\r\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.\r\n\r\n \r\n\r\nExample 1:\r\n    ______3__\r\n   /         \\\r\n  5__         1\r\n /   \\       / \\\r\n6     2     9   8\r\n     / \\\r\n    7   4\r\n\r\n    __3__\r\n   /     \\\r\n  5       1__\r\n / \\     /   \\\r\n6   7   4     2\r\n             / \\\r\n            9   8\r\nInput: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\r\nOutput: true\r\nExample 2:\r\n  1\r\n / \\\r\n2   3\r\n\r\n  1\r\n / \\\r\n3   2\r\nInput: root1 = [1,2,3], root2 = [1,3,2]\r\nOutput: false", "created_at": "2025-01-12T14:51:35.157Z", "updated_at": "2025-01-12T14:51:35.315Z", "owner": 3, "tags": [42, 41, 40]}}, {"model": "python_problems.problem", "pk": 201, "fields": {"title": "Restore IP Addresses", "slug": "restore-ip-addresses", "difficulty": 2, "url": "https://leetcode.com/problems/restore-ip-addresses/description/", "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\r\n\r\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\r\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"25525511135\"\r\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\r\nExample 2:\r\n\r\nInput: s = \"0000\"\r\nOutput: [\"0.0.0.0\"]\r\nExample 3:\r\n\r\nInput: s = \"101023\"\r\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]", "created_at": "2025-01-12T17:58:45.483Z", "updated_at": "2025-01-12T17:58:45.505Z", "owner": 3, "tags": [36, 6]}}, {"model": "python_problems.problem", "pk": 202, "fields": {"title": "Design Add and Search Words Data Structure", "slug": "design-add-and-search-words-data-structure", "difficulty": 2, "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/description/", "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\r\n\r\nImplement the WordDictionary class:\r\n\r\nWordDictionary() Initializes the object.\r\nvoid addWord(word) Adds word to the data structure, it can be matched later.\r\nbool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\r\n \r\n\r\nExample:\r\n\r\nInput\r\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\r\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\r\nOutput\r\n[null,null,null,null,false,true,true,true]\r\n\r\nExplanation\r\nWordDictionary wordDictionary = new WordDictionary();\r\nwordDictionary.addWord(\"bad\");\r\nwordDictionary.addWord(\"dad\");\r\nwordDictionary.addWord(\"mad\");\r\nwordDictionary.search(\"pad\"); // return False\r\nwordDictionary.search(\"bad\"); // return True\r\nwordDictionary.search(\".ad\"); // return True\r\nwordDictionary.search(\"b..\"); // return True", "created_at": "2025-01-12T21:27:34.404Z", "updated_at": "2025-01-12T21:27:34.423Z", "owner": 3, "tags": [41, 35, 6, 29]}}, {"model": "python_problems.problem", "pk": 203, "fields": {"title": "Triangle", "slug": "triangle", "difficulty": 2, "url": "https://leetcode.com/problems/triangle/description/", "description": "Given a triangle array, return the minimum path sum from top to bottom.\r\n\r\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\r\nOutput: 11\r\nExplanation: The triangle looks like:\r\n   2\r\n  3 4\r\n 6 5 7\r\n4 1 8 3\r\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\r\nExample 2:\r\n\r\nInput: triangle = [[-10]]\r\nOutput: -10", "created_at": "2025-01-12T22:23:24.804Z", "updated_at": "2025-01-12T22:23:24.826Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 204, "fields": {"title": "Kth Largest Element in a Stream", "slug": "kth-largest-element-in-a-stream", "difficulty": 1, "url": "https://leetcode.com/problems/kth-largest-element-in-a-stream/description/", "description": "You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.\r\n\r\nYou are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.\r\n\r\nImplement the KthLargest class:\r\n\r\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of test scores nums.\r\nint add(int val) Adds a new test score val to the stream and returns the element representing the kth largest element in the pool of test scores so far.\r\n \r\n\r\nExample 1:\r\n\r\nInput:\r\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\r\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\r\n\r\nOutput: [null, 4, 5, 5, 8, 8]\r\n\r\nExplanation:\r\n\r\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\r\nkthLargest.add(3); // return 4\r\nkthLargest.add(5); // return 5\r\nkthLargest.add(10); // return 5\r\nkthLargest.add(9); // return 8\r\nkthLargest.add(4); // return 8\r\n\r\nExample 2:\r\n\r\nInput:\r\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"]\r\n[[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]\r\n\r\nOutput: [null, 7, 7, 7, 8]\r\n\r\nExplanation:\r\n\r\nKthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]);\r\nkthLargest.add(2); // return 7\r\nkthLargest.add(10); // return 7\r\nkthLargest.add(9); // return 7\r\nkthLargest.add(9); // return 8", "created_at": "2025-01-13T00:18:02.957Z", "updated_at": "2025-01-13T00:19:30.064Z", "owner": 3, "tags": [50, 42, 47, 35, 19, 40]}}, {"model": "python_problems.problem", "pk": 205, "fields": {"title": "Last Stone Weight", "slug": "last-stone-weight", "difficulty": 1, "url": "https://leetcode.com/problems/last-stone-weight/description/", "description": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\r\n\r\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\r\n\r\nIf x == y, both stones are destroyed, and\r\nIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\r\nAt the end of the game, there is at most one stone left.\r\n\r\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: stones = [2,7,4,1,8,1]\r\nOutput: 1\r\nExplanation: \r\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\r\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\r\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\r\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\r\nExample 2:\r\n\r\nInput: stones = [1]\r\nOutput: 1", "created_at": "2025-01-13T17:07:22.259Z", "updated_at": "2025-01-13T17:07:22.279Z", "owner": 3, "tags": [2, 19]}}, {"model": "python_problems.problem", "pk": 206, "fields": {"title": "Sort an Array", "slug": "sort-an-array", "difficulty": 1, "url": "https://leetcode.com/problems/sort-an-array/description/", "description": "Given an array of integers nums, sort the array in ascending order and return it.\r\n\r\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [5,2,3,1]\r\nOutput: [1,2,3,5]\r\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).\r\nExample 2:\r\n\r\nInput: nums = [5,1,1,2,0,0]\r\nOutput: [0,0,1,1,2,5]\r\nExplanation: Note that the values of nums are not necessairly unique.", "created_at": "2025-01-15T14:28:17.154Z", "updated_at": "2025-01-15T14:32:02.898Z", "owner": 3, "tags": [2, 20, 54, 18, 19, 55, 53, 17]}}, {"model": "python_problems.problem", "pk": 207, "fields": {"title": "Sort Colors", "slug": "sort-colors", "difficulty": 1, "url": "https://leetcode.com/problems/sort-colors/description/", "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\r\n\r\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\r\n\r\nYou must solve this problem without using the library's sort function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [2,0,2,1,1,0]\r\nOutput: [0,0,1,1,2,2]\r\nExample 2:\r\n\r\nInput: nums = [2,0,1]\r\nOutput: [0,1,2]", "created_at": "2025-01-15T17:58:01.673Z", "updated_at": "2025-01-15T17:58:01.694Z", "owner": 3, "tags": [2, 17, 4]}}, {"model": "python_problems.problem", "pk": 208, "fields": {"title": "Boats to Save People", "slug": "boats-to-save-people", "difficulty": 2, "url": "https://leetcode.com/problems/boats-to-save-people/description/", "description": "You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.\r\n\r\nReturn the minimum number of boats to carry every given person.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: people = [1,2], limit = 3\r\nOutput: 1\r\nExplanation: 1 boat (1, 2)\r\nExample 2:\r\n\r\nInput: people = [3,2,2,1], limit = 3\r\nOutput: 3\r\nExplanation: 3 boats (1, 2), (2) and (3)\r\nExample 3:\r\n\r\nInput: people = [3,5,3,4], limit = 5\r\nOutput: 4\r\nExplanation: 4 boats (3), (3), (4), (5)", "created_at": "2025-01-15T20:01:58.195Z", "updated_at": "2025-01-15T20:01:58.216Z", "owner": 3, "tags": [2, 10, 17, 4]}}, {"model": "python_problems.problem", "pk": 209, "fields": {"title": "Count Subarrays Where Max Element Appears at Least K Times", "slug": "count-subarrays-where-max-element-appears-at-least-k-times", "difficulty": 2, "url": "https://leetcode.com/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/", "description": "You are given an integer array nums and a positive integer k.\r\n\r\nReturn the number of subarrays where the maximum element of nums appears at least k times in that subarray.\r\n\r\nA subarray is a contiguous sequence of elements within an array.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,3,2,3,3], k = 2\r\nOutput: 6\r\nExplanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].\r\nExample 2:\r\n\r\nInput: nums = [1,4,2,1], k = 3\r\nOutput: 0\r\nExplanation: No subarray contains the element 4 at least 3 times.", "created_at": "2025-01-16T11:41:00.036Z", "updated_at": "2025-01-16T11:41:00.066Z", "owner": 3, "tags": [2, 24]}}, {"model": "python_problems.problem", "pk": 210, "fields": {"title": "132 Pattern", "slug": "132-pattern", "difficulty": 2, "url": "https://leetcode.com/problems/132-pattern/description/", "description": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].\r\n\r\nReturn true if there is a 132 pattern in nums, otherwise, return false.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,3,4]\r\nOutput: false\r\nExplanation: There is no 132 pattern in the sequence.\r\nExample 2:\r\n\r\nInput: nums = [3,1,4,2]\r\nOutput: true\r\nExplanation: There is a 132 pattern in the sequence: [1, 4, 2].\r\nExample 3:\r\n\r\nInput: nums = [-1,3,2,0]\r\nOutput: true\r\nExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].", "created_at": "2025-01-16T18:43:17.097Z", "updated_at": "2025-02-11T20:30:09.683Z", "owner": 3, "tags": [2, 5, 25, 56, 7]}}, {"model": "python_problems.problem", "pk": 211, "fields": {"title": "Design Browser History", "slug": "design-browser-history", "difficulty": 2, "url": "https://leetcode.com/problems/design-browser-history/description/", "description": "You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.\r\n\r\nImplement the BrowserHistory class:\r\n\r\nBrowserHistory(string homepage) Initializes the object with the homepage of the browser.\r\nvoid visit(string url) Visits url from the current page. It clears up all the forward history.\r\nstring back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.\r\nstring forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.\r\n \r\n\r\nExample:\r\n\r\nInput:\r\n[\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"]\r\n[[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]]\r\nOutput:\r\n[null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"]\r\n\r\nExplanation:\r\nBrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\");\r\nbrowserHistory.visit(\"google.com\");       // You are in \"leetcode.com\". Visit \"google.com\"\r\nbrowserHistory.visit(\"facebook.com\");     // You are in \"google.com\". Visit \"facebook.com\"\r\nbrowserHistory.visit(\"youtube.com\");      // You are in \"facebook.com\". Visit \"youtube.com\"\r\nbrowserHistory.back(1);                   // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"\r\nbrowserHistory.back(1);                   // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"\r\nbrowserHistory.forward(1);                // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"\r\nbrowserHistory.visit(\"linkedin.com\");     // You are in \"facebook.com\". Visit \"linkedin.com\"\r\nbrowserHistory.forward(2);                // You are in \"linkedin.com\", you cannot move forward any steps.\r\nbrowserHistory.back(2);                   // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"\r\nbrowserHistory.back(7);                   // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"", "created_at": "2025-01-17T09:44:58.478Z", "updated_at": "2025-01-17T09:44:58.509Z", "owner": 3, "tags": [2, 47, 35, 48, 37, 7]}}, {"model": "python_problems.problem", "pk": 212, "fields": {"title": "Evaluate Boolean Binary Tree", "slug": "evaluate-boolean-binary-tree", "difficulty": 1, "url": "https://leetcode.com/problems/evaluate-boolean-binary-tree/description/", "description": "You are given the root of a full binary tree with the following properties:\r\n\r\nLeaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.\r\nNon-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.\r\nThe evaluation of a node is as follows:\r\n\r\nIf the node is a leaf node, the evaluation is the value of the node, i.e. True or False.\r\nOtherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.\r\nReturn the boolean result of evaluating the root node.\r\n\r\nA full binary tree is a binary tree where each node has either 0 or 2 children.\r\n\r\nA leaf node is a node that has zero children.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n   __And______                                   __And_\r\n  /                         \\                              /                 \\\r\nTrue               __Or_         =>       True            True     =>     True\r\n                      /            \\       \r\n                 False      True    \r\n\r\nInput: root = [2,1,3,null,null,0,1]\r\nOutput: true\r\nExplanation: The above diagram illustrates the evaluation process.\r\nThe AND node evaluates to False AND True = False.\r\nThe OR node evaluates to True OR False = True.\r\nThe root node evaluates to True, so we return true.\r\nExample 2:\r\n\r\nInput: root = [0]\r\nOutput: false\r\nExplanation: The root node is a leaf node and it evaluates to false, so we return false.", "created_at": "2025-01-17T12:32:56.943Z", "updated_at": "2025-01-17T12:32:56.965Z", "owner": 3, "tags": [42, 41, 40]}}, {"model": "python_problems.problem", "pk": 213, "fields": {"title": "K Closest Points to Origin", "slug": "k-closest-points-to-origin", "difficulty": 2, "url": "https://leetcode.com/problems/k-closest-points-to-origin/description/", "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\r\n\r\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., (x1 - x2)2 + (y1 - y2)2).\r\n\r\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: points = [[1,3],[-2,2]], k = 1\r\nOutput: [[-2,2]]\r\nExplanation:\r\nThe distance between (1, 3) and the origin is sqrt(10).\r\nThe distance between (-2, 2) and the origin is sqrt(8).\r\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\r\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\r\nExample 2:\r\n\r\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\r\nOutput: [[3,3],[-2,4]]\r\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.", "created_at": "2025-01-17T13:59:49.292Z", "updated_at": "2025-01-17T14:00:37.934Z", "owner": 3, "tags": [2, 18, 57, 19, 8, 21, 17]}}, {"model": "python_problems.problem", "pk": 214, "fields": {"title": "Matchsticks to Square", "slug": "matchsticks-to-square", "difficulty": 2, "url": "https://leetcode.com/problems/matchsticks-to-square/description/", "description": "You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\r\n\r\nReturn true if you can make this square and false otherwise.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: matchsticks = [1,1,2,2,2]\r\nOutput: true\r\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\r\nExample 2:\r\n\r\nInput: matchsticks = [3,3,3,3,4]\r\nOutput: false\r\nExplanation: You cannot find a way to form a square with all the matchsticks.", "created_at": "2025-01-17T17:35:18.887Z", "updated_at": "2025-01-17T17:36:11.547Z", "owner": 3, "tags": [2, 36, 39, 58, 14]}}, {"model": "python_problems.problem", "pk": 215, "fields": {"title": "Extra Characters in a String", "slug": "extra-characters-in-a-string", "difficulty": 2, "url": "https://leetcode.com/problems/extra-characters-in-a-string/description/", "description": "You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.\r\n\r\nReturn the minimum number of extra characters left over if you break up s optimally.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\r\nOutput: 1\r\nExplanation: We can break s in two substrings: \"leet\" from index 0 to 3 and \"code\" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.\r\n\r\nExample 2:\r\n\r\nInput: s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\r\nOutput: 3\r\nExplanation: We can break s in two substrings: \"hello\" from index 3 to 7 and \"world\" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.", "created_at": "2025-01-18T12:45:17.703Z", "updated_at": "2025-01-18T12:45:17.724Z", "owner": 3, "tags": [2, 14, 3, 6, 29]}}, {"model": "python_problems.problem", "pk": 216, "fields": {"title": "Delete and Earn", "slug": "delete-and-earn", "difficulty": 2, "url": "https://leetcode.com/problems/delete-and-earn/description/", "description": "You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:\r\n\r\nPick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.\r\nReturn the maximum number of points you can earn by applying the above operation some number of times.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [3,4,2]\r\nOutput: 6\r\nExplanation: You can perform the following operations:\r\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].\r\n- Delete 2 to earn 2 points. nums = [].\r\nYou earn a total of 6 points.\r\nExample 2:\r\n\r\nInput: nums = [2,2,3,3,3,4]\r\nOutput: 9\r\nExplanation: You can perform the following operations:\r\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].\r\n- Delete a 3 again to earn 3 points. nums = [3].\r\n- Delete a 3 once more to earn 3 points. nums = [].\r\nYou earn a total of 9 points.", "created_at": "2025-01-19T12:58:12.331Z", "updated_at": "2025-01-19T12:58:12.352Z", "owner": 3, "tags": [2, 14, 3]}}, {"model": "python_problems.problem", "pk": 217, "fields": {"title": "Paint House", "slug": "paint-house", "difficulty": 2, "url": "https://leetcode.com/problems/paint-house/", "description": "There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color, and you need to cost the least. Return the minimum cost.\r\n\r\nThe cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.", "created_at": "2025-01-19T14:45:14.154Z", "updated_at": "2025-01-19T14:45:14.172Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 218, "fields": {"title": "Destination City", "slug": "destination-city", "difficulty": 1, "url": "https://leetcode.com/problems/destination-city/description/", "description": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\r\n\r\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\r\nOutput: \"Sao Paulo\" \r\nExplanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\".\r\nExample 2:\r\n\r\nInput: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\r\nOutput: \"A\"\r\nExplanation: All possible trips are: \r\n\"D\" -> \"B\" -> \"C\" -> \"A\". \r\n\"B\" -> \"C\" -> \"A\". \r\n\"C\" -> \"A\". \r\n\"A\". \r\nClearly the destination city is \"A\".\r\nExample 3:\r\n\r\nInput: paths = [[\"A\",\"Z\"]]\r\nOutput: \"Z\"", "created_at": "2025-01-20T11:14:46.025Z", "updated_at": "2025-01-20T11:14:46.049Z", "owner": 3, "tags": [2, 3, 6]}}, {"model": "python_problems.problem", "pk": 219, "fields": {"title": "Maximum Product Difference Between Two Pairs", "slug": "maximum-product-difference-between-two-pairs", "difficulty": 1, "url": "https://leetcode.com/problems/maximum-product-difference-between-two-pairs/description/", "description": "The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).\r\n\r\nFor example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.\r\nGiven an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.\r\n\r\nReturn the maximum such product difference.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [5,6,2,7,4]\r\nOutput: 34\r\nExplanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\r\nThe product difference is (6 * 7) - (2 * 4) = 34.\r\nExample 2:\r\n\r\nInput: nums = [4,2,5,9,7,4,8]\r\nOutput: 64\r\nExplanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\r\nThe product difference is (9 * 8) - (2 * 4) = 64.", "created_at": "2025-01-20T14:28:10.087Z", "updated_at": "2025-01-20T14:28:10.108Z", "owner": 3, "tags": [2, 17]}}, {"model": "python_problems.problem", "pk": 220, "fields": {"title": "K-th Symbol in Grammar", "slug": "k-th-symbol-in-grammar", "difficulty": 2, "url": "https://leetcode.com/problems/k-th-symbol-in-grammar/description/", "description": "We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.\r\n\r\nFor example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.\r\nGiven two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: n = 1, k = 1\r\nOutput: 0\r\nExplanation: row 1: 0\r\nExample 2:\r\n\r\nInput: n = 2, k = 1\r\nOutput: 0\r\nExplanation: \r\nrow 1: 0\r\nrow 2: 01\r\nExample 3:\r\n\r\nInput: n = 2, k = 2\r\nOutput: 1\r\nExplanation: \r\nrow 1: 0\r\nrow 2: 01", "created_at": "2025-01-20T17:31:09.188Z", "updated_at": "2025-01-20T17:31:09.209Z", "owner": 3, "tags": [39, 8, 38]}}, {"model": "python_problems.problem", "pk": 221, "fields": {"title": "Subarrays with K Different Integers", "slug": "subarrays-with-k-different-integers", "difficulty": 3, "url": "https://leetcode.com/problems/subarrays-with-k-different-integers/description/", "description": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\r\n\r\nA good array is an array where the number of different integers in that array is exactly k.\r\n\r\nFor example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.\r\nA subarray is a contiguous part of an array.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,2,1,2,3], k = 2\r\nOutput: 7\r\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]\r\nExample 2:\r\n\r\nInput: nums = [1,2,1,3,4], k = 3\r\nOutput: 3\r\nExplanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].", "created_at": "2025-01-20T20:22:07.443Z", "updated_at": "2025-01-20T20:22:07.464Z", "owner": 3, "tags": [2, 11, 3, 24]}}, {"model": "python_problems.problem", "pk": 222, "fields": {"title": "Search in Rotated Sorted Array II", "slug": "search-in-rotated-sorted-array-ii", "difficulty": 2, "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/", "description": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\r\n\r\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\r\n\r\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\r\n\r\nYou must decrease the overall operation steps as much as possible.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [2,5,6,0,0,1,2], target = 0\r\nOutput: true\r\nExample 2:\r\n\r\nInput: nums = [2,5,6,0,0,1,2], target = 3\r\nOutput: false", "created_at": "2025-01-21T10:40:47.734Z", "updated_at": "2025-01-21T10:40:47.756Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 223, "fields": {"title": "Construct String from Binary Tree", "slug": "construct-string-from-binary-tree", "difficulty": 2, "url": "https://leetcode.com/problems/construct-string-from-binary-tree/description/", "description": "Given the root node of a binary tree, your task is to create a string representation of the tree following a specific set of formatting rules. The representation should be based on a preorder traversal of the binary tree and must adhere to the following guidelines:\r\n\r\nNode Representation: Each node in the tree should be represented by its integer value.\r\n\r\nParentheses for Children: If a node has at least one child (either left or right), its children should be represented inside parentheses. Specifically:\r\n\r\nIf a node has a left child, the value of the left child should be enclosed in parentheses immediately following the node's value.\r\nIf a node has a right child, the value of the right child should also be enclosed in parentheses. The parentheses for the right child should follow those of the left child.\r\nOmitting Empty Parentheses: Any empty parentheses pairs (i.e., ()) should be omitted from the final string representation of the tree, with one specific exception: when a node has a right child but no left child. In such cases, you must include an empty pair of parentheses to indicate the absence of the left child. This ensures that the one-to-one mapping between the string representation and the original binary tree structure is maintained.\r\n\r\nIn summary, empty parentheses pairs should be omitted when a node has only a left child or no children. However, when a node has a right child but no left child, an empty pair of parentheses must precede the representation of the right child to reflect the tree's structure accurately.\r\n\r\n \r\n\r\nExample 1:\r\n    1\r\n   / \\\r\n  2   3\r\n /\r\n4\r\n\r\nInput: root = [1,2,3,4]\r\nOutput: \"1(2(4))(3)\"\r\nExplanation: Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the empty parenthesis pairs. And it will be \"1(2(4))(3)\".\r\nExample 2:\r\n  __1\r\n /   \\\r\n2     3\r\n \\\r\n  4\r\n\r\nInput: root = [1,2,3,null,4]\r\nOutput: \"1(2()(4))(3)\"\r\nExplanation: Almost the same as the first example, except the () after 2 is necessary to indicate the absence of a left child for 2 and the presence of a right child.", "created_at": "2025-01-21T16:28:47.570Z", "updated_at": "2025-01-21T16:28:47.591Z", "owner": 3, "tags": [42, 41, 6, 40]}}, {"model": "python_problems.problem", "pk": 224, "fields": {"title": "Kth Largest Element in an Array", "slug": "kth-largest-element-in-an-array", "difficulty": 2, "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/description/", "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\r\n\r\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\r\n\r\nCan you solve it without sorting?\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [3,2,1,5,6,4], k = 2\r\nOutput: 5\r\nExample 2:\r\n\r\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\r\nOutput: 4", "created_at": "2025-01-21T19:02:28.985Z", "updated_at": "2025-01-21T19:02:29.004Z", "owner": 3, "tags": [2, 18, 19, 21, 17]}}, {"model": "python_problems.problem", "pk": 225, "fields": {"title": "Splitting a String Into Descending Consecutive Values", "slug": "splitting-a-string-into-descending-consecutive-values", "difficulty": 2, "url": "https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/description/", "description": "You are given a string s that consists of only digits.\r\n\r\nCheck if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order and the difference between numerical values of every two adjacent substrings is equal to 1.\r\n\r\nFor example, the string s = \"0090089\" can be split into [\"0090\", \"089\"] with numerical values [90,89]. The values are in descending order and adjacent values differ by 1, so this way is valid.\r\nAnother example, the string s = \"001\" can be split into [\"0\", \"01\"], [\"00\", \"1\"], or [\"0\", \"0\", \"1\"]. However all the ways are invalid because they have numerical values [0,1], [0,1], and [0,0,1] respectively, all of which are not in descending order.\r\nReturn true if it is possible to split s as described above, or false otherwise.\r\n\r\nA substring is a contiguous sequence of characters in a string.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"1234\"\r\nOutput: false\r\nExplanation: There is no valid way to split s.\r\nExample 2:\r\n\r\nInput: s = \"050043\"\r\nOutput: true\r\nExplanation: s can be split into [\"05\", \"004\", \"3\"] with numerical values [5,4,3].\r\nThe values are in descending order with adjacent values differing by 1.\r\nExample 3:\r\n\r\nInput: s = \"9080701\"\r\nOutput: false\r\nExplanation: There is no valid way to split s.", "created_at": "2025-01-22T07:25:16.919Z", "updated_at": "2025-01-22T07:25:16.942Z", "owner": 3, "tags": [36, 6]}}, {"model": "python_problems.problem", "pk": 226, "fields": {"title": "Island Perimeter", "slug": "island-perimeter", "difficulty": 1, "url": "https://leetcode.com/problems/island-perimeter/description/", "description": "You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\r\n\r\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\r\n\r\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\r\nOutput: 16\r\nExplanation: The perimeter is the 16 yellow stripes in the image above.\r\nExample 2:\r\n\r\nInput: grid = [[1]]\r\nOutput: 4\r\nExample 3:\r\n\r\nInput: grid = [[1,0]]\r\nOutput: 4", "created_at": "2025-01-22T12:24:43.682Z", "updated_at": "2025-01-22T12:24:43.701Z", "owner": 3, "tags": [2, 27, 41, 31]}}, {"model": "python_problems.problem", "pk": 227, "fields": {"title": "Verifying an Alien Dictionary", "slug": "verifying-an-alien-dictionary", "difficulty": 1, "url": "https://leetcode.com/problems/verifying-an-alien-dictionary/description/", "description": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\r\n\r\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\r\nOutput: true\r\nExplanation: As 'h' comes before 'l' in this language, then the sequence is sorted.\r\nExample 2:\r\n\r\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\r\nOutput: false\r\nExplanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.\r\nExample 3:\r\n\r\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\r\nOutput: false\r\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '', where '' is defined as the blank character which is less than any other character (More info).", "created_at": "2025-01-22T21:56:13.915Z", "updated_at": "2025-01-22T21:56:13.935Z", "owner": 3, "tags": [2, 3, 6]}}, {"model": "python_problems.problem", "pk": 228, "fields": {"title": "Find the Town Judge", "slug": "find-the-town-judge", "difficulty": 1, "url": "https://leetcode.com/problems/find-the-town-judge/description/", "description": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\r\n\r\nIf the town judge exists, then:\r\n\r\nThe town judge trusts nobody.\r\nEverybody (except for the town judge) trusts the town judge.\r\nThere is exactly one person that satisfies properties 1 and 2.\r\nYou are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\r\n\r\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: n = 2, trust = [[1,2]]\r\nOutput: 2\r\nExample 2:\r\n\r\nInput: n = 3, trust = [[1,3],[2,3]]\r\nOutput: 3\r\nExample 3:\r\n\r\nInput: n = 3, trust = [[1,3],[2,3],[3,1]]\r\nOutput: -1", "created_at": "2025-01-23T11:55:24.538Z", "updated_at": "2025-01-23T11:55:24.565Z", "owner": 3, "tags": [2, 44, 3]}}, {"model": "python_problems.problem", "pk": 229, "fields": {"title": "Perfect Squares", "slug": "perfect-squares", "difficulty": 2, "url": "https://leetcode.com/problems/perfect-squares/description/", "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\r\n\r\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: n = 12\r\nOutput: 3\r\nExplanation: 12 = 4 + 4 + 4.\r\nExample 2:\r\n\r\nInput: n = 13\r\nOutput: 2\r\nExplanation: 13 = 4 + 9.", "created_at": "2025-01-24T17:10:04.643Z", "updated_at": "2025-01-24T17:10:04.668Z", "owner": 3, "tags": [27, 14, 8]}}, {"model": "python_problems.problem", "pk": 230, "fields": {"title": "Buy Two Chocolates", "slug": "buy-two-chocolates", "difficulty": 1, "url": "https://leetcode.com/problems/buy-two-chocolates/description/", "description": "You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.\r\n\r\nYou must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.\r\n\r\nReturn the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: prices = [1,2,2], money = 3\r\nOutput: 0\r\nExplanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.\r\nExample 2:\r\n\r\nInput: prices = [3,2,3], money = 3\r\nOutput: 3\r\nExplanation: You cannot buy 2 chocolates without going in debt, so we return 3.", "created_at": "2025-01-24T20:25:20.969Z", "updated_at": "2025-01-24T20:25:20.992Z", "owner": 3, "tags": [2, 10, 17]}}, {"model": "python_problems.problem", "pk": 231, "fields": {"title": "Lemonade Change", "slug": "lemonade-change", "difficulty": 1, "url": "https://leetcode.com/problems/lemonade-change/description/", "description": "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.\r\n\r\nNote that you do not have any change in hand at first.\r\n\r\nGiven an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: bills = [5,5,5,10,20]\r\nOutput: true\r\nExplanation: \r\nFrom the first 3 customers, we collect three $5 bills in order.\r\nFrom the fourth customer, we collect a $10 bill and give back a $5.\r\nFrom the fifth customer, we give a $10 bill and a $5 bill.\r\nSince all customers got correct change, we output true.\r\nExample 2:\r\n\r\nInput: bills = [5,5,10,10,20]\r\nOutput: false\r\nExplanation: \r\nFrom the first two customers in order, we collect two $5 bills.\r\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\r\nFor the last customer, we can not give the change of $15 back because we only have two $10 bills.\r\nSince not every customer received the correct change, the answer is false.", "created_at": "2025-01-24T21:09:02.765Z", "updated_at": "2025-01-24T21:09:02.788Z", "owner": 3, "tags": [2, 10]}}, {"model": "python_problems.problem", "pk": 232, "fields": {"title": "Maximum Odd Binary Number", "slug": "maximum-odd-binary-number", "difficulty": 1, "url": "https://leetcode.com/problems/maximum-odd-binary-number/description/", "description": "You are given a binary string s that contains at least one '1'.\r\n\r\nYou have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.\r\n\r\nReturn a string representing the maximum odd binary number that can be created from the given combination.\r\n\r\nNote that the resulting string can have leading zeros.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"010\"\r\nOutput: \"001\"\r\nExplanation: Because there is just one '1', it must be in the last position. So the answer is \"001\".\r\nExample 2:\r\n\r\nInput: s = \"0101\"\r\nOutput: \"1001\"\r\nExplanation: One of the '1's must be in the last position. The maximum number that can be made with the remaining digits is \"100\". So the answer is \"1001\".", "created_at": "2025-01-24T21:43:01.184Z", "updated_at": "2025-01-24T21:43:01.204Z", "owner": 3, "tags": [10, 8, 6]}}, {"model": "python_problems.problem", "pk": 233, "fields": {"title": "Maximum Nesting Depth of the Parentheses", "slug": "maximum-nesting-depth-of-the-parentheses", "difficulty": 1, "url": "https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/", "description": "Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"(1+(2*3)+((8)/4))+1\"\r\n\r\nOutput: 3\r\n\r\nExplanation:\r\n\r\nDigit 8 is inside of 3 nested parentheses in the string.\r\n\r\nExample 2:\r\n\r\nInput: s = \"(1)+((2))+(((3)))\"\r\n\r\nOutput: 3\r\n\r\nExplanation:\r\n\r\nDigit 3 is inside of 3 nested parentheses in the string.\r\n\r\nExample 3:\r\n\r\nInput: s = \"()(())((()()))\"\r\n\r\nOutput: 3", "created_at": "2025-01-24T22:50:07.374Z", "updated_at": "2025-01-24T22:50:07.391Z", "owner": 3, "tags": [7, 6]}}, {"model": "python_problems.problem", "pk": 234, "fields": {"title": "Maximum Score After Splitting a String", "slug": "maximum-score-after-splitting-a-string", "difficulty": 1, "url": "https://leetcode.com/problems/maximum-score-after-splitting-a-string/description/", "description": "Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).\r\n\r\nThe score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"011101\"\r\nOutput: 5 \r\nExplanation: \r\nAll possible ways of splitting s into two non-empty substrings are:\r\nleft = \"0\" and right = \"11101\", score = 1 + 4 = 5 \r\nleft = \"01\" and right = \"1101\", score = 1 + 3 = 4 \r\nleft = \"011\" and right = \"101\", score = 1 + 2 = 3 \r\nleft = \"0111\" and right = \"01\", score = 1 + 1 = 2 \r\nleft = \"01110\" and right = \"1\", score = 2 + 1 = 3\r\nExample 2:\r\n\r\nInput: s = \"00111\"\r\nOutput: 5\r\nExplanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5\r\nExample 3:\r\n\r\nInput: s = \"1111\"\r\nOutput: 3", "created_at": "2025-01-25T01:17:44.114Z", "updated_at": "2025-01-25T01:17:44.136Z", "owner": 3, "tags": [32, 6]}}, {"model": "python_problems.problem", "pk": 235, "fields": {"title": "Path Crossing", "slug": "path-crossing", "difficulty": 1, "url": "https://leetcode.com/problems/path-crossing/description/", "description": "Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.\r\n\r\nReturn true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: path = \"NES\"\r\nOutput: false \r\nExplanation: Notice that the path doesn't cross any point more than once.\r\nExample 2:\r\n\r\n\r\nInput: path = \"NESWW\"\r\nOutput: true\r\nExplanation: Notice that the path visits the origin twice.", "created_at": "2025-01-25T12:37:21.840Z", "updated_at": "2025-01-25T12:37:21.859Z", "owner": 3, "tags": [3, 6]}}, {"model": "python_problems.problem", "pk": 236, "fields": {"title": "Minimum Time to Make Rope Colorful", "slug": "minimum-time-to-make-rope-colorful", "difficulty": 2, "url": "https://leetcode.com/problems/minimum-time-to-make-rope-colorful/description/", "description": "Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.\r\n\r\nAlice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.\r\n\r\nReturn the minimum time Bob needs to make the rope colorful.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: colors = \"abaac\", neededTime = [1,2,3,4,5]\r\nOutput: 3\r\nExplanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.\r\nBob can remove the blue balloon at index 2. This takes 3 seconds.\r\nThere are no longer two consecutive balloons of the same color. Total time = 3.\r\nExample 2:\r\n\r\n\r\nInput: colors = \"abc\", neededTime = [1,2,3]\r\nOutput: 0\r\nExplanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.\r\nExample 3:\r\n\r\n\r\nInput: colors = \"aabaa\", neededTime = [1,2,3,4,1]\r\nOutput: 2\r\nExplanation: Bob will remove the balloons at indices 0 and 4. Each balloons takes 1 second to remove.\r\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.", "created_at": "2025-01-25T13:59:04.956Z", "updated_at": "2025-01-25T13:59:04.976Z", "owner": 3, "tags": [2, 14, 10, 6]}}, {"model": "python_problems.problem", "pk": 237, "fields": {"title": "Find First and Last Position of Element in Sorted Array", "slug": "find-first-and-last-position-of-element-in-sorted-array", "difficulty": 2, "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/", "description": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\r\n\r\nIf target is not found in the array, return [-1, -1].\r\n\r\nYou must write an algorithm with O(log n) runtime complexity.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [5,7,7,8,8,10], target = 8\r\nOutput: [3,4]\r\nExample 2:\r\n\r\nInput: nums = [5,7,7,8,8,10], target = 6\r\nOutput: [-1,-1]\r\nExample 3:\r\n\r\nInput: nums = [], target = 0\r\nOutput: [-1,-1]", "created_at": "2025-01-26T01:00:30.120Z", "updated_at": "2025-01-26T01:00:30.140Z", "owner": 3, "tags": [2, 5]}}, {"model": "python_problems.problem", "pk": 238, "fields": {"title": "Find the Duplicate Number", "slug": "find-the-duplicate-number", "difficulty": 2, "url": "https://leetcode.com/problems/find-the-duplicate-number/description/", "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\r\n\r\nThere is only one repeated number in nums, return this repeated number.\r\n\r\nYou must solve the problem without modifying the array nums and using only constant extra space.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,3,4,2,2]\r\nOutput: 2\r\nExample 2:\r\n\r\nInput: nums = [3,1,3,4,2]\r\nOutput: 3\r\nExample 3:\r\n\r\nInput: nums = [3,3,3,3,3]\r\nOutput: 3", "created_at": "2025-01-26T16:16:52.102Z", "updated_at": "2025-01-26T16:16:52.125Z", "owner": 3, "tags": [2, 5, 39, 4]}}, {"model": "python_problems.problem", "pk": 239, "fields": {"title": "Insert into a Binary Search Tree", "slug": "insert-into-a-binary-search-tree", "difficulty": 2, "url": "https://leetcode.com/problems/insert-into-a-binary-search-tree/description/", "description": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\r\n\r\nNotice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\r\n\r\n \r\n\r\nExample 1:\r\n    __4\r\n   /   \\\r\n  2     7\r\n / \\\r\n1   3\r\n\r\n    __4__\r\n   /     \\\r\n  2       7\r\n / \\     /\r\n1   3   5\r\n\r\nInput: root = [4,2,7,1,3], val = 5\r\nOutput: [4,2,7,1,3,5]\r\nExplanation: Another accepted tree is:\r\n    ____5\r\n   /     \\\r\n  2       7\r\n / \\\r\n1   3\r\n     \\\r\n      4\r\n\r\nExample 2:\r\n     ____40___\r\n    /         \\\r\n  _20         _60\r\n /   \\       /   \\\r\n10    30    50    70\r\n\r\n     _______40___\r\n    /            \\\r\n  _20___         _60\r\n /      \\       /   \\\r\n10      _30    50    70\r\n       /\r\n      25\r\n\r\nInput: root = [40,20,60,10,30,50,70], val = 25\r\nOutput: [40,20,60,10,30,50,70,null,null,25]\r\n\r\nExample 3:\r\n    __4\r\n   /   \\\r\n  2     7\r\n / \\\r\n1   3\r\n\r\n    __4__\r\n   /     \\\r\n  2       7\r\n / \\     /\r\n1   3   5\r\n\r\nInput: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\r\nOutput: [4,2,7,1,3,5]", "created_at": "2025-01-26T20:03:16.295Z", "updated_at": "2025-01-26T20:03:16.314Z", "owner": 3, "tags": [5, 50, 40]}}, {"model": "python_problems.problem", "pk": 240, "fields": {"title": "Task Scheduler", "slug": "task-scheduler", "difficulty": 2, "url": "https://leetcode.com/problems/task-scheduler/description/", "description": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label.\r\n\r\nReturn the minimum number of CPU intervals required to complete all tasks.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\r\n\r\nOutput: 8\r\n\r\nExplanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.\r\n\r\nAfter completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th interval, you can do A again as 2 intervals have passed.\r\n\r\nExample 2:\r\n\r\nInput: tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1\r\n\r\nOutput: 6\r\n\r\nExplanation: A possible sequence is: A -> B -> C -> D -> A -> B.\r\n\r\nWith a cooling interval of 1, you can repeat a task after just one other task.\r\n\r\nExample 3:\r\n\r\nInput: tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3\r\n\r\nOutput: 10\r\n\r\nExplanation: A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B.\r\n\r\nThere are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.", "created_at": "2025-01-28T14:32:30.332Z", "updated_at": "2025-01-28T14:32:30.356Z", "owner": 3, "tags": [2, 11, 10, 3, 19, 17]}}, {"model": "python_problems.problem", "pk": 241, "fields": {"title": "Design Twitter", "slug": "design-twitter", "difficulty": 2, "url": "https://leetcode.com/problems/design-twitter/description/", "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\r\n\r\nImplement the Twitter class:\r\n\r\nTwitter() Initializes your twitter object.\r\nvoid postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\r\nList<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\r\nvoid follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\r\nvoid unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\r\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\r\nOutput\r\n[null, null, [5], null, null, [6, 5], null, [5]]\r\n\r\nExplanation\r\nTwitter twitter = new Twitter();\r\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\r\ntwitter.follow(1, 2);    // User 1 follows user 2.\r\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\r\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\r\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.", "created_at": "2025-01-28T21:06:19.344Z", "updated_at": "2025-01-28T21:06:19.362Z", "owner": 3, "tags": [35, 3, 19, 37]}}, {"model": "python_problems.problem", "pk": 242, "fields": {"title": "Find Unique Binary String", "slug": "find-unique-binary-string", "difficulty": 2, "url": "https://leetcode.com/problems/find-unique-binary-string/description/", "description": "Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [\"01\",\"10\"]\r\nOutput: \"11\"\r\nExplanation: \"11\" does not appear in nums. \"00\" would also be correct.\r\nExample 2:\r\n\r\nInput: nums = [\"00\",\"01\"]\r\nOutput: \"11\"\r\nExplanation: \"11\" does not appear in nums. \"10\" would also be correct.\r\nExample 3:\r\n\r\nInput: nums = [\"111\",\"011\",\"001\"]\r\nOutput: \"101\"\r\nExplanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct.", "created_at": "2025-01-30T00:32:27.438Z", "updated_at": "2025-01-30T00:32:27.461Z", "owner": 3, "tags": [2, 36, 3, 6]}}, {"model": "python_problems.problem", "pk": 243, "fields": {"title": "Check if There is a Valid Partition For The Array", "slug": "check-if-there-is-a-valid-partition-for-the-array", "difficulty": 2, "url": "https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/description/", "description": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\r\n\r\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\r\n\r\nThe subarray consists of exactly 2, equal elements. For example, the subarray [2,2] is good.\r\nThe subarray consists of exactly 3, equal elements. For example, the subarray [4,4,4] is good.\r\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\r\nReturn true if the array has at least one valid partition. Otherwise, return false.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [4,4,4,5,6]\r\nOutput: true\r\nExplanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\r\nThis partition is valid, so we return true.\r\nExample 2:\r\n\r\nInput: nums = [1,1,1,2]\r\nOutput: false\r\nExplanation: There is no valid partition for this array.", "created_at": "2025-01-30T22:17:50.947Z", "updated_at": "2025-01-30T22:17:50.967Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 244, "fields": {"title": "Minimum Number of Operations to Make Array Continuous", "slug": "minimum-number-of-operations-to-make-array-continuous", "difficulty": 3, "url": "https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/description/", "description": "You are given an integer array nums. In one operation, you can replace any element in nums with any integer.\r\n\r\nnums is considered continuous if both of the following conditions are fulfilled:\r\n\r\nAll elements in nums are unique.\r\nThe difference between the maximum element and the minimum element in nums equals nums.length - 1.\r\nFor example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.\r\n\r\nReturn the minimum number of operations to make nums continuous.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [4,2,5,3]\r\nOutput: 0\r\nExplanation: nums is already continuous.\r\nExample 2:\r\n\r\nInput: nums = [1,2,3,5,6]\r\nOutput: 1\r\nExplanation: One possible solution is to change the last element to 4.\r\nThe resulting array is [1,2,3,5,4], which is continuous.\r\nExample 3:\r\n\r\nInput: nums = [1,10,100,1000]\r\nOutput: 3\r\nExplanation: One possible solution is to:\r\n- Change the second element to 2.\r\n- Change the third element to 3.\r\n- Change the fourth element to 4.\r\nThe resulting array is [1,2,3,4], which is continuous.", "created_at": "2025-02-06T23:37:31.205Z", "updated_at": "2025-02-06T23:37:31.229Z", "owner": 3, "tags": [2, 5, 3, 24]}}, {"model": "python_problems.problem", "pk": 245, "fields": {"title": "Design Compressed String Iterator", "slug": "design-compressed-string-iterator", "difficulty": 1, "url": "https://leetcode.com/problems/design-compressed-string-iterator", "description": "Design and implement a data structure for a compressed string iterator. It should support the following operations: next and hasNext.\r\n\r\nThe given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.\r\n\r\nnext() - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.\r\nhasNext() - Judge whether there is any letter needs to be uncompressed.\r\n\r\nNote:\r\nPlease remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see here for more details.\r\n\r\nExample:\r\n\r\nStringIterator iterator = new StringIterator(\"L1e2t1C1o1d1e1\");\r\n\r\niterator.next(); // return 'L'\r\niterator.next(); // return 'e'\r\niterator.next(); // return 'e'\r\niterator.next(); // return 't'\r\niterator.next(); // return 'C'\r\niterator.next(); // return 'o'\r\niterator.next(); // return 'd'\r\niterator.hasNext(); // return true\r\niterator.next(); // return 'e'\r\niterator.hasNext(); // return false\r\niterator.next(); // return ' '", "created_at": "2025-02-13T03:37:24.127Z", "updated_at": "2025-02-13T03:37:24.150Z", "owner": 3, "tags": [2, 35, 51, 6]}}, {"model": "python_problems.problem", "pk": 246, "fields": {"title": "Binary Search Tree Iterator", "slug": "binary-search-tree-iterator", "difficulty": 2, "url": "https://leetcode.com/problems/binary-search-tree-iterator/", "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\r\n\r\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\r\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\r\nint next() Moves the pointer to the right, then returns the number at the pointer.\r\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\r\n\r\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\r\n\r\n \r\n\r\nExample 1:\r\n  7__\r\n /   \\\r\n3     15\r\n     /  \\\r\n    9    20\r\n\r\nInput\r\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\r\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\r\nOutput\r\n[null, 3, 7, true, 9, true, 15, true, 20, false]\r\n\r\nExplanation\r\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\r\nbSTIterator.next();    // return 3\r\nbSTIterator.next();    // return 7\r\nbSTIterator.hasNext(); // return True\r\nbSTIterator.next();    // return 9\r\nbSTIterator.hasNext(); // return True\r\nbSTIterator.next();    // return 15\r\nbSTIterator.hasNext(); // return True\r\nbSTIterator.next();    // return 20\r\nbSTIterator.hasNext(); // return False", "created_at": "2025-02-14T10:40:44.434Z", "updated_at": "2025-02-14T10:40:44.455Z", "owner": 3, "tags": [50, 42, 35, 51, 7, 40]}}, {"model": "python_problems.problem", "pk": 247, "fields": {"title": "Maximum Frequency Stack", "slug": "maximum-frequency-stack", "difficulty": 3, "url": "https://leetcode.com/problems/maximum-frequency-stack/description/", "description": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\r\n\r\nImplement the FreqStack class:\r\n\r\nFreqStack() constructs an empty frequency stack.\r\nvoid push(int val) pushes an integer val onto the top of the stack.\r\nint pop() removes and returns the most frequent element in the stack.\r\nIf there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\r\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\r\nOutput\r\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\r\n\r\nExplanation\r\nFreqStack freqStack = new FreqStack();\r\nfreqStack.push(5); // The stack is [5]\r\nfreqStack.push(7); // The stack is [5,7]\r\nfreqStack.push(5); // The stack is [5,7,5]\r\nfreqStack.push(7); // The stack is [5,7,5,7]\r\nfreqStack.push(4); // The stack is [5,7,5,7,4]\r\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\r\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\r\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\r\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\r\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].", "created_at": "2025-02-15T00:07:49.171Z", "updated_at": "2025-02-15T00:07:49.192Z", "owner": 3, "tags": [35, 3, 56, 7]}}, {"model": "python_problems.problem", "pk": 248, "fields": {"title": "Minimum Cost For Tickets", "slug": "minimum-cost-for-tickets", "difficulty": 2, "url": "https://leetcode.com/problems/minimum-cost-for-tickets/description/", "description": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\r\n\r\nTrain tickets are sold in three different ways:\r\n\r\na 1-day pass is sold for costs[0] dollars,\r\na 7-day pass is sold for costs[1] dollars, and\r\na 30-day pass is sold for costs[2] dollars.\r\nThe passes allow that many days of consecutive travel.\r\n\r\nFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\r\nReturn the minimum number of dollars you need to travel every day in the given list of days.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\r\nOutput: 11\r\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\r\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\r\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\r\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\r\nIn total, you spent $11 and covered all the days of your travel.\r\nExample 2:\r\n\r\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\r\nOutput: 17\r\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\r\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\r\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\r\nIn total, you spent $17 and covered all the days of your travel.", "created_at": "2025-02-21T07:22:47.816Z", "updated_at": "2025-02-21T07:22:47.837Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 249, "fields": {"title": "Integer Break", "slug": "integer-break", "difficulty": 2, "url": "https://leetcode.com/problems/integer-break/description/", "description": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\r\n\r\nReturn the maximum product you can get.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: n = 2\r\nOutput: 1\r\nExplanation: 2 = 1 + 1, 1  1 = 1.\r\nExample 2:\r\n\r\nInput: n = 10\r\nOutput: 36\r\nExplanation: 10 = 3 + 3 + 4, 3  3  4 = 36.", "created_at": "2025-02-21T10:11:19.497Z", "updated_at": "2025-02-21T10:11:19.518Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 250, "fields": {"title": "Number of Longest Increasing Subsequence", "slug": "number-of-longest-increasing-subsequence", "difficulty": 2, "url": "https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/", "description": "Given an integer array nums, return the number of longest increasing subsequences.\r\n\r\nNotice that the sequence has to be strictly increasing.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: nums = [1,3,5,4,7]\r\nOutput: 2\r\nExplanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\r\nExample 2:\r\n\r\nInput: nums = [2,2,2,2,2]\r\nOutput: 5\r\nExplanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.", "created_at": "2025-02-22T07:14:17.046Z", "updated_at": "2025-02-22T07:15:09.462Z", "owner": 3, "tags": [2, 49, 14, 59]}}, {"model": "python_problems.problem", "pk": 251, "fields": {"title": "Uncrossed Lines", "slug": "uncrossed-lines", "difficulty": 2, "url": "https://leetcode.com/problems/uncrossed-lines/description/", "description": "You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines.\r\n\r\nWe may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that:\r\n\r\nnums1[i] == nums2[j], and\r\nthe line we draw does not intersect any other connecting (non-horizontal) line.\r\nNote that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\r\n\r\nReturn the maximum number of connecting lines we can draw in this way.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: nums1 = [1,4,2], nums2 = [1,2,4]\r\nOutput: 2\r\nExplanation: We can draw 2 uncrossed lines as in the diagram.\r\nWe cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.\r\nExample 2:\r\n\r\nInput: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\r\nOutput: 3\r\nExample 3:\r\n\r\nInput: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\r\nOutput: 2", "created_at": "2025-02-23T07:15:58.900Z", "updated_at": "2025-02-23T07:15:58.921Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 252, "fields": {"title": "Solving Questions With Brainpower", "slug": "solving-questions-with-brainpower", "difficulty": 2, "url": "https://leetcode.com/problems/solving-questions-with-brainpower/description/", "description": "You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].\r\n\r\nThe array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.\r\n\r\nFor example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:\r\nIf question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.\r\nIf instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.\r\nReturn the maximum points you can earn for the exam.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: questions = [[3,2],[4,3],[4,4],[2,5]]\r\nOutput: 5\r\nExplanation: The maximum points can be earned by solving questions 0 and 3.\r\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\r\n- Unable to solve questions 1 and 2\r\n- Solve question 3: Earn 2 points\r\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\r\nExample 2:\r\n\r\nInput: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\r\nOutput: 7\r\nExplanation: The maximum points can be earned by solving questions 1 and 4.\r\n- Skip question 0\r\n- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\r\n- Unable to solve questions 2 and 3\r\n- Solve question 4: Earn 5 points\r\nTotal points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.", "created_at": "2025-02-23T11:11:47.415Z", "updated_at": "2025-02-23T11:11:47.431Z", "owner": 3, "tags": [2, 14]}}, {"model": "python_problems.problem", "pk": 253, "fields": {"title": "Count Ways To Build Good Strings", "slug": "count-ways-to-build-good-strings", "difficulty": 2, "url": "https://leetcode.com/problems/count-ways-to-build-good-strings/description/", "description": "Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\r\n\r\nAppend the character '0' zero times.\r\nAppend the character '1' one times.\r\nThis can be performed any number of times.\r\n\r\nA good string is a string constructed by the above process having a length between low and high (inclusive).\r\n\r\nReturn the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: low = 3, high = 3, zero = 1, one = 1\r\nOutput: 8\r\nExplanation: \r\nOne possible valid good string is \"011\". \r\nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \r\nAll binary strings from \"000\" to \"111\" are good strings in this example.\r\nExample 2:\r\n\r\nInput: low = 2, high = 3, zero = 1, one = 2\r\nOutput: 5\r\nExplanation: The good strings are \"00\", \"11\", \"000\", \"110\", and \"011\".", "created_at": "2025-02-25T13:11:09.912Z", "updated_at": "2025-02-25T13:11:09.937Z", "owner": 3, "tags": [14]}}, {"model": "python_problems.solution", "pk": 1, "fields": {"problem": 1, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\r\n        seen = {}\r\n\r\n        for ind, num in enumerate(nums):\r\n            diff = target - num\r\n\r\n            if diff in seen:\r\n                return [seen[diff], ind]\r\n            else:\r\n                # seen.update({num: ind})\r\n                seen[num] = ind\r\n        \r\n        return None", "testcase": "(Solution().twoSum([2, 7, 11, 15], 9), [0, 1])\r\n(Solution().twoSum([3, 2, 4], 6), [1, 2])\r\n(Solution().twoSum([3, 3], 6), [0, 1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-02-01T00:00:00Z", "updated_at": "2024-07-24T23:29:19.727Z"}}, {"model": "python_problems.solution", "pk": 2, "fields": {"problem": 2, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def twoSum(self, numbers: list[int], target: int) -> list[int]:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n\r\n        while left < right:\r\n            curr_sum = numbers[left] + numbers[right]\r\n            if curr_sum > target:\r\n                right -= 1\r\n            elif curr_sum < target:\r\n                left += 1\r\n            else:\r\n                return [left + 1, right + 1]\r\n        \r\n        return None", "testcase": "(Solution().twoSum([2, 7, 11, 15], 9), [1, 2])\r\n(Solution().twoSum([2, 3, 4], 6), [1, 3])\r\n(Solution().twoSum([-1, 0], -1), [1, 2])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-02-04T11:04:36.923Z", "updated_at": "2024-08-23T09:23:42.015Z"}}, {"model": "python_problems.solution", "pk": 3, "fields": {"problem": 3, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def isValid(self, brackets: str) -> bool:\r\n        stacked_brackets = []\r\n        opposing_bracket = {\r\n            \")\": \"(\",\r\n            \"]\": \"[\",\r\n            \"}\": \"{\"\r\n        }\r\n\r\n        for bracket in brackets:\r\n            if bracket in opposing_bracket:\r\n                if (stacked_brackets and \r\n                        opposing_bracket[bracket] == stacked_brackets[-1]):\r\n                    stacked_brackets.pop()\r\n                else:\r\n                    return False\r\n            else:\r\n                stacked_brackets.append(bracket)\r\n        \r\n        return not stacked_brackets  # if not empty then unmatched brackets left", "testcase": "print(Solution().isValid(\"()\"), True)\r\nprint(Solution().isValid(\"({})\"), True)\r\nprint(Solution().isValid(\"(]\"), False)\r\nprint(Solution().isValid(\"(})\"), False)\r\nprint(Solution().isValid(\"([)\"), False)\r\nprint(Solution().isValid(\"\"), True)\r\nprint(Solution().isValid(\"[\"), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-02-07T22:09:13.846Z", "updated_at": "2025-02-07T01:49:28.383Z"}}, {"model": "python_problems.solution", "pk": 4, "fields": {"problem": 4, "language": 1, "owner": 3, "solution": "def dir_reduc(arr):\r\n    opos = {\"NORTH\": \"SOUTH\", \"SOUTH\": \"NORTH\", \"EAST\": \"WEST\", \"WEST\": \"EAST\"}\r\n    seen = []\r\n    \r\n    for direction in arr:\r\n        if seen and direction == opos[seen[-1]]:\r\n            seen.pop() #seen = seen[:-1]\r\n        else:\r\n            seen.append(direction) # seen += directions\r\n    return seen", "testcase": "(dir_reduc([\"NORTH\", \"SOUTH\", \"SOUTH\", \"EAST\", \"WEST\", \"NORTH\", \"WEST\"]), \"WEST\")\r\n(dir_reduc([\"NORTH\", \"EAST\", \"WEST\", \"SOUTH\", \"WEST\", \"WEST\"]), [\"WEST\", \"WEST\"])\r\n(dir_reduc([\"NORTH\", \"WEST\", \"SOUTH\", \"EAST\"]), [\"NORTH\", \"WEST\", \"SOUTH\", \"EAST\"])\r\n(dir_reduc([]), [])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-02-11T09:13:50.769Z", "updated_at": "2024-02-11T09:13:50.769Z"}}, {"model": "python_problems.solution", "pk": 5, "fields": {"problem": 6, "language": 1, "owner": 3, "solution": "# Two Pointers\r\nclass Solution:\r\n    def isPalindrome(self, sentence):\r\n        l = 0\r\n        r = len(sentence) - 1\r\n\r\n        while l < r:\r\n            while l < r and not sentence[l].isalnum():\r\n                l += 1\r\n            \r\n            while l < r and not sentence[r].isalnum():\r\n                r -= 1\r\n\r\n            if sentence[l].lower() != sentence[r].lower():\r\n                return False\r\n            else:\r\n                l += 1\r\n                r -= 1\r\n\r\n        return True\r\n\r\n\r\nimport string\r\nclass Solution:\r\n    def isPalindrome(self, s: str) -> bool:\r\n        l = 0\r\n        r = len(s) - 1\r\n\r\n        while l < r:\r\n            while s[l] in string.punctuation + \" \" and l < r:\r\n                l += 1\r\n\r\n            while s[r] in string.punctuation + \" \"  and l < r:\r\n                r -= 1\r\n            \r\n            if s[l].lower() != s[r].lower():\r\n                return False\r\n\r\n            l += 1\r\n            r -= 1\r\n        \r\n        return True\r\n\r\n\r\n# replace\r\nimport string\r\nclass Solution:\r\n    def isPalindrome(self, s: str) -> bool:\r\n        for char in string.punctuation + \" \":\r\n            s = s.replace(char, \"\")\r\n        return s.lower() == s[::-1].lower()\r\nSolution().isPalindrome(\"A man, a plan, a canal: Panama\")\r\n\r\n\r\n# regex\r\nimport re\r\nclass Solution:\r\n    def isPalindrome(self, s: str) -> bool:\r\n        s = re.sub(r\"[\\W_]\", \"\", s).lower()\r\n        return s == s[::-1]\r\nSolution().isPalindrome(\"A man, a plan, a canal: Panama\")\r\n\r\n\r\n# comprehension list, isalpha()\r\nclass Solution:\r\n    def isPalindrome(self, s: str) -> bool:\r\n        cleaned_s = [alph.lower() for alph in s if alph.isalpha()]\r\n        return cleaned_s == cleaned_s[::-1]\r\nSolution().isPalindrome(\"A man, a plan, a canal: Panama\")\r\n\r\n\r\n# comprehension list\r\nimport string\r\nclass Solution:\r\n    def isPalindrome(self, s: str) -> bool:\r\n        # filtered_s = list(filter(lambda x: not x in string.punctuation + \" \", s))\r\n        filtered_s = list(alph.lower() for alph in s if not alph in string.punctuation + \" \")\r\n        # return \"\".join(filtered_s).lower() == \"\".join(filtered_s[::-1]).lower()\r\n        return filtered_s == filtered_s[::-1]\r\nSolution().isPalindrome(\"A man, a plan, a canal: Panama\")", "testcase": "(Solution().isPalindrome(\"A man, a plan, a canal: Panama\"), True)\r\n(Solution().isPalindrome(\"race a car\"), False)\r\n(Solution().isPalindrome(\" \"), True)\r\n(Solution().isPalindrome(\"0P\"), False)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-02-14T20:18:27.692Z", "updated_at": "2024-08-22T19:09:48.660Z"}}, {"model": "python_problems.solution", "pk": 6, "fields": {"problem": 7, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def balancedStringSplit(self, s: str) -> int:\r\n        seen = []\r\n        oppos = {\"L\": \"R\", \"R\": \"L\"}\r\n        counter = 0\r\n\r\n        for direct in s:\r\n            if seen and oppos[direct] == seen[-1]:\r\n                seen.pop()\r\n            else:\r\n                seen.append(direct)\r\n            if not seen:\r\n                counter += 1\r\n\r\n        return counter", "testcase": "(Solution().balancedStringSplit(\"RLRRLLRLRL\"), 4)\r\n(Solution().balancedStringSplit(\"RLRRRLLRLL\"), 2)\r\n(Solution().balancedStringSplit(\"LLLLRRRR\"), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-02-18T07:23:04.615Z", "updated_at": "2024-02-18T07:23:04.615Z"}}, {"model": "python_problems.solution", "pk": 7, "fields": {"problem": 8, "language": 1, "owner": 3, "solution": "def sum_pairs(ints, s):\r\n    seen = set()\r\n\r\n    for number in ints:\r\n        diff = s - number\r\n\r\n        if diff in seen:\r\n            return [diff, number]\r\n        seen.add(number)\r\n\r\n    return None", "testcase": "(sum_pairs([10, 5, 2, 3, 7, 5], 10), [3, 7])\r\n(sum_pairs([1, 4, 8, 7, 3, 15], 8), [1, 7])\r\n(sum_pairs([1, -2, 3, 0, -6, 1], -6), [0, -6])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-02-21T18:27:41.538Z", "updated_at": "2024-02-21T18:27:41.538Z"}}, {"model": "python_problems.solution", "pk": 8, "fields": {"problem": 10, "language": 1, "owner": 3, "solution": "# O(n * m) O(n)\r\nclass Solution():\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n\r\n        bottom_row = [1] * n\r\n\r\n        for _ in range(m - 1):\r\n            curr_row = [1] * n\r\n        \r\n            for i in range(n - 1)[::-1]:\r\n                curr_row[i] = curr_row[i + 1] + bottom_row[i]\r\n\r\n            bottom_row = curr_row\r\n\r\n        return bottom_row[0]", "testcase": "(Solution().uniquePaths(3, 7), 28)\r\n(Solution().uniquePaths(3, 2), 3)\r\n(Solution().uniquePaths(1, 2), 1)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-02-25T05:32:18.461Z", "updated_at": "2024-02-25T05:32:18.461Z"}}, {"model": "python_problems.solution", "pk": 9, "fields": {"problem": 11, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def containsDuplicate(self, nums: list[int]) -> bool:\r\n        seen = set()\r\n    \r\n        for num in nums:\r\n            if num in seen:\r\n                return True\r\n            else:\r\n                seen.add(num)\r\n        return False\r\n        \r\n        # alt solution \r\n        # return not (len(set(nums)) == len(nums))\r\n\r\n        # alt solution\r\n        # import numpy as np\r\n        # return len(np.unique(nums)) == len(nums)", "testcase": "(Solution().containsDuplicate([1, 2, 3, 1]), True)\r\n(Solution().containsDuplicate([1, 2, 3]), False)\r\n(Solution().containsDuplicate([1, 2, 3, 4]), False)\r\n(Solution().containsDuplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]), True)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-02-28T16:36:55.384Z", "updated_at": "2024-07-09T11:53:46.132Z"}}, {"model": "python_problems.solution", "pk": 10, "fields": {"problem": 12, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def counter(self, word):\r\n        counter = {}\r\n\r\n        for letter in word:\r\n            counter[letter] = counter.get(letter, 0) + 1\r\n\r\n        return counter\r\n\r\n    def isAnagram(self, word1, word2):\r\n        return self.counter(word1) == self.counter(word2)\r\n\r\n\r\nfrom collections import Counter\r\n\r\nclass Solution:\r\n    def isAnagram(self, s: str, t: str) -> bool:\r\n        return Counter(s) == Counter(t)", "testcase": "(Solution().isAnagram(\"anagram\", \"nagaram\"), True)\r\n(Solution().isAnagram(\"rat\", \"car\"), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-03-03T03:41:32.307Z", "updated_at": "2024-08-19T17:23:23.800Z"}}, {"model": "python_problems.solution", "pk": 11, "fields": {"problem": 13, "language": 1, "owner": 3, "solution": "# O(m*n), O(m*n)\r\nclass Solution:\r\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\r\n        grouped_anagrams = dict()\r\n        # from collections import defaultdict\r\n        # grouped_anagrams = defaultdict(list)\r\n\r\n        for word in strs:\r\n            key = [0] * 26\r\n\r\n            for letter in word:\r\n                key[ord(letter) - ord(\"a\")] += 1\r\n\r\n            key = tuple(key)\r\n            if not key in grouped_anagrams:\r\n                grouped_anagrams[key] = []\r\n            grouped_anagrams[key].append(word)  # inplace method\r\n            # grouped_anagrams[key] = grouped_anagrams[key] + [word]  # creates new value\r\n\r\n        return grouped_anagrams.values()\r\n\r\n\r\n# alt solutions # 83, 19 O(m*n*logn) m - list cout, n - avg word len\r\nclass Solution:\r\n    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\r\n        grouped_anagrams = {}\r\n        \r\n        for word in strs:\r\n            key = \"\".join(sorted(word))\r\n            if key in grouped_anagrams:\r\n                grouped_anagrams[key].append(word)\r\n            else:\r\n                grouped_anagrams[key] = [word]\r\n        return list(grouped_anagrams.values())", "testcase": "(Solution().groupAnagrams([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]), [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']])\r\n(Solution().groupAnagrams([\"\"]), [[\"\"]])\r\n(Solution().groupAnagrams([\"a\"]), [[\"a\"]])\r\n(Solution().groupAnagrams([\"tin\",\"ram\",\"zip\",\"cry\",\"pus\",\"jon\",\"zip\",\"pyx\"]), [['tin'], ['ram'], ['zip', 'zip'], ['cry'], ['pus'], ['jon'], ['pyx']])", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-03-06T14:46:09.230Z", "updated_at": "2024-07-18T15:23:16.988Z"}}, {"model": "python_problems.solution", "pk": 12, "fields": {"problem": 14, "language": 1, "owner": 3, "solution": "# bucket as dict\r\n# It's actually faster to use a dict and sort its keys than to traverse through a list.\r\nclass Solution:\r\n    def topKFrequent(self, nums, solution_len):\r\n        solution = []\r\n        counts = {}\r\n        bucket = {}\r\n\r\n        # counts values\r\n        for num in nums:\r\n            counts[num] = counts.get(num, 0) + 1\r\n\r\n        # reverse counts {key: val} pairs as bucket\r\n        for key, val in counts.items():\r\n            if not val in bucket:\r\n                bucket[val] = []\r\n            bucket[val].append(key)\r\n\r\n        # sort frequencies descending\r\n        keys = sorted(bucket.keys(), reverse=True)\r\n\r\n        # get top solution_len values\r\n        for key in keys:\r\n            for number in bucket[key]:\r\n                solution.append(number)\r\n                if len(solution) == solution_len:\r\n                    return solution\r\n\r\n        return -1\r\n(Solution().topKFrequent([1, 1, 1, 2, 2, 3], 2), [1, 2])\r\n(Solution().topKFrequent([1], 1), [1])\r\n\r\n\r\n# O(n), O(n)\r\n# bucket as list of lists\r\n# It's actually faster to use a dict and sort its keys than to traverse through a list.\r\nclass Solution:\r\n    def topKFrequent(self, nums, solution_len):\r\n        solution = []\r\n        counts = {}\r\n        bucket = [[] for _ in range(len(nums) + 1)]\r\n        \r\n        # counts values\r\n        for num in nums:\r\n            counts[num] = counts.get(num, 0) + 1\r\n\r\n        # bucket as a list of lists\r\n        # [[], [3], [2], [1], [], [], []]\r\n        for key, val in counts.items():\r\n            bucket[val].append(key)\r\n        \r\n        # get top solution_len values\r\n        for numbers in bucket[::-1]:\r\n            for number in numbers:\r\n                solution.append(number)\r\n                if len(solution) == solution_len:\r\n                    return solution\r\n\r\n        return -1\r\n\r\n\r\nfrom collections import Counter\r\n\r\n# use Counter from collections\r\nclass Solution:\r\n    def topKFrequent(self, nums: list[int], k: int) -> list[int]:\r\n        return [key for key, _ in Counter(nums).most_common(k)]", "testcase": "(Solution().topKFrequent([1, 1, 1, 2, 2, 3], 2), [1, 2])\r\n(Solution().topKFrequent([1], 1), [1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-03-10T01:50:46.153Z", "updated_at": "2024-08-21T16:00:57.708Z"}}, {"model": "python_problems.solution", "pk": 13, "fields": {"problem": 15, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\nclass Solution:\r\n    def longestConsecutive(self, nums: list[int]) -> int:\r\n        nums_set = set(nums)\r\n        longest_concec = 0\r\n\r\n        for num in nums_set:\r\n            if not num - 1 in nums_set:\r\n                curr_len = 1\r\n                \r\n                while num + curr_len in nums_set:\r\n                    curr_len += 1\r\n                longest_concec = max(longest_concec, curr_len)\r\n\r\n        return longest_concec", "testcase": "(Solution().longestConsecutive([100, 4, 200, 1, 3, 2]), 4)\r\n(Solution().longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]), 9)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-03-13T12:55:23.076Z", "updated_at": "2024-03-13T12:55:23.076Z"}}, {"model": "python_problems.solution", "pk": 14, "fields": {"problem": 16, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def threeSum(self, nums: list[int]) -> list[list[int]]:\r\n        solution = []\r\n        nums.sort()\r\n\r\n        for index, num in enumerate(nums[:-2]):\r\n            # Skip positive nums\r\n            if num > 0:\r\n                break\r\n            \r\n            # Skip same num values\r\n            if index and nums[index] == nums[index - 1]:\r\n                continue\r\n\r\n            left = index + 1\r\n            right = len(nums) - 1\r\n\r\n            # two pointers\r\n            while left < right:\r\n                curr_sum = num + nums[left] + nums[right]\r\n                \r\n                if curr_sum < 0:  # if sum is less than 0\r\n                    left += 1\r\n                elif curr_sum > 0:  # if sum is geater than 0\r\n                    right -= 1\r\n                else:  # if sum is equal to 0\r\n                    solution.append([num, nums[left], nums[right]])\r\n                    left += 1\r\n                    right -= 1\r\n                    \r\n                    # skip same left pointer values\r\n                    while left < right and nums[left] == nums[left - 1]:\r\n                        left += 1                \r\n        \r\n        return solution", "testcase": "(Solution().threeSum([-1, 0, 1, 2, -1, -4]), [[-1, -1, 2], [-1, 0, 1]])\r\n(Solution().threeSum([3, 0, -2, -1, 1, 2]), [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]])\r\n(Solution().threeSum([1, 1, -2]), [[-2, 1, 1]])\r\n(Solution().threeSum([-1, 1, 1]), [])\r\n(Solution().threeSum([0, 0, 0]), [[0, 0, 0]])\r\n(Solution().threeSum([-2, 0, 0, 2, 2]), [[-2, 0, 2]])", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-03-17T00:00:00Z", "updated_at": "2024-08-23T10:49:04.520Z"}}, {"model": "python_problems.solution", "pk": 15, "fields": {"problem": 17, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\nclass Solution:\r\n    def maxArea(self, height: list[int]) -> int:\r\n        l = 0\r\n        r = len(height) - 1\r\n        max_pool_size = 0\r\n\r\n        while l < r:\r\n            pool_size = min(height[l], height[r]) * (r - l)\r\n            if pool_size > max_pool_size:\r\n                max_pool_size = pool_size\r\n\r\n            if height[l] < height[r]:\r\n                l += 1\r\n            else:\r\n                r -= 1\r\n\r\n        return max_pool_size\r\n\r\n\r\n\r\n# O(n2)\r\nclass Solution:\r\n    def maxArea(self, height: list[int]) -> int:\r\n        max_pool_size = 0\r\n\r\n        for i, h1 in enumerate(height[:-1]):\r\n            for j, h2 in enumerate(height[i+1:]):\r\n                pool_size = min(h1, h2) * (j + 1)\r\n                if  pool_size > max_pool_size:\r\n                    max_pool_size = pool_size\r\n\r\n        return max_pool_size", "testcase": "(Solution().maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]), 49)\r\n(Solution().maxArea([1, 1]), 1)\r\n(Solution().maxArea([2, 3, 4, 5, 18, 17, 6]), 17)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-03-20T11:04:36.923Z", "updated_at": "2024-07-25T21:25:22.464Z"}}, {"model": "python_problems.solution", "pk": 16, "fields": {"problem": 18, "language": 1, "owner": 3, "solution": "# O(nlgon), O(1)\nclass Solution:\n    def countPairs(self, nums: list[int], target: int) -> int:\n        counter = 0\n        nums.sort()\n        l = 0\n        r = len(nums) -1\n\n        while l < r:\n            if nums[l] + nums[r] < target:\n                # [-1, 1, 1, 2, 3] (r - l) because left = -1, rigth = 2, so add every combination (1, 1, 2) before incresing the left pointer\n                counter += r - l\n                l += 1\n            else:\n                r -= 1\n\n        return counter\n\n\n# O(n2), O(1)\nclass Solution:\n    def countPairs(self, nums, target):\n        nums.sort()\n        counter = 0\n\n        for ind, num in enumerate(nums[:-1]):\n            l = ind + 1\n\n            while l < len(nums) and num + nums[l] < target:\n                counter += 1\n                l += 1\n\n        return counter\n\n\n# O(n2), O(1)\nclass Solution:\n    def countPairs(self, nums: list[int], target: int) -> int:\n        counter = 0\n\n        for i_ind, i in enumerate(nums):\n            for j_ind, j in enumerate(nums):\n                if i_ind < j_ind and i + j < target:\n                    counter += 1\n        \n        return counter", "testcase": "(Solution().countPairs([-1, 1, 2, 3, 1], 2), 3)\r\n(Solution().countPairs([-6, 2, 5, -2, -7, -1, 3], -2), 10)\r\n(Solution().countPairs([6, -1, 7, 4, 2, 3], 8), 8)\r\n(Solution().countPairs([-5, 0, -7, -1, 9, 8, -9, 9], -14), 1)", "time_complexity": 5, "space_complexity": 1, "created_at": "2024-03-23T22:09:13.846Z", "updated_at": "2024-07-15T15:55:41.810Z"}}, {"model": "python_problems.solution", "pk": 17, "fields": {"problem": 19, "language": 1, "owner": 3, "solution": "class Solution:\n    def reversePrefix(self, word: str, ch: str) -> str:\n        prefix_word = \"\"\n        \n        for letter in word:\n            prefix_word = letter + prefix_word\n            \n            if letter == ch:\n                return prefix_word + word[len(prefix_word):]\n        \n        return word\n\n\nclass Solution:\n    def reversePrefix(self, word: str, ch: str) -> str:\n        letter_pos = word.find(ch)\n\n        if letter_pos == -1:\n            return word\n        else:\n            return word[:letter_pos + 1][::-1] + word[letter_pos + 1:]", "testcase": "(Solution().reversePrefix(\"abcdefd\", \"d\"), \"dcbaefd\")\r\n(Solution().reversePrefix(\"xyxzxe\", \"z\"), \"zxyxxe\")\r\n(Solution().reversePrefix(\"abcd\", \"z\"), \"ab", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-03-27T09:13:50.769Z", "updated_at": "2024-03-27T09:13:50.769Z"}}, {"model": "python_problems.solution", "pk": 18, "fields": {"problem": 20, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# build-in function\r\nclass Solution:\r\n    def firstPalindrome(self, words: list[str]) -> str:\r\n        for word in words:\r\n            if word == word[::-1]:\r\n                return word\r\n\r\n        return \"\"\r\n\r\n\r\n# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def firstPalindrome(self, words: list[str]) -> str:\r\n        for word in words:\r\n            left = 0\r\n            right = len(word) - 1\r\n\r\n            while left < right:\r\n                if word[left] != word[right]:\r\n                    break\r\n                \r\n                left += 1\r\n                right -= 1\r\n            \r\n            else:\r\n                return word\r\n\r\n        return \"\"", "testcase": "print(Solution().firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\", \"cool\"]), \"ada\")\r\nprint(Solution().firstPalindrome([\"notapalindrome\", \"racecar\"]), \"racecar\")\r\nprint(Solution().firstPalindrome([\"def\", \"ghi\"]), \"\")", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-03-30T20:18:27.692Z", "updated_at": "2024-12-06T04:53:42.808Z"}}, {"model": "python_problems.solution", "pk": 19, "fields": {"problem": 21, "language": 1, "owner": 3, "solution": "# set\nclass Solution:\n    def arithmeticTriplets(self, nums: list[int], diff: int) -> int:\n        num_set = set(nums)\n        counter = 0\n\n        for num in num_set:\n            if num + diff in num_set and num + 2*diff in num_set:\n                counter += 1\n\n        return counter\n\n\n# binary search\nclass Solution:\n    def binary_search(self, nums, num):\n# pointers    \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            middle_ind = (l + r)//2\n\n            if num > nums[middle_ind]:\n                l = middle_ind + 1\n            elif num < nums[middle_ind]:\n                r = middle_ind -1\n            else:\n                return True\n\n        return False\n\n# while\n#         while len(nums) >= 1:\n#             middle_ind = len(nums)//2\n# \n#             if num > nums[middle_ind]:\n#                 nums = nums[middle_ind + 1:]\n#             elif num < nums[middle_ind]:\n#                 nums = nums[:middle_ind]\n#             else:\n#                 return True\n# \n#         return False\n\n    def arithmeticTriplets(self, nums, diff):\n        counter = 0\n        for ind, num in enumerate(nums):\n            if self.binary_search(nums[ind + 1:], num + diff)\\\n                    and self.binary_search(nums[ind + 1:], num + 2*diff):\n                counter += 1\n\n        return counter\n", "testcase": "(Solution().arithmeticTriplets([0, 1, 4, 6, 7, 10], 3), 2)\r\n(Solution().arithmeticTriplets([4, 5, 6, 7, 8, 9], 2), 2)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-04-03T07:23:04.615Z", "updated_at": "2024-04-03T07:23:04.615Z"}}, {"model": "python_problems.solution", "pk": 20, "fields": {"problem": 22, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# built-in function\r\nclass Solution:\r\n    def reverseWords(self, text: str) -> str:\r\n        return \" \".join(word[::-1] \r\n                        for word in text.split())\r\n\r\n\r\n# O(n), O(n)\r\n# two pionters\r\nclass Solution:\r\n    def reverseWords(self, text: str) -> str:\r\n        text = list(text)\r\n        text.append(\" \")  # add space to catch the last word\r\n        left = 0  # the start of the word pointer\r\n\r\n        for index, letter in enumerate(text):\r\n            if letter == \" \":\r\n                right = index - 1  # the end of the word pointer\r\n\r\n                while left < right:\r\n                    text[left], text[right] = text[right], text[left]  # swap letters\r\n                    left += 1\r\n                    right -= 1\r\n                \r\n                left = index + 1  # move the left pointer to the beginning of the next word\r\n\r\n        return \"\".join(text[:-1])\r\n\r\n\r\nclass Solution:\r\n    def reverseWords(self, text: str) -> str:\r\n        rev_str = \"\"\r\n\r\n        for word in text.split():\r\n            rev_str = rev_str + word[::-1] + \" \"\r\n\r\n        return rev_str[:-1]\r\n\r\n\r\nclass Solution:\r\n    def reverseWords(self, text: str) -> str:\r\n        rev_word = \"\"\r\n        rev_text = \"\"\r\n\r\n        for letter in text:\r\n            if letter != \" \":\r\n                rev_word = letter + rev_word\r\n            else:\r\n                rev_text += rev_word + \" \"\r\n                rev_word = \"\"\r\n        \r\n        return rev_text + rev_word", "testcase": "print(Solution().reverseWords(\"Let's take LeetCode contest\"), \"s'teL ekat edoCteeL tsetnoc\")\r\nprint(Solution().reverseWords(\"Mr Ding\"), \"rM gniD\")\r\nprint(Solution().reverseWords(\"hehhhhhhe\"), \"ehhhhhheh\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-04-06T18:27:41.538Z", "updated_at": "2024-12-08T18:42:13.826Z"}}, {"model": "python_problems.solution", "pk": 21, "fields": {"problem": 23, "language": 1, "owner": 3, "solution": "# pointers as values\r\nclass Solution:\r\n    def maxProfit(self, prices):\r\n        left = prices[0]  # the left pointer as a value\r\n        max_profit = 0\r\n\r\n        for right in prices[1:]:  # the right pointer as a value\r\n            if left > right:  # if price is lower buy\r\n                left = right\r\n            else:  # if price is higher calculate revenue\r\n                current_profit = right - left\r\n                max_profit = max(max_profit, current_profit)\r\n\r\n        return max_profit\r\n\r\n\r\n# pointers as indexes\r\nclass Solution:\r\n    def maxProfit(self, prices):\r\n        max_profit = 0\r\n        left = 0  # the left pointer\r\n        right = 1  # the right pointer\r\n\r\n        while right < len(prices):  # bound the right pointer\r\n            if prices[left] > prices[right]:  # if price is lower buy\r\n                left = right# pointers as values\r\nclass Solution:\r\n    def maxProfit(self, prices):\r\n        left_price = prices[0]  # the left_price pointer as a value\r\n        max_profit = 0\r\n\r\n        for right_price in prices[1:]:  # the right_price pointer as a value\r\n            if left_price > right_price:  # if price is lower buy\r\n                left_price = right_price\r\n            else:  # if price is higher calculate revenue\r\n                profit = right_price - left_price\r\n                max_profit = max(max_profit, profit)\r\n\r\n        return max_profit\r\n\r\n\r\n# pointers as indexes\r\nclass Solution:\r\n    def maxProfit(self, prices):\r\n        max_profit = 0\r\n        left = 0  # the left pointer\r\n\r\n        for right in range(1, len(prices)):  # the right pointer\r\n            if prices[left] > prices[right]:  # if price is lower buy\r\n                left = right\r\n            else:  # if price is higher calculate revenue\r\n                profit = prices[right] - prices[left]\r\n                max_profit = max(max_profit, profit)\r\n\r\n        return max_profit\r\n\r\n\r\n# O(n), O(n)\r\n# two pass\r\nclass Solution:\r\n    def maxProfit(self, prices: list[int]) -> int:\r\n        min_price = [0] * len(prices)  # cache\r\n\r\n        for index, price in enumerate(prices):\r\n            if index:\r\n                min_price[index] = min(min_price[index - 1], price)\r\n            else:\r\n                min_price[index] = price\r\n        \r\n        for index, price in enumerate(prices):\r\n            min_price[index] = price - min_price[index]\r\n        \r\n        return max(min_price)\r\n    \r\n\r\n# O(n), O(n)\r\n# one pass\r\nclass Solution:\r\n    def maxProfit(self, prices: list[int]) -> int:\r\n        min_price = [0] * len(prices)  # cache\r\n        max_profit = 0\r\n\r\n        for index, price in enumerate(prices):\r\n            if index:\r\n                min_price[index] = min(min_price[index - 1], price)\r\n            else:\r\n                min_price[index] = price\r\n\r\n            max_profit = max(max_profit, price - min_price[index])\r\n        \r\n        return max_profit\r\n    \r\n\r\n# O(n), O(1)\r\n# one pass\r\nclass Solution:\r\n    def maxProfit(self, prices: list[int]) -> int:\r\n        max_profit = 0\r\n\r\n        for index, price in enumerate(prices):\r\n            if index:\r\n                min_price = min(min_price, price)\r\n            else:\r\n                min_price = price\r\n\r\n            max_profit = max(max_profit, price - min_price)\r\n        \r\n        return max_profit\r\n\r\n\r\n# O(n), O(1)\r\n# one pass, basic functions\r\nclass Solution:\r\n    def maxProfit(self, prices: list[int]) -> int:\r\n        max_profit = 0\r\n\r\n        for index, price in enumerate(prices):\r\n            if index:\r\n                if price < min_price:\r\n                    min_price = price\r\n            else:\r\n                min_price = price\r\n\r\n            profit = price - min_price\r\n        \r\n            if profit > max_profit:\r\n                max_profit = profit\r\n        \r\n        return max_profit\r\n                current_profit = prices[right] - prices[left]\r\n                max_profit = max(max_profit, current_profit)\r\n\r\n            right += 1\r\n\r\n        return max_profit", "testcase": "(Solution().maxProfit([7, 1, 5, 3, 6, 4]), 5)\r\n(Solution().maxProfit([7, 6, 4, 3, 1]), 0)\r\n(Solution().maxProfit([2, 4, 1]), 2)\r\n(Solution().maxProfit([2, 1, 2, 1, 0, 1, 2]), 2)\r\n(Solution().maxProfit([1, 2]), 1)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-04-10T05:32:18.461Z", "updated_at": "2024-11-21T22:43:33.361Z"}}, {"model": "python_problems.solution", "pk": 22, "fields": {"problem": 24, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# sliding window (as hash set)\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, word: str) -> int:\r\n        left = 0\r\n        window = set()  # slidiong window without repeating characters\r\n        longest = 0\r\n\r\n        for right, letter in enumerate(word):\r\n            while letter in window:  # while duplicate found\r\n                window.remove(word[left])  # remove (discard) that charactr with every preceding character\r\n                left += 1  # increase the left pointer\r\n\r\n            window.add(letter)  # add an unique letter\r\n            longest = max(longest, right - left + 1)  # update the length of the longest substring\r\n        return longest\r\n\r\n\r\n# O(n), O(n)\r\n# sliding window (as hash map)\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, word: str) -> int:\r\n        left = 0\r\n        window = {}  # sliding window as hash map\r\n        longest = 0\r\n\r\n        for right, letter in enumerate(word):\r\n            window[letter] = window.get(letter, 0) + 1  # update window\r\n\r\n            while window[letter] == 2:  # if duplicate found\r\n                window[word[left]] -= 1  #  pop window left\r\n                if window[word[left]] == 0:  # if no key\r\n                    window.pop(word[left])  # remove a key\r\n                left += 1  # increase the left pointer\r\n\r\n            longest = max(longest, right - left + 1)  # update the length of the longest substring\r\n        return longest\r\n\r\n\r\n# O(n3), O(1)\r\n# brute force\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, word: str) -> int:\r\n            longest = 0\r\n\r\n            for left in range(len(word)):\r\n                for right in range(left, len(word)):\r\n                    substring = word[left: right + 1]\r\n\r\n                    if len(substring) == len(set(substring)):\r\n                        longest = max(longest, right - left + 1)\r\n\r\n            return longest", "testcase": "print(Solution().lengthOfLongestSubstring(\"abcabcbb\"), 3)\r\nprint(Solution().lengthOfLongestSubstring(\"bbbbb\"), 1)\r\nprint(Solution().lengthOfLongestSubstring(\"pwwkew\"), 3)\r\nprint(Solution().lengthOfLongestSubstring(\"aabaab!bb\"), 3)\r\nprint(Solution().lengthOfLongestSubstring(\"aab\"), 2)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-04-13T16:36:55.384Z", "updated_at": "2025-02-02T16:32:21.717Z"}}, {"model": "python_problems.solution", "pk": 23, "fields": {"problem": 25, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def countGoodSubstrings(self, s: str) -> int:\r\n        counter = 0\r\n\r\n        for i in range(len(s) - 2):\r\n            if len(set(s[i: i + 3])) == 3:\r\n                counter += 1\r\n\r\n        return counter", "testcase": "(Solution().countGoodSubstrings(\"xyzzaz\"), 1)\r\n(Solution().countGoodSubstrings(\"aababcabc\"), 4)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-04-17T03:41:32.307Z", "updated_at": "2024-04-17T03:41:32.307Z"}}, {"model": "python_problems.solution", "pk": 24, "fields": {"problem": 26, "language": 1, "owner": 3, "solution": "# O(logn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def findMin(self, numbers):\r\n        left = 0\r\n        right = len(numbers) - 1\r\n        curr_min = numbers[0]  # assign some value\r\n\r\n        while left <= right:  # two pointers \r\n            middle = (left + right) // 2  # get the middle index\r\n            curr_min = min(curr_min, numbers[middle])  # check if the value in the middle it lower than currten min\r\n\r\n            if numbers[middle] < numbers[right]: # if the middle value is lower than the most right value\r\n                right = middle - 1  # then the left part should be searched\r\n            else:\r\n                left = middle + 1  # else the right part should be searched\r\n\r\n        return curr_min\r\n\r\n\r\n# O(logn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def findMin(self, numbers: list[int]) -> int:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n\r\n        while left <= right:\r\n            if right - left <= 1:\r\n                return min(numbers[left], numbers[right])\r\n            \r\n            middle = (left + right) // 2\r\n\r\n            if numbers[middle] < numbers[right]:  # minimum is in the left portion\r\n                right = middle\r\n            else:\r\n                left = middle + 1", "testcase": "(Solution().findMin([1, 2, 3, 4]), 1)\r\n(Solution().findMin([4, 1, 2, 3]), 1)\r\n(Solution().findMin([2, 3, 4, 1]), 1)\r\n(Solution().findMin([3, 4, 1, 2]), 1)\r\n(Solution().findMin([4, 5, 1, 2, 3]), 1)\r\n(Solution().findMin([5, 1, 2, 3, 4]), 1)\r\n(Solution().findMin([1, 2, 3, 4, 5]), 1)\r\n(Solution().findMin([2, 3, 4, 5, 1]), 1)\r\n(Solution().findMin([3, 4, 5, 1, 2]), 1)\r\n(Solution().findMin([4, 5, 6, 7, 0, 1, 2]), 0)\r\n(Solution().findMin([11, 13, 15, 17]), 11)\r\n(Solution().findMin([1]), 1)\r\n(Solution().findMin([3, 1, 2]), 1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-04-20T14:46:09.230Z", "updated_at": "2024-11-26T16:38:40.256Z"}}, {"model": "python_problems.solution", "pk": 25, "fields": {"problem": 27, "language": 1, "owner": 3, "solution": "def is_even_letters(word):\r\n    word_len = len([letter for letter in word if letter.isalpha()])\r\n    return not word_len % 2\r\n\r\n\r\ndef is_odd_digits(word):\r\n    word_len = len([digit for digit in word if digit.isdigit()])\r\n    return bool(word_len % 2)\r\n\r\n\r\ndef solution(S):\r\n    if not S:\r\n        return -1\r\n    sol = -1\r\n    for word in S.split():\r\n        if word.isalnum() and is_even_letters(word) and is_odd_digits(word):\r\n            sol = max(sol, len(word))\r\n    return sol", "testcase": "(solution(\"test 5 a0A pass007 ?xy1\"), 7)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-04-24T01:50:46.153Z", "updated_at": "2024-04-24T01:50:46.153Z"}}, {"model": "python_problems.solution", "pk": 26, "fields": {"problem": 28, "language": 1, "owner": 3, "solution": "def flood_depth(land):\r\n    l = 0\r\n    r = len(land) - 1\r\n    flood_depth = 0\r\n    # flood_sum = 0\r\n    max_land_l = 0\r\n    max_land_r = 0\r\n\r\n    while l < r:\r\n        if land[l] < land[r]:\r\n            max_land_l = max(max_land_l, land[l])\r\n            flood_depth = max(flood_depth, max_land_l - land[l])\r\n            # flood_depth = max_land_l - land[l]\r\n            # flood_sum += flood_depth\r\n            l += 1\r\n        else:\r\n            max_land_r = max(max_land_r, land[r])\r\n            flood_depth = max(flood_depth, max_land_r - land[r])\r\n            # flood_depth = max_land_r - land[r]\r\n            # flood_sum += flood_depth\r\n            r -= 1\r\n\r\n    return flood_depth", "testcase": "(flood_depth([1, 3, 2, 1, 2, 1, 5, 3, 3, 4, 2]), 2)\r\n(flood_depth([5, 8]), 0)\r\n(flood_depth([3, 1, 2]), 1)\r\n(flood_depth([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-04-27T12:55:23.076Z", "updated_at": "2024-04-27T12:55:23.076Z"}}, {"model": "python_problems.solution", "pk": 27, "fields": {"problem": 29, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def trap(self, heights):\r\n        left = 0\r\n        right = len(heights) - 1\r\n        left_max_height = 0\r\n        right_max_height = 0\r\n        trapped_water = 0\r\n\r\n        # two pointers\r\n        while left < right:\r\n            if heights[left] < heights[right]:  # choose the lower height because it gets to higher eventually\r\n                left_max_height = max(left_max_height, heights[left])\r\n                curr_water = left_max_height - heights[left]\r\n                trapped_water += curr_water\r\n                left += 1\r\n            else:\r\n                right_max_height = max(right_max_height, heights[right])\r\n                curr_water = right_max_height - heights[right]\r\n                trapped_water += curr_water\r\n                right -= 1\r\n\r\n        return trapped_water", "testcase": "(Solution().trap([1, 3, 2, 1, 2, 1, 5, 3, 3, 4, 2]), 8)\r\n(Solution().trap([5, 8]), 0)\r\n(Solution().trap([3, 1, 2]), 1)\r\n(Solution().trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), 6)\r\n(Solution().trap([4, 2, 0, 3, 2, 5]), 9)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-05-01T00:00:00Z", "updated_at": "2024-08-23T12:55:27.982Z"}}, {"model": "python_problems.solution", "pk": 28, "fields": {"problem": 30, "language": 1, "owner": 3, "solution": "\"\"\"\r\nblueprint\r\n             ___5\r\n           _| 4\r\n         _| 3\r\n       _| 2\r\n     _| 1\r\n____|\r\n\r\n           ___4\r\n         _|  3\r\n       _|  2\r\n     _|  1\r\n____|\r\n\r\n         ___3\r\n       _|  2\r\n     _|  1\r\n____|\r\n\r\n\r\nAdding steps\r\n                   0\r\n             /1          \\2\r\n            1             2\r\n        /1     \\2      /1   \\2\r\n       2        3     3      4\r\n     /1  \\2    /1    /1\r\n   3      4   4     4\r\n  /1\r\n 4\r\n\r\nSubtracting steps\r\n                   4\r\n             /1          \\2\r\n            3             2\r\n        /1     \\2      /1   \\2\r\n       2        1     1      0\r\n     /1  \\2    /1    /1\r\n   1      0   0     0\r\n  /1\r\n 0\r\n\r\n\r\n5 -> 1 + 4 + 3 = 8\r\n4 -> 5\r\n3 -> 3\r\n2 -> 2\r\n1 -> 1\r\n0 -> 0\r\n\r\nFibonnacci problem\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def climbStairs(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        if number == 0:\r\n            return 0\r\n        elif number == 1:\r\n            return 1\r\n        \r\n        cache = [1, 1]\r\n\r\n        for _ in range(2, number + 1):\r\n            cache = [cache[1], cache[0] + cache[1]]\r\n\r\n        return cache[-1]\r\n\r\n\r\nclass Solution:\r\n    def climbStairs(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        if number == 0:\r\n            return 0\r\n        elif number == 1:\r\n            return 1\r\n        \r\n        cache = [1] * (number + 1)\r\n\r\n        for index in range(2, number + 1):\r\n            cache[index] = cache[index - 1] + cache[index - 2]\r\n\r\n        return cache[number]\r\n\r\n\r\nclass Solution:\r\n    def climbStairs(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        if number == 0:\r\n            return 0\r\n        \r\n        memo = {0: 1}\r\n\r\n        def dfs(index):\r\n            if index < 0:\r\n                return 0\r\n            elif index in memo:\r\n                return memo[index]\r\n\r\n            memo[index] = dfs(index - 1) + dfs(index - 2)\r\n            return memo[index]\r\n\r\n        return dfs(number)\r\n\r\n\r\nclass Solution:\r\n    def climbStairs(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        if number == 0:\r\n            return 0\r\n        \r\n        memo = [None] * (number + 1)\r\n        memo[0] = 1\r\n\r\n        def dfs(index):\r\n            if index < 0:\r\n                return 0\r\n            elif memo[index]:\r\n                return memo[index]\r\n\r\n            memo[index] = dfs(index - 1) + dfs(index - 2)\r\n            return memo[index]\r\n\r\n        return dfs(number)\r\n\r\n\r\nclass Solution:\r\n    def climbStairs(self, number: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, pure recursion, tle\r\n        converts to top-down\r\n        \"\"\"\r\n        if number == 0:\r\n            return 0\r\n        \r\n        def dfs(index):\r\n            if index < 0:\r\n                return 0\r\n            elif index == 0:\r\n                return 1\r\n\r\n            return dfs(index - 1) + dfs(index - 2)\r\n\r\n        return dfs(number)\r\n\r\n\r\nclass Solution:\r\n    def climbStairs(self, number: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, shared state, tle\r\n        \"\"\"\r\n        if number == 0:\r\n            return 0\r\n        \r\n        self.counter = 0\r\n\r\n        def dfs(index):\r\n            if index == 0:\r\n                self.counter += 1\r\n                return\r\n            elif index < 0:\r\n                return\r\n\r\n            dfs(index - 1)\r\n            dfs(index - 2)\r\n\r\n        dfs(number)\r\n        return self.counter\r\n\r\n\r\n# generator\r\ndef Fib_gen(n):\r\n    a = 1\r\n    b = 1\r\n\r\n    for _ in range(n):\r\n        yield b\r\n        a, b = b, a + b\r\n\r\nfib5 = Fib_gen(5)\r\n\r\nfor i in fib5:\r\n    print(i)\r\nnext(fib5)", "testcase": "print(Solution().climbStairs(0), 0)\r\nprint(Solution().climbStairs(1), 1)\r\nprint(Solution().climbStairs(2), 2)\r\nprint(Solution().climbStairs(3), 3)\r\nprint(Solution().climbStairs(4), 5)\r\nprint(Solution().climbStairs(5), 8)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-05-04T11:04:36.923Z", "updated_at": "2025-02-16T08:49:13.570Z"}}, {"model": "python_problems.solution", "pk": 29, "fields": {"problem": 31, "language": 1, "owner": 3, "solution": "# draft\r\n# values     [2, 7, 9,  3,  1]\r\n# cumulative [2, 7, 11,11. 12]\r\n\r\n# [2, 100, 9, 3, 100] data\r\n# [2, 100, 100, 100, 200] dp solution\r\n# [(2), (2, 100), (100, 100) ....]\r\n\r\n# [100, 9, 3, 100, 2] data\r\n# [100, 100, 100, 200, 200] dp solution\r\n\r\n\r\nclass Solution:\r\n    def rob(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        if len(numbers) < 3:\r\n            return max(numbers)\r\n\r\n        cache = [numbers[0], max(numbers[:2])]\r\n\r\n        for index in range(2, len(numbers)):\r\n            cache = [cache[1], max(numbers[index] + cache[0], cache[1])]\r\n\r\n        return cache[-1]\r\n\r\n\r\nclass Solution:\r\n    def rob(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        mutate input list\r\n        \"\"\"\r\n        if len(numbers) < 3:\r\n            return max(numbers)\r\n\r\n        numbers[1] = max(numbers[:2])\r\n\r\n        for index in range(2, len(numbers)):\r\n            numbers[index] = max(numbers[index] + numbers[index - 2], numbers[index - 1])\r\n\r\n        return numbers[-1]\r\n\r\n\r\nclass Solution:\r\n    def rob(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        if len(numbers) < 3:\r\n            return max(numbers)\r\n\r\n        cache = [0] * len(numbers)\r\n        cache[0] = numbers[0]\r\n        cache[1] = max(numbers[:2])\r\n\r\n        for index in range(2, len(numbers)):\r\n            cache[index] = max(numbers[index] + cache[index - 2], cache[index - 1])\r\n\r\n        return cache[-1]\r\n\r\n\r\nclass Solution:\r\n    def rob(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        memo = {}\r\n\r\n        def dfs(index):\r\n            if index >= len(numbers):\r\n                return 0\r\n            elif index in memo:\r\n                return memo[index]\r\n\r\n            memo[index] = max(numbers[index] + dfs(index + 2), dfs(index + 1))\r\n            return memo[index]\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def rob(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [None] * (len(numbers) + 1)\r\n\r\n        def dfs(index):\r\n            if index >= len(numbers):\r\n                return 0\r\n            elif memo[index] != None:\r\n                return memo[index]\r\n\r\n            memo[index] = max(numbers[index] + dfs(index + 2), dfs(index + 1))\r\n            return memo[index]\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def rob(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        def dfs(index):\r\n            if index >= len(numbers):\r\n                return 0\r\n\r\n            return max(numbers[index] + dfs(index + 2), dfs(index + 1))\r\n\r\n        return dfs(0)", "testcase": "print(Solution().rob([2]), 2)\r\nprint(Solution().rob([0]), 0)\r\nprint(Solution().rob([2, 1]), 2)\r\nprint(Solution().rob([2, 100, 9, 3, 100]), 200)\r\nprint(Solution().rob([100, 9, 3, 100, 2]), 200)\r\nprint(Solution().rob([1, 2, 3, 1]), 4)\r\nprint(Solution().rob([2, 7, 9, 3, 1]), 12)\r\nprint(Solution().rob([183,219,57,193,94,233,202,154,65,240,97,234,100,249,186,66,90,238,168,128,177,235,50,81,185,165,217,207,88,80,112,78,135,62,228,247,211]), 3365)\r\nprint(Solution().rob([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-05-07T22:09:13.846Z", "updated_at": "2025-02-16T10:25:35.509Z"}}, {"model": "python_problems.solution", "pk": 30, "fields": {"problem": 32, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def rob(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        if len(numbers) < 3:\r\n            return max(numbers)\r\n        \r\n        def rob2(numbers):\r\n            if len(numbers) < 3:\r\n                return max(numbers)\r\n            \r\n            cache = [numbers[0], max(numbers[:2])]\r\n\r\n            for index in range(2, len(numbers)):\r\n                cache = [cache[1], max(numbers[index] + cache[0], cache[1])]\r\n\r\n            return cache[1]\r\n\r\n        return max(rob2(numbers[1:]), \r\n                   rob2(numbers[:-1]))\r\n\r\n\r\nclass Solution:\r\n    def rob(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        if len(numbers) < 3:\r\n            return max(numbers)\r\n        \r\n        def rob2(numbers):\r\n            if len(numbers) < 3:\r\n                return max(numbers)\r\n            \r\n            cache = [0] * len(numbers)\r\n            cache[:2] = [numbers[0], max(numbers[:2])]\r\n\r\n            for index in range(2, len(numbers)):\r\n                cache[index] = max(numbers[index] + cache[index - 2], \r\n                                   cache[index - 1])\r\n\r\n            return cache[-1]\r\n\r\n        return max(rob2(numbers[1:]), \r\n                   rob2(numbers[:-1]))", "testcase": "print(Solution().rob([2, 3, 2]), 3)\r\nprint(Solution().rob([1, 2, 3, 1]), 4)\r\nprint(Solution().rob([1, 2, 3]), 3)\r\nprint(Solution().rob([1]), 1)\r\nprint(Solution().rob([0, 0]), 0)\r\nprint(Solution().rob([1, 3, 1, 3, 100]), 103)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-05-11T09:13:50.769Z", "updated_at": "2025-02-16T11:42:01.734Z"}}, {"model": "python_problems.solution", "pk": 31, "fields": {"problem": 33, "language": 1, "owner": 3, "solution": "# O(n2), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def longestPalindrome(self, word):\r\n        start = 0\r\n        palindrome_length = 0\r\n\r\n        for index in range(len(word)):\r\n            # odd length palindrome\r\n            left = index\r\n            right = index\r\n            while (left >= 0 and  # check if not out of bounds left\r\n                   right < len(word) and  # check if not out of bounds right\r\n                   word[left] == word[right]):  # if letter match\r\n                if right - left + 1 > palindrome_length:  # if longer palindrome found\r\n                    palindrome_length = right - left + 1\r\n                    start = left\r\n                \r\n                left -= 1\r\n                right += 1\r\n\r\n            # even lenght palindrome\r\n            left = index\r\n            right = index + 1\r\n            while (left >= 0 and  # check if not out of bounds left\r\n                   right < len(word) and  # check if not out of bounds right\r\n                   word[left] == word[right]):  # if letter match\r\n                if right - left + 1 > palindrome_length:  # if longer palindrome found\r\n                    palindrome_length = right - left + 1\r\n                    start = left\r\n\r\n                left -= 1\r\n                right += 1\r\n\r\n        return word[start: start + palindrome_length]", "testcase": "print(Solution().longestPalindrome(\"babad\"), \"bab\")\r\nprint(Solution().longestPalindrome(\"cbbd\"), \"bb\")\r\nprint(Solution().longestPalindrome(\"a\"), \"a\")\r\nprint(Solution().longestPalindrome(\"\"), \"\")\r\nprint(Solution().longestPalindrome(\"bb\"), \"bb\")\r\nprint(Solution().longestPalindrome(\"ab\"), \"a\")\r\nprint(Solution().longestPalindrome(\"aacabdkacaa\"), \"aca\")\r\nprint(Solution().longestPalindrome(\"abdka\"), \"a\")\r\nprint(Solution().longestPalindrome(\"aaaa\"), \"aaaa\")", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-05-14T20:18:27.692Z", "updated_at": "2025-01-08T08:24:53.058Z"}}, {"model": "python_problems.solution", "pk": 32, "fields": {"problem": 34, "language": 1, "owner": 3, "solution": "# draft\r\n# \"aaa\"\r\n# a aa a aa aaa a \r\n\r\n# O(n2), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def __init__(self):\r\n        self.counter = 0  # count palindroms\r\n\r\n    def count_palindroms(self, left: int, right: int) -> None:\r\n        while (left >= 0 and  # check if not out of bounds left\r\n               right < len(self.word) and  # check if not out of bounds right\r\n               self.word[left] == self.word[right]):  # if letter match\r\n            self.counter += 1  # increase counter\r\n            left -= 1  # move left pointer\r\n            right += 1  # move right pointer\r\n\r\n    def countSubstrings(self, word: str) -> int:\r\n        self.word = word\r\n\r\n        for index in range(len(word)):\r\n            self.count_palindroms(index, index)  # odd length palindromes\r\n            self.count_palindroms(index, index + 1)  # even length palindromes\r\n\r\n        return self.counter", "testcase": "print(Solution().countSubstrings(\"abc\"), 3)\r\nprint(Solution().countSubstrings(\"aaa\"), 6)", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-05-18T07:23:04.615Z", "updated_at": "2025-01-08T09:01:05.316Z"}}, {"model": "python_problems.solution", "pk": 33, "fields": {"problem": 35, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def coinChange(self, coins: list[int], amount: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up with tabulation as list\r\n        \"\"\"\r\n        # min number of coins needed to get target amount (equal to the index)\r\n        # \"anmount + 1\" an imposbile value stays when the last element of min_coins was not modified\r\n        cache = [amount + 1] * (amount + 1)  # cache\r\n        cache[0] = 0  # no coins needed to get 0\r\n\r\n        for index in range(1, amount + 1):  # check each 'cache' index\r\n            for coin in coins:  # check every coin\r\n                if index - coin >= 0:  # target ammount must be greater equal to current coin\r\n                    # choose current amount of coins or get ammount without current coin and add 1\r\n                    cache[index] = min(cache[index], cache[index - coin] + 1)\r\n        \r\n        # if the last value was not modified, there is no valid combination\r\n        return (cache[amount] \r\n                if cache[amount] != amount + 1\r\n                else -1)\r\n\r\n\r\nclass Solution:\r\n    def coinChange(self, coins: list[int], amount: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up with tabulation as hash map\r\n        \"\"\"\r\n        # min number of coins needed to get target amount (equal to the index)\r\n        cache = {0: 0}  # {ammont: min coins to get that amount}\r\n\r\n        for index in range(1, amount + 1):\r\n            for coin in coins:\r\n                if index - coin >= 0:\r\n                    cache[index] = min(cache.get(index, amount + 1), # \"anmount + 1\" an imposbile value stays when the last element of min_coins was not founded\r\n                                       cache.get(index - coin, amount + 1) + 1)\r\n        \r\n        return (cache[amount] \r\n                if (amount in cache and  # if amount exists and\r\n                    cache[amount] != amount + 1)  # the value is not impossible value\r\n                else -1)\r\n\r\n\r\nclass Solution:\r\n    def coinChange(self, coins: list[int], amount: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        base_amount = amount\r\n        memo = {0: 0}  # {ammont: min coins to get that amount}\r\n        \r\n        def dfs(amount):\r\n            if amount < 0:\r\n                return base_amount + 1  # return impossible value\r\n            elif amount in memo:\r\n                return memo[amount]\r\n\r\n            # Calculate the minimum number of coins needed for this amount\r\n            memo[amount] = min(1 + dfs(amount - coin) \r\n                               for coin in coins)\r\n\r\n            return memo[amount]\r\n\r\n        number_of_coins = dfs(amount)\r\n        return (number_of_coins \r\n                if number_of_coins <= amount\r\n                else -1)\r\n\r\n\r\nclass Solution:\r\n    def coinChange(self, coins: list[int], amount: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [None] * (amount + 1)  # [min coins to get index amount]\r\n        memo[0] = 0\r\n        base_amount = amount\r\n        \r\n        def dfs(amount):\r\n            if amount < 0:\r\n                return base_amount + 1\r\n            elif memo[amount] != None:\r\n                return memo[amount]\r\n\r\n            memo[amount] = min(1 + dfs(amount - coin) \r\n                               for coin in coins)\r\n\r\n            return memo[amount]\r\n\r\n        number_of_coins = dfs(amount)\r\n        return (number_of_coins \r\n                if number_of_coins <= amount\r\n                else -1)\r\n\r\n\r\nclass Solution:\r\n    def coinChange(self, coins: list[int], amount: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        O(coins^amount)\r\n        \"\"\"\r\n        base_amount = amount\r\n\r\n        def dfs(amount):\r\n            if amount == 0:\r\n                return 0\r\n            elif amount < 0:\r\n                return base_amount + 1\r\n\r\n            return min(1 + dfs(amount - coin) \r\n                       for coin in coins)\r\n\r\n        number_of_coins = dfs(amount)\r\n        return (number_of_coins \r\n                if number_of_coins <= amount\r\n                else -1)", "testcase": "print(Solution().coinChange([5], 5), 1)\r\nprint(Solution().coinChange([1, 2], 3), 2)\r\nprint(Solution().coinChange([1, 2, 5], 11), 3)\r\nprint(Solution().coinChange([2, 5, 10, 1], 27), 4)\r\nprint(Solution().coinChange([186, 419, 83, 408], 6249), 20)\r\nprint(Solution().coinChange([2], 3), -1)\r\nprint(Solution().coinChange([2], 1), -1)\r\nprint(Solution().coinChange([1], 0), 0)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-05-21T18:27:41.538Z", "updated_at": "2025-02-17T09:57:50.782Z"}}, {"model": "python_problems.solution", "pk": 34, "fields": {"problem": 36, "language": 1, "owner": 3, "solution": "# draft\r\n# [2, 3, -2, 4]\r\n# (2, 2), (3, !2*3!), (-2*6, -2), (-48, -2)\r\n\r\n\r\nclass Solution:\r\n    def maxProduct(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = (1, 1)\r\n        max_product = numbers[0]\r\n\r\n        for number in numbers:\r\n            triplet = (cache[0] * number, \r\n                       cache[1] * number, \r\n                       number)\r\n            cache = (max(triplet), min(triplet))\r\n            max_product = max(max_product, cache[0])\r\n\r\n        return max_product\r\n\r\n\r\nclass Solution:\r\n    def maxProduct(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        mutate input array\r\n        \"\"\"\r\n        max_product = numbers[0]\r\n        \r\n        for index, number in enumerate(numbers):\r\n            if index == 0:\r\n                numbers[0] = (numbers[0], numbers[0])\r\n                continue\r\n\r\n            triplet = (numbers[index - 1][0] * number, \r\n                       numbers[index - 1][1] * number, \r\n                       number)\r\n            numbers[index] = (max(triplet), min(triplet))\r\n            max_product = max(max_product, numbers[index][0])\r\n\r\n        return max_product\r\n\r\n\r\nclass Solution:\r\n    def maxProduct(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down\r\n        single recursive call per index\r\n        \"\"\"\r\n        self.max_product = numbers[0]\r\n        \r\n        def dfs(index):\r\n            if index == len(numbers):\r\n                return (1, 1)\r\n\r\n            next_dfs = dfs(index + 1)\r\n            triplet = (next_dfs[0] * numbers[index], \r\n                       next_dfs[1] * numbers[index], \r\n                       numbers[index])\r\n            \r\n            current_max = max(triplet)\r\n            self.max_product = max(self.max_product, current_max)\r\n\r\n            return (current_max, min(triplet))\r\n\r\n        return max(max(dfs(0)), self.max_product)\r\n\r\n\r\nclass Solution:\r\n    def maxProduct(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2), O(1)\r\n        brute force\r\n        \"\"\"\r\n        max_product = numbers[0]\r\n\r\n        for left in range(len(numbers)):\r\n            val = 1\r\n            for right in range(left, len(numbers)):\r\n                val *= numbers[right]\r\n                max_product = max(max_product, val)\r\n        \r\n        return max_product", "testcase": "print(Solution().maxProduct([-2]), -2)\r\nprint(Solution().maxProduct([-4, -3]), 12)\r\nprint(Solution().maxProduct([2, 3, -2, 4]), 6)\r\nprint(Solution().maxProduct([-2, 0, -1]), 0)\r\nprint(Solution().maxProduct([-2, -3, 7]), 42)\r\nprint(Solution().maxProduct([2, -5, -2, -4, 3]), 24)\r\nprint(Solution().maxProduct([0]), 0)\r\nprint(Solution().maxProduct([-2, 0]), 0)\r\nprint(Solution().maxProduct([0, 2]), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-05-25T05:32:18.461Z", "updated_at": "2025-02-17T14:11:23.133Z"}}, {"model": "python_problems.solution", "pk": 35, "fields": {"problem": 37, "language": 1, "owner": 4, "solution": "             \\ / \\/ \\/ / ,\r\n           \\ /  \\/ \\/  \\/  / ,\r\n         \\ \\ \\/ \\/ \\/ \\ \\/ \\/ /\r\n       .\\  \\/  \\/ \\/ \\/  \\/ / / /\r\n      '  / / \\/  \\/ \\/ \\/  \\/ \\ \\/ \\\r\n   .'     ) \\/ \\/ \\/ \\/  \\/  \\/ \\ / \\\r\n  /   o    ) \\/ \\/ \\/ \\/ \\/ \\/ \\// /\r\no'_ ',__ .'   ,.,.,.,.,.,.,.,'- '%\r\n         // \\\\          // \\\\       \r\n        ''  ''         ''  ''", "testcase": "(Solution().hedgehog(), 0)", "time_complexity": 1, "space_complexity": 1, "created_at": "2024-05-28T16:36:55.384Z", "updated_at": "2024-05-28T16:36:55.384Z"}}, {"model": "python_problems.solution", "pk": 36, "fields": {"problem": 38, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def wordBreak(self, text: str, word_list: list[str]) -> bool:\r\n        \"\"\"\r\n        O(n3), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        # cache where each elemet tells if sentece can be fold from this index to the right\r\n        cache = [False] * (len(text) + 1)  # can fold\r\n        cache[-1] = True  # dummy element tells that everything after \"text can be folded\"\r\n        word_set = set(word_list)\r\n\r\n        for index in reversed(range(len(text))):  # go through every index reversed\r\n            for word in word_set:  # go through every word\r\n                if text[index: index + len(word)] == word:  # if found the word\r\n                    cache[index] = (cache[index] or  # if already can fold\r\n                                       cache[index + len(word)])  # update can fold\r\n                if cache[index]:  # early exit\r\n                    break\r\n        return cache[0]\r\n\r\n\r\nclass Solution:\r\n    def wordBreak(self, text: str, word_list: list[str]) -> bool:\r\n        \"\"\"\r\n        O(n3), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        memo = {len(text): True}\r\n        word_set = set(word_list)\r\n\r\n        def dfs(index):\r\n            if index in memo:\r\n                return memo[index]\r\n            \r\n            for word in word_set:\r\n                if (text[index: index + len(word)] == word and\r\n                        dfs(index + len(word))):\r\n                    memo[index] = True\r\n                    return True\r\n            \r\n            memo[index] = False\r\n            return False\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def wordBreak(self, text: str, word_list: list[str]) -> bool:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        word_set = set(word_list)\r\n\r\n        def dfs(index):\r\n            if index == len(text):\r\n                return True\r\n            \r\n            for word in word_set:\r\n                if (text[index: index + len(word)] == word and\r\n                        dfs(index + len(word))):\r\n                    return True\r\n\r\n            return False\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass TrieNode:\r\n    def __init__(self):\r\n        # Each TrieNode contains a dictionary of children and a boolean to indicate if it's the end of a word.\r\n        self.children = {}\r\n        self.is_word = False\r\n\r\nclass Trie:\r\n    def __init__(self) -> None:\r\n        # Initialize the Trie with a root node.\r\n        self.root = TrieNode()\r\n\r\n    def insert(self, word: str) -> None:\r\n        # Inserts a word into the Trie.\r\n        node = self.root\r\n        for letter in word:\r\n            if letter not in node.children:\r\n                # If the letter is not in children, create a new TrieNode.\r\n                node.children[letter] = TrieNode()\r\n            # Move to the child node.\r\n            node = node.children[letter]\r\n        # Mark the end of the word.\r\n        node.is_word = True\r\n\r\n    def search(self, text: str, start: int, end: int) -> bool:\r\n        # Checks if the substring `text[start:end+1]` exists in the Trie.\r\n        node = self.root\r\n        for letter in text[start: end + 1]:\r\n            if letter not in node.children:\r\n                # If a letter is not found in the children, return False.\r\n                return False\r\n            # Move to the child node.\r\n            node = node.children[letter]\r\n        # Return True if the substring is a complete word in the Trie.\r\n        return node.is_word\r\n\r\nclass Solution:\r\n    def wordBreak(self, text: str, word_list: list[str]) -> bool:\r\n        \"\"\"\r\n        O(n3), O(n2)\r\n        dp, bottom-up, trie\r\n\r\n        Determines if the string `text` can be segmented into words from `word_list`.\r\n\r\n        Args:\r\n        text (str): The input string.\r\n        word_list (list[str]): List of valid words.\r\n\r\n        Returns:\r\n        bool: True if `text` can be segmented, False otherwise.\r\n        \"\"\"\r\n        # Cache stores whether `text[i:]` can be segmented (True or False).\r\n        cache = [False] * (len(text) + 1)\r\n        cache[-1] = True  # Base case: empty string is always segmentable.\r\n        \r\n        max_word_len = 0  # Track the length of the longest word in `word_list`.\r\n        trie = Trie()\r\n        \r\n        # Insert all words into the Trie and update the max word length.\r\n        for word in word_list:\r\n            trie.insert(word)\r\n            max_word_len = max(max_word_len, len(word))\r\n\r\n        # Iterate over the text from right to left.\r\n        for left in reversed(range(len(text))):\r\n            # Check substrings starting from the current position.\r\n            for right in range(left, min(len(text), left + max_word_len)):\r\n                # If a substring exists in the Trie and the rest of the string can be segmented.\r\n                if trie.search(text, left, right):\r\n                    cache[left] = cache[right + 1]\r\n                if cache[left]:\r\n                    # Stop checking further substrings if segmentation is already confirmed.\r\n                    break\r\n\r\n        # Return whether the entire string can be segmented.\r\n        return cache[0]", "testcase": "print(Solution().wordBreak(\"leetcode\", [\"leet\", \"code\"]), True)\r\nprint(Solution().wordBreak(\"applepenapple\", [\"apple\",\"pen\"]), True)\r\nprint(Solution().wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]), False)\r\nprint(Solution().wordBreak(\"cars\", [\"car\", \"ca\", \"rs\"]), True)\r\nprint(Solution().wordBreak(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\", [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]), False)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-06-01T03:41:32.307Z", "updated_at": "2025-02-17T20:08:44.405Z"}}, {"model": "python_problems.solution", "pk": 37, "fields": {"problem": 39, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n[10, 9, 2, 5, 3, 7, 101, 18]\r\n[1, 1, 1, 2, 2, max(2,2)+1=3, 4, 1]\r\n                 .\r\n        /               \\\r\n        2               .\r\n      /   \\           /   \\\r\n     8    .          8     .\r\n    / \\  / \\        / \\   / \\\r\n   4  . 4   .      4  .  4   .\r\n  /\\ /\\ /\\  /\\    /\\  /\\ /\\  /\\\r\n  5. 5. 5.  5.    5.  5.  5.  5.\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def lengthOfLIS(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up with cache as list\r\n        \"\"\"\r\n        cache = [1] * len(numbers)\r\n\r\n        for right in range(len(numbers)):  # check every right (index)\r\n            for left in range(right):  # check every left (index) lower than right\r\n                if numbers[left] < numbers[right]:  # if right number is greater\r\n                    cache[right] = max(cache[right], cache[left] + 1)  # update LIS lengths \r\n\r\n        return max(cache)\r\n\r\n\r\nclass Solution:\r\n    def lengthOfLIS(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up with cache as hash map\r\n        \"\"\"\r\n        cache = {}  # LIS lengths\r\n\r\n        for right in range(len(numbers)):  # check every right (index)\r\n            cache[numbers[right]] = 1  # add current element to cache\r\n            \r\n            for left_val in cache.keys():  # check every left_val (index) of cache\r\n                if left_val < numbers[right]:  # if right number is greater\r\n                    cache[numbers[right]] = max(cache[numbers[right]], \r\n                                                cache[left_val] + 1)  # update LIS lengths \r\n\r\n        return max(cache.values())\r\n\r\n\r\nclass Solution:\r\n    def lengthOfLIS(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map, mle\r\n        \"\"\"\r\n        memo = {}\r\n\r\n        def dfs(index, prev_index):\r\n            if index == len(numbers):\r\n                return 0\r\n            elif (index, prev_index) in memo:\r\n                return memo[(index, prev_index)]\r\n\r\n            # Try skipping numbers[index]\r\n            longest = dfs(index + 1, prev_index)\r\n            \r\n            # Try including numbers[index] if it maintains an increasing order\r\n            if (prev_index == -1 or \r\n                    numbers[index] > numbers[prev_index]):\r\n                longest = max(longest, 1 + dfs(index + 1, index))\r\n\r\n            memo[(index, prev_index)] = longest\r\n            return longest\r\n\r\n        return dfs(0, -1)\r\n\r\n\r\nclass Solution:\r\n    def lengthOfLIS(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, pure recursion, tle, mle\r\n        converts to top-down\r\n        \"\"\"\r\n\r\n        def dfs(index, prev_index):\r\n            if index == len(numbers):\r\n                return 0\r\n\r\n            # Try skipping numbers[index]\r\n            longest = dfs(index + 1, prev_index)\r\n            \r\n            # Try including numbers[index] if it maintains an increasing order\r\n            if (prev_index == -1 or \r\n                    numbers[index] > numbers[prev_index]):\r\n                longest = max(longest, 1 + dfs(index + 1, index))\r\n\r\n            return longest\r\n\r\n        return dfs(0, -1)\r\n\r\n\r\nclass Solution:\r\n    def lengthOfLIS(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, function argument, tle\r\n        \"\"\"\r\n        self.longest = 0\r\n        \r\n        def dfs(index, subsequence):\r\n            if index == len(numbers):\r\n                self.longest = max(self.longest, len(subsequence))\r\n                return\r\n\r\n            # Try including numbers[index] if it maintains an increasing order\r\n            if not subsequence or subsequence[-1] < numbers[index]:\r\n                dfs(index + 1, subsequence + [numbers[index]])\r\n            \r\n            # Try skipping numbers[index]\r\n            dfs(index + 1, subsequence)\r\n\r\n        dfs(0, [])\r\n        return self.longest\r\n\r\n\r\nclass Solution:\r\n    def lengthOfLIS(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2^n), O(n)\r\n        brute force, backtracking, tle\r\n        \"\"\"\r\n        self.counter = 1\r\n        subsequence = []\r\n\r\n        def dfs(index):\r\n            if index == len(numbers):\r\n                if len(subsequence) > 1:\r\n                    for ind in range(len(subsequence) - 1):\r\n                        if subsequence[ind] >= subsequence[ind + 1]:\r\n                            return\r\n                    self.counter = max(self.counter, len(subsequence))\r\n                return\r\n\r\n            subsequence.append(numbers[index])\r\n            dfs(index + 1)\r\n            subsequence.pop()\r\n            dfs(index + 1)\r\n\r\n        dfs(0)\r\n        return self.counter", "testcase": "print(Solution().lengthOfLIS([5]), 1)\r\nprint(Solution().lengthOfLIS([5, 6]), 2)\r\nprint(Solution().lengthOfLIS([5, 4]), 1)\r\nprint(Solution().lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]), 4)\r\nprint(Solution().lengthOfLIS([0, 1, 0, 3, 2, 3]), 4)\r\nprint(Solution().lengthOfLIS([7, 7, 7, 7, 7, 7, 7]), 1)\r\nprint(Solution().lengthOfLIS([4, 10, 4, 3, 8, 9]), 3)\r\nprint(Solution().lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]), 6)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-06-04T14:46:09.230Z", "updated_at": "2025-02-18T08:23:12.379Z"}}, {"model": "python_problems.solution", "pk": 38, "fields": {"problem": 40, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n                  .\r\n            /           \\\r\n           1            .\r\n         /    \\       /    \\\r\n        5     .       5     .\r\n       /\\     /\\     /\\    /\\\r\n      11 .   11 .   11 .  11 .\r\n    /\\\r\n   5 .\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def canPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        total = sum(numbers)\r\n        if total % 2:  # if odd sum (cannot be split in half)\r\n            return False\r\n        half = total // 2  # half of the sum\r\n        subset = set({0})  # set with addition neutral element\r\n\r\n        for number in numbers:\r\n            subset.update({val + number  # update every val in subset with (val + number), but preserve orginal vals\r\n                           for val in subset.copy()})\r\n            subset.add(number)\r\n\r\n            if half in subset:\r\n                return True\r\n\r\n        return False\r\n\r\n\r\nclass Solution:\r\n    def canPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        total = sum(numbers)\r\n        if total % 2:  # if odd sum (cannot be split in half)\r\n            return False\r\n\r\n        memo = {}  # {(index, target): bool}\r\n        \r\n        def dfs(index: int, target: int) -> bool:\r\n            if (index, target) in memo:\r\n                return memo[(index, target)]\r\n            elif target <= 0:\r\n                return target == 0\r\n            elif index == len(numbers):\r\n                return False\r\n\r\n            memo[(index, target)] = (dfs(index + 1, target - numbers[index]) or \r\n                                     dfs(index + 1, target))\r\n            return memo[(index, target)]\r\n\r\n        return dfs(0, total // 2)\r\n\r\n\r\nclass Solution:\r\n    def canPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, pure recursion, tle\r\n        converts to top-down\r\n        \"\"\"\r\n        total = sum(numbers)\r\n        if total % 2:  # if odd sum (cannot be split in half)\r\n            return False\r\n\r\n        def dfs(index: int, target: int) -> bool:\r\n            if target <= 0:\r\n                return target == 0\r\n            elif index == len(numbers):\r\n                return False\r\n        \r\n            return (dfs(index + 1, target - numbers[index]) or\r\n                    dfs(index + 1, target))\r\n\r\n        return dfs(0, total // 2)\r\n\r\n\r\nclass Solution:\r\n    def canPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, backtracking, tle\r\n        \"\"\"\r\n        total = sum(numbers)\r\n        if total % 2:\r\n            return False\r\n        half = total // 2\r\n        subset = []\r\n\r\n        def dfs(index: int) -> bool:\r\n            if sum(subset) == half:\r\n                return True\r\n            elif (index == len(numbers) or\r\n                  sum(subset) > half):\r\n                return\r\n\r\n            subset.append(numbers[index])\r\n            if dfs(index + 1):\r\n                return True\r\n            subset.pop()\r\n            if dfs(index + 1):\r\n                return True\r\n\r\n            return False\r\n\r\n        return dfs(0)", "testcase": "print(Solution().canPartition([2]), False)\r\nprint(Solution().canPartition([2, 2]), True)\r\nprint(Solution().canPartition([1, 5, 11, 5]), True)\r\nprint(Solution().canPartition([14, 9, 8, 4, 3, 2]), True)\r\nprint(Solution().canPartition([1, 2, 5]), False)\r\nprint(Solution().canPartition([3, 3, 3, 4, 5]), True)\r\nprint(Solution().canPartition([1, 2, 3, 5]), False)\r\nprint(Solution().canPartition([1]), False)\r\nprint(Solution().canPartition([2, 2, 1, 1]), True)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-06-08T01:50:46.153Z", "updated_at": "2025-02-18T11:33:06.666Z"}}, {"model": "python_problems.solution", "pk": 39, "fields": {"problem": 41, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\r\n        # dp = [[0] * (len(text1) + 1)] * (len(text2) + 1)  creates a list of lists where each sublist is a reference to the same list. This means that updating one element in any sublist will affect all sublists.\r\n        dp = [[0] * (len(text1) + 1) for _ in range(len(text2) + 1)]\r\n\r\n        for i in range(len(text2))[::-1]:\r\n            for j in range(len(text1))[::-1]:\r\n                if text2[i] == text1[j]:\r\n                    dp[i][j] = dp[i + 1][j + 1] + 1\r\n                else:\r\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j + 1])\r\n\r\n        return dp[0][0]", "testcase": "(Solution().longestCommonSubsequence(\"abcde\", \"ace\"), 3)\r\n(Solution().longestCommonSubsequence(\"abc\", \"abc\"), 3)\r\n(Solution().longestCommonSubsequence(\"abc\", \"dew\"), 0)\r\n(Solution().longestCommonSubsequence(\"bsbininm\", \"jmjkbkjkv\"), 1)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-06-11T12:55:23.076Z", "updated_at": "2024-06-11T12:55:23.076Z"}}, {"model": "python_problems.solution", "pk": 40, "fields": {"problem": 42, "language": 1, "owner": 3, "solution": "# for [-2, 1, -3, 4, -1, 2, 1, -5, 4]\r\n# cummulative sum [-2, 1, -2, 4, 3, 5, 6, 1, 4]\r\n\r\n# dp, bottom up, dp list => 2 variables: cumulative, maxSum\r\n# O(n), O(1)\r\nclass Solution:\r\n    def maxSubArray(self, nums: list[int]) -> int:\r\n        nums_len = len(nums)\r\n        cumulative = nums[0]  # in case of all negative values cannot take \"0\" as a base\r\n        max_value = nums[0]  # in case of all negative values cannot take \"0\" as a base\r\n\r\n        for index in range(1, nums_len):\r\n            cumulative = max(cumulative, 0) + nums[index]  # keep track of the cumulative sum or start a new one if below zero\r\n            max_value = max(cumulative, max_value)  # keep track of the highest value\r\n\r\n        return max_value\r\n\r\n\r\n# dp, bottom up, use nums as dp\r\n# O(n), O(n)\r\nclass Solution:\r\n    def maxSubArray(self, nums: list[int]) -> int:\r\n        for index in range(1, len(nums)):\r\n            nums[index] += max(nums[index - 1], 0)  # add another element to sum or start a new one\r\n\r\n        return max(nums)\r\n\r\n\r\n# dp, bottom up\r\n# O(n), O(n)\r\nclass Solution:\r\n    def maxSubArray(self, nums: list[int]) -> int:\r\n        nums_len = len(nums)\r\n        dp = [0 for _ in range(nums_len)]  # for cumulative sum\r\n        dp[0] = nums[0]  # in case of all negative values cannot take \"0\" as a base\r\n\r\n        for index in range(1, nums_len):\r\n            dp[index] = max(dp[index - 1], 0) + nums[index]  # add another element to sum or start a new one\r\n        \r\n        return max(dp)", "testcase": "(Solution().maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]), 6)\r\n(Solution().maxSubArray([1]), 1)\r\n(Solution().maxSubArray([5, 4, -1, 7, 8]), 23)\r\n(Solution().maxSubArray([-4, -2, -1, -3]), -1)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-06-15T00:00:00Z", "updated_at": "2024-09-08T12:46:28.431Z"}}, {"model": "python_problems.solution", "pk": 41, "fields": {"problem": 1, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[]}\r\n*/\r\n// Using Plain Object:\r\nvar twoSum = (nums, target) => {\r\n  const seen = {}\r\n  const numsLength = nums.length\r\n\r\n  for (let index = 0; index < numsLength; index++) {\r\n    let num = nums[index];\r\n    let diff = target - num;\r\n\r\n    if (diff in seen) {\r\n      return [seen[diff], index];\r\n    } else {\r\n      seen[num] = index;\r\n    };\r\n  };\r\n\r\n  return [-1, -1]\r\n};\r\n\r\n\r\n// Using Map:\r\nvar twoSum = (nums, target) => {\r\n  const seen = new Map()\r\n  const numsLength = nums.length;\r\n\r\n  for (let index = 0; index < numsLength; index++) {\r\n    const num = nums[index];\r\n    const diff = target - num;\r\n\r\n    if (seen.has(diff)) {\r\n      return [seen.get(diff), index];\r\n    } else {\r\n      seen.set(num, index);\r\n    };\r\n  };\r\n\r\n  return [-1, -1]\r\n};", "testcase": "(twoSum([2, 7, 11, 15], 9), [0, 1])\r\n(twoSum([3, 2, 4], 6), [1, 2])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-06-18T19:46:11.822Z", "updated_at": "2024-08-19T14:57:02.251Z"}}, {"model": "python_problems.solution", "pk": 42, "fields": {"problem": 46, "language": 3, "owner": 3, "solution": "import pandas as pd\r\n\r\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\r\n    sol_df = pd.merge(person, address, how=\"left\", on=[\"personId\"])\r\n    return sol_df[[\"firstName\", \"lastName\", \"city\", \"state\"]]", "testcase": "", "time_complexity": 4, "space_complexity": 2, "created_at": "2024-06-20T12:36:13.464Z", "updated_at": "2024-06-20T12:36:13.469Z"}}, {"model": "python_problems.solution", "pk": 43, "fields": {"problem": 46, "language": 4, "owner": 3, "solution": "SELECT firstName, lastName, city, state\r\nFROM Person\r\nLEFT JOIN Address USING(personId)", "testcase": "", "time_complexity": 4, "space_complexity": 2, "created_at": "2024-06-20T12:37:23.043Z", "updated_at": "2024-06-20T12:37:23.052Z"}}, {"model": "python_problems.solution", "pk": 44, "fields": {"problem": 46, "language": 5, "owner": 3, "solution": "SELECT firstName, lastName, city, state\r\nFROM Person\r\nLEFT JOIN Address USING(personId)", "testcase": "", "time_complexity": 4, "space_complexity": 2, "created_at": "2024-06-20T12:38:26.176Z", "updated_at": "2024-06-20T12:38:26.186Z"}}, {"model": "python_problems.solution", "pk": 46, "fields": {"problem": 37, "language": 1, "owner": 3, "solution": "888                  888                888                      \r\n888                  888                888                      \r\n888                  888                888                      \r\n88888b.  .d88b.  .d88888 .d88b.  .d88b. 88888b.  .d88b.  .d88b.  \r\n888 \"88bd8P  Y8bd88\" 888d88P\"88bd8P  Y8b888 \"88bd88\"\"88bd88P\"88b \r\n888  88888888888888  888888  88888888888888  888888  888888  888 \r\n888  888Y8b.    Y88b 888Y88b 888Y8b.    888  888Y88..88PY88b 888 \r\n888  888 \"Y8888  \"Y88888 \"Y88888 \"Y8888 888  888 \"Y88P\"  \"Y88888 \r\n                             888                             888 \r\n                        Y8b d88P                        Y8b d88P \r\n                         \"Y88P\"                          \"Y88P\"", "testcase": "(Solution().hedgehog(\"needle\"), \"haystack\")", "time_complexity": 1, "space_complexity": 1, "created_at": "2024-06-21T21:13:10.816Z", "updated_at": "2024-06-21T21:17:30.344Z"}}, {"model": "python_problems.solution", "pk": 47, "fields": {"problem": 47, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def search(self, nums: list[int], target: int):\r\n        left = 0\r\n        right = len(nums) - 1\r\n\r\n        while left <= right:  # two poionters\r\n            mid = (left + right) // 2  # find mid index\r\n            \r\n            if target == nums[mid]:  # if target found\r\n                return mid\r\n            elif target < nums[mid]:  # if target is less than middle, choose left chunk\r\n                right = mid - 1\r\n            else:  # if target is greater than middle, choose rigth chunk\r\n                left = mid + 1\r\n        \r\n        return -1", "testcase": "(Solution().search([-1, 0, 3, 5, 9, 12], -1), 0)\r\n(Solution().search([-1, 0, 3, 5, 9, 12], 0), 1)\r\n(Solution().search([-1, 0, 3, 5, 9, 12], 3), 2)\r\n(Solution().search([-1, 0, 3, 5, 9, 12], 5), 3)\r\n(Solution().search([-1, 0, 3, 5, 9, 12], 9), 4)\r\n(Solution().search([-1, 0, 3, 5, 9, 12], 12), 5)\r\n(Solution().search([-1, 0, 3, 5, 9, 12], 2), -1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-07-16T20:35:18.849Z", "updated_at": "2024-08-25T11:12:31.682Z"}}, {"model": "python_problems.solution", "pk": 48, "fields": {"problem": 48, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def searchMatrix(self, matrix, target):\r\n        top = 0  # boundries\r\n        bottom = len(matrix) - 1\r\n        left = 0\r\n        right = len(matrix[0]) - 1\r\n\r\n        while top <= bottom:  # two poionters to find the right row\r\n            mid_row = (top + bottom) // 2  # find middle row index\r\n\r\n            if (target >= matrix[mid_row][left] and\r\n                    target <= matrix[mid_row][right]):  # if target row found\r\n                break\r\n            elif target < matrix[mid_row][left]:  # if target is less than the most left, choose top chunk\r\n                bottom = mid_row - 1\r\n            else:  # if target is grater than the most right, choose bottom chunk\r\n                top = mid_row + 1\r\n\r\n        while left <= right:  # two poionters to find the right column\r\n            mid_col = (left + right) // 2# find middle column index\r\n\r\n            if target == matrix[mid_row][mid_col]:  # if target column found\r\n                return True\r\n            elif target < matrix[mid_row][mid_col]:  # if target is less than middle colum, choose left chunk\r\n                right = mid_col - 1\r\n            else:  # if target is greater than middle colum, choose rigth chunk\r\n                left = mid_col + 1\r\n\r\n        return False", "testcase": "(Solution().searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 3), True)\r\n(Solution().searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 13), False)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-07-22T21:18:27.473Z", "updated_at": "2024-08-25T11:16:19.866Z"}}, {"model": "python_problems.solution", "pk": 49, "fields": {"problem": 49, "language": 1, "owner": 3, "solution": "# O(nlogn), O(1)\r\n# Binary search\r\nimport numpy as np\r\n\r\nclass Solution:\r\n    def minEatingSpeed(self, piles: list[int], hours: int) -> int:\r\n        left = 1  # eat one banana per hour\r\n        right = max(piles)  # eat `tallest pile` per hour\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n\r\n            eat_time = sum(int(np.ceil(number / middle)) for number in piles)  # time to eat all bananas\r\n            # eat_time = sum(int((number - 1) // middle) + 1 for number in piles)  # way to celi wihout numpy\r\n            \r\n            if eat_time <= hours:  # enought time to eat all bananas, check for a better solution\r\n                current_eat_time = middle  # save current banana per hour time\r\n                right = middle - 1  # eat slower\r\n            else:  # not enough time to eat all bananas need to increase middle\r\n                left = middle + 1  # eat faster\r\n        \r\n        return current_eat_time\r\n\r\n\r\n# Brute force\r\n# Time Limit Exceeded\r\nclass Solution:\r\n    def minEatingSpeed(self, piles: list[int], h: int) -> int:\r\n        k = 1\r\n\r\n        while sum(number // k if not number % k else (number // k) + 1 for number in piles) > h:\r\n            k += 1\r\n        \r\n        return k", "testcase": "(Solution().minEatingSpeed([3, 6, 7, 11], 8), 4)\r\n(Solution().minEatingSpeed([30, 11, 23, 4, 20], 5), 30)\r\n(Solution().minEatingSpeed([30, 11, 23, 4, 20], 6), 23)\r\n(Solution().minEatingSpeed([312884470], 312884469), 2)\r\n(Solution().minEatingSpeed([3], 2), 2)", "time_complexity": 5, "space_complexity": 1, "created_at": "2024-07-22T23:45:10.678Z", "updated_at": "2024-11-26T13:43:31.309Z"}}, {"model": "python_problems.solution", "pk": 50, "fields": {"problem": 50, "language": 1, "owner": 3, "solution": "# if middle < right: right portion is contiguous\r\n# 1, 2, 3, 4, 5\r\n# 4, 5, 1, 2, 3\r\n# 5, 1, 2, 3, 4\r\n\r\n# 2, 3, 4, 5, 1\r\n# 3, 4, 5, 1, 2\r\n\r\n\r\n# O(logn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def search(self, numbers: list[int], target: int) -> int:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n            middle_number = numbers[middle]\r\n\r\n            if middle_number == target:\r\n                return middle\r\n            elif middle_number < numbers[right]:  # contiguous right side portion\r\n                if target > middle_number and target <= numbers[right]:  # target in the right side\r\n                    left = middle + 1\r\n                else:\r\n                    right = middle - 1  # tagget in the left side\r\n            else:  # contiguous left side portion\r\n                if target >= numbers[0] and target < middle_number:\r\n                    right = middle - 1  # tagget in the left side\r\n                else:\r\n                    left = middle + 1  # target in the right side\r\n\r\n        return -1", "testcase": "(Solution().search([4, 5, 6, 7, 8, 1, 2, 3], 8), 4)\r\n(Solution().search([1, 3, 5], 5), 2)\r\n(Solution().search([3, 5, 1], 3), 0)\r\n(Solution().search([3, 5, 1], 1), 2)\r\n(Solution().search([5, 1, 3], 3), 2)\r\n(Solution().search([4, 5, 6, 7, 0, 1, 2], 0), 4)\r\n(Solution().search([4, 5, 6, 7, 0, 1, 2], 3), -1)\r\n(Solution().search([1], 0), -1)\r\n(Solution().search([5, 1, 3], 4), -1)\r\n(Solution().search([4, 5, 6, 7, 8, 1, 2, 3], 8), 4)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-07-23T19:51:41.323Z", "updated_at": "2024-11-26T20:53:36.574Z"}}, {"model": "python_problems.solution", "pk": 51, "fields": {"problem": 51, "language": 1, "owner": 3, "solution": "# using set\r\nclass Solution:\r\n    # validating sub-box\r\n    def is_subbox_valid(self, row, col):\r\n        seen = set()\r\n\r\n        for r in range(3):\r\n            for c in range(3):\r\n                digit = self.board[r + row][c + col]\r\n\r\n                if digit != \".\":\r\n                    if digit in seen:\r\n                        return False\r\n                    else:\r\n                        seen.add(digit)\r\n        return True\r\n\r\n    def isValidSudoku(self, board):\r\n        self.board = board\r\n\r\n        rows = len(board)\r\n        cols = len(board[0])\r\n\r\n        # validating rows\r\n        for row in board:\r\n            seen = set()\r\n\r\n            for digit in row:\r\n                if digit != \".\":\r\n                    if digit in seen:\r\n                        return False\r\n                    else:\r\n                        seen.add(digit)\r\n\r\n        # validating columns\r\n        for col in range(cols):\r\n            seen = set()\r\n\r\n            for row in range(rows):\r\n                digit = board[row][col]\r\n\r\n                if digit != \".\":\r\n                    if digit in seen:\r\n                        return False\r\n                    else:\r\n                        seen.add(digit)\r\n\r\n        # validating sub-boxes\r\n        for row in range(0, 3*3, 3):\r\n            for col in range(0, 3*3, 3):\r\n                if not self.is_subbox_valid(row, col):\r\n                    return False\r\n\r\n        return True\r\n\r\n\r\n# using defaultdict(set) form collections\r\nfrom collections import defaultdict\r\nclass Solution:\r\n    def isValidSudoku(self, board: list[list[str]]) -> bool:\r\n        row_uniq = defaultdict(set)\r\n        col_uniq = defaultdict(set)\r\n        box_uniq = defaultdict(set)\r\n\r\n        for row in range(len(board)):\r\n            for col in range(len(board[0])):\r\n                element = board[row][col]\r\n\r\n                if element != \".\":\r\n                    if (element in row_uniq[row]\r\n                        or element in col_uniq[col]\r\n                        or element in box_uniq[(row//3, col//3)]\r\n                    ):\r\n                        return False\r\n                    else:\r\n                        row_uniq[row].add(element)\r\n                        col_uniq[col].add(element)\r\n                        box_uniq[((row//3, col//3))].add(element)\r\n\r\n        return True", "testcase": "(Solution().isValidSudoku([[\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"], [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"], [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"], [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"], [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"], [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"], [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"], [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"], [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]], ), True)\r\n(Solution().isValidSudoku([[\"8\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"], [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"], [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"], [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"], [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"], [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"], [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"], [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"], [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]]), False)\r\n(Solution().isValidSudoku([[\".\", \".\", \".\", \".\", \"5\", \".\", \".\", \"1\", \".\"], [\".\", \"4\", \".\", \"3\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \".\", \".\", \"3\", \".\", \".\", \"1\"],  [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \"2\", \".\"],  [\".\", \".\", \"2\", \".\", \"7\", \".\", \".\", \".\", \".\"],  [\".\", \"1\", \"5\", \".\", \".\", \".\", \".\", \".\", \".\"],  [\".\", \".\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\"],  [\".\", \"2\", \".\", \"9\", \".\", \".\", \".\", \".\", \".\"],  [\".\", \".\", \"4\", \".\", \".\", \".\", \".\", \".\", \".\"]]), False)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-07-24T22:33:21.696Z", "updated_at": "2024-08-22T16:30:14.926Z"}}, {"model": "python_problems.solution", "pk": 52, "fields": {"problem": 52, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# using 3 loops\r\nclass Solution:\r\n    def productExceptSelf(self, nums: list[int]) -> list[int]:\r\n        left_prod_cum = [1] * len(nums)  # prefix\r\n        right_prod_cum = [1] * len(nums)  # postfix\r\n\r\n        # cummulative prod from left\r\n        for ind, num in enumerate(nums[:-1], 1):\r\n            left_prod_cum[ind] = left_prod_cum[ind - 1] * num\r\n\r\n        # cummulative prod from right\r\n        for ind, num in enumerate(nums[1:][::-1], 1):\r\n            right_prod_cum[len(nums) - 1 - ind] = right_prod_cum[len(nums) - ind] * num\r\n\r\n        return [left_prod_cum[i] * right_prod_cum[i] for i in range(len(nums))]\r\n\r\n\r\n\"\"\"\r\nsolution draft\r\n[(1) * 3*4*5=60, 2 * 4*5=40, 2*3 * 5=30, 2*3*4 * (1)=24]\r\ncummulative prod\r\nfrom left\r\nall elements\r\n[2, 2*3=6, 2*3*4=24, 2*3*4*5=120]\r\nwithout the last element\r\n[1, 2, 6, 24]\r\nfrom right\r\nall elements\r\n[2*3*4*5=120, 3*4*5=60, 4*5=20, 5]\r\nwithout the first element\r\n[60, 20, 5, 1]\r\n\"\"\"\r\n\r\n\r\n# O(n), O(n)\r\n# using 2 loops, memory: one list\r\nclass Solution:\r\n    def productExceptSelf(self, nums: list[int]) -> list[int]:\r\n        left_prod_cum = 1\r\n        right_prod_cum = [1] * len(nums)\r\n\r\n        # cummulative prod from right\r\n        for ind, num in enumerate(nums[1:][::-1], 1):\r\n            right_prod_cum[len(nums) - 1 - ind] = right_prod_cum[len(nums) - ind] * num\r\n\r\n        # cummulative prod from left\r\n        for ind, num in enumerate(nums[:-1]):\r\n            # append cum prod from right in this loop\r\n            right_prod_cum[ind] *= left_prod_cum\r\n            left_prod_cum *= num\r\n\r\n        # append the last left_prod_cum\r\n        right_prod_cum[-1] = left_prod_cum\r\n\r\n        return right_prod_cum\r\n\r\n\r\n# O(n2), O(n)\r\nimport numpy as np\r\n\r\nclass Solution:\r\n    def productExceptSelf(self, nums: list[int]) -> list[int]:\r\n        return [np.prod(nums[:i]) * np.prod(nums[i + 1:]) for i in range(len(nums))]", "testcase": "(Solution().productExceptSelf([2, 3, 4, 5]), [60, 40, 30, 24])\r\n(Solution().productExceptSelf([1, 2, 3, 4]), [24, 12, 8, 6])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-07-25T15:09:57.269Z", "updated_at": "2024-07-25T19:59:10.787Z"}}, {"model": "python_problems.solution", "pk": 53, "fields": {"problem": 53, "language": 1, "owner": 3, "solution": "class Solution:\r\n    \"\"\"\r\n    @param: strs: a list of strings\r\n    @return: encodes a list of strings to a single string.\r\n    \"\"\"\r\n\r\n    def encode(self, words):\r\n        encoded = \"\"\r\n        \r\n        for word in words:\r\n            encoded += \"\"\r\n            encoded += str(len(word))\r\n            encoded += word\r\n\r\n        return encoded\r\n\r\n    \"\"\"\r\n    @param: str: A string\r\n    @return: decodes a single string to a list of strings\r\n    \"\"\"\r\n\r\n    def decode(self, word):\r\n        decoded = []\r\n        \r\n        while word:\r\n            if word[0] == \"\":\r\n                word = word[1:]\r\n                length = \"\"\r\n                \r\n                while word and word[0].isdigit():\r\n                    length += word[0]\r\n                    word = word[1:]\r\n\r\n                length = int(length)\r\n                decoded.append(word[:length])\r\n                word = word[length:]\r\n        \r\n        return decoded", "testcase": "(Solution().encode([\"code\", \"site\", \"love\", \"you\"]), \"4code4site4love3you\")\r\n(Solution().decode(Solution().encode([\"code\", \"site\", \"love\", \"you\"])), [\"code\", \"site\", \"love\", \"you\"])\r\n(Solution().decode(Solution().encode([])), [])\r\n(Solution().decode(Solution().encode([\"\"])), [\"\"])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-07-25T22:40:14.485Z", "updated_at": "2024-08-21T20:41:25.348Z"}}, {"model": "python_problems.solution", "pk": 54, "fields": {"problem": 54, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def characterReplacement(self, word: str, joker: int) -> int:\r\n        left = 0  # left pointer\r\n        window = {}  # sliding window as hash map\r\n        longest = 0  # length of the longest substring meeting conditions\r\n        max_count = 0  # most frequent character counter\r\n\r\n        for right, letter in enumerate(word):  # right pointer\r\n            window[letter] = window.get(letter, 0) + 1  # update window\r\n            max_count = max(max_count, window[letter])  # add new letter to window\r\n            \r\n            while (right - left + 1) - max_count > joker:  # while too many characters to change\r\n                window[word[left]] -= 1  # remove \"left\" character from the window\r\n                left += 1  # update left pointer\r\n\r\n            longest = max(longest, right - left + 1)  # update the length of the longest substring\r\n        return longest\r\n\r\n\r\n# O(n2), O(n)\r\n# brute force\r\nclass Solution:\r\n    def characterReplacement(self, word: str, joker: int) -> int:\r\n            longest = 0\r\n\r\n            for left in range(len(word)):\r\n                counter = {}\r\n                max_count = 0\r\n                \r\n                for right in range(left, len(word)):    \r\n                    counter[word[right]] = counter.get(word[right], 0) + 1\r\n                    max_count = max(max_count, counter[word[right]])\r\n                    if (right - left + 1) - max_count > joker:\r\n                        break\r\n                    \r\n                longest = max(longest, min(max_count + joker, right - left + 1))\r\n\r\n            return longest\r\n\r\n\r\n# oldies\r\n# O(n), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def characterReplacement(self, word, joker):\r\n        window = {}  # window as dict\r\n        left = 0  # left pointer\r\n        longest = 0\r\n\r\n        for right, letter in enumerate(word):  # right pointer\r\n            window[letter] = window.get(letter, 0) + 1  # add new letter to window\r\n            \r\n            while (right - left + 1) - max(window.values()) > joker:  # check (\"sum - max\") how many character are replaced, if exeded\r\n                window[word[left]] -= 1  # remove \"left\" character from the window\r\n                left += 1\r\n\r\n            longest = max(longest, (right - left + 1))  # update the length of the longest replacement\r\n            # (right - left + 1) is much faster than sum(window.values())\r\n\r\n        return longest", "testcase": "print(Solution().characterReplacement(\"ABAB\", 2), 4)\r\nprint(Solution().characterReplacement(\"AABABBA\", 1), 4)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-07-26T23:16:42.880Z", "updated_at": "2025-02-02T16:31:11.877Z"}}, {"model": "python_problems.solution", "pk": 55, "fields": {"problem": 55, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def checkInclusion(self, word1: str, word2: str) -> bool:\r\n        left = 0  # `left` marks the start of the sliding window\r\n        pattern = {}  # `pattern` stores the frequency of characters in `word1`\r\n        window = {}  # `window` keeps track of character frequencies in the current window of `word2`\r\n        \r\n        for letter in word1:\r\n            pattern[letter] = pattern.get(letter, 0) + 1\r\n        \r\n        needed = len(pattern)  # `needed` keeps track of how many characters in `pattern` are still needed to match frequencies in `window`\r\n\r\n        for right, letter in enumerate(word2):\r\n            window[letter] = window.get(letter, 0) + 1  # add `letter` to `window`\r\n            \r\n            if (letter in pattern and  # if `letter` is in `pattern` and\r\n                    window[letter] == pattern[letter]):  # `letter` frequencies match\r\n                needed -= 1  # one less character needed to match strings\r\n\r\n                if needed == 0:  # if no `needed` (strings matched)\r\n                    return True\r\n            \r\n            # if `window` is as long as `text1`\r\n            if (right - left + 1) == len(word1):\r\n                left_letter = word2[left]  # get left letter\r\n                \r\n                if (left_letter in pattern and  # if left letter is in pattern and\r\n                        window[left_letter] == pattern[left_letter]):  # frequency of that letter in window is same as in pattern\r\n                    needed += 1  # increase matching character frequences\r\n\r\n                window[left_letter] -= 1  # decrease character frequency\r\n\r\n                if window[left_letter] == 0:  # if character frequency is zero\r\n                    window.pop(left_letter)  # pop that character\r\n\r\n                left += 1\r\n        \r\n        return False\r\n\r\n\r\n# O(n), O(n)\r\n# sliding window\r\n# This code is wrong somehow. In this version correct window length is checked\r\n# just after adding a new letter. So when its too long it gets shorten.\r\n# In the working version window lenght is checkd as the end of the loop.\r\n# If it's the size of the pattern, it gets trimmed for the next loop.\r\nclass Solution:\r\n    def checkInclusion(self, word1: str, word2: str) -> bool:\r\n        left = 0  # `left` marks the start of the sliding window\r\n        pattern = {}  # `pattern` stores the frequency of characters in `word1`\r\n        window = {}  # `window` keeps track of character frequencies in the current window of `word2`\r\n        \r\n        for letter in word1:\r\n            pattern[letter] = pattern.get(letter, 0) + 1\r\n        \r\n        needed = len(pattern)  # `needed` keeps track of how many characters in `pattern` are still needed to match frequencies in `window`\r\n\r\n        for right, letter in enumerate(word2):\r\n            window[letter] = window.get(letter, 0) + 1  # add `letter` to `window`\r\n            \r\n            # if `window` is longer than `text1`\r\n            if (right - left + 1) == len(word1) + 1:\r\n                left_letter = word2[left]  # get left letter\r\n                \r\n                if (left_letter in pattern and  # if left letter is in pattern and\r\n                        window[left_letter] == pattern[left_letter]):  # frequency of that letter in window is same as in pattern\r\n                    needed += 1  # increase matching character frequences\r\n\r\n                window[left_letter] -= 1  # decrease character frequency\r\n\r\n                if window[left_letter] == 0:  # if character frequency is zero\r\n                    window.pop(left_letter)  # pop that character\r\n\r\n                left += 1\r\n\r\n            if (letter in pattern and  # if `letter` is in `pattern` and\r\n                    window[letter] == pattern[letter]):  # `letter` frequencies match\r\n                needed -= 1  # one less character needed to match strings\r\n\r\n                if needed == 0:  # if no `needed` (strings matched)\r\n                    return True\r\n        \r\n        return False\r\n\r\n\r\n# O(n2), O(n)\r\n# brute force\r\nclass Solution:\r\n    def checkInclusion(self, word1: str, word2: str) -> bool:\r\n        counter_word1 = {}\r\n        for letter in word1:\r\n            counter_word1[letter] = counter_word1.get(letter, 0) + 1\r\n\r\n        for left in range(len(word2) - len(word1) + 1):\r\n            counter_word1_copy = counter_word1.copy()\r\n            \r\n            for right in range(left, left + len(word1)):\r\n                letter = word2[right]\r\n                if letter not in counter_word1_copy:\r\n                    break\r\n                counter_word1_copy[letter] -= 1\r\n                if counter_word1_copy[letter] == 0:\r\n                    counter_word1_copy.pop(letter)\r\n            \r\n            if not counter_word1_copy:\r\n                return True\r\n\r\n        return False", "testcase": "print(Solution().checkInclusion(\"ab\", \"eidbaooo\"), True)\r\nprint(Solution().checkInclusion(\"ab\", \"eidboaoo\"), False)\r\nprint(Solution().checkInclusion(\"ccc\", \"cbac\"), False)\r\nprint(Solution().checkInclusion(\"ab\", \"a\"), False)\r\nprint(Solution().checkInclusion(\"abcdxabcde\", \"abcdeabcdx\"), True)\r\nprint(Solution().checkInclusion(\"adc\", \"dcda\"), True)\r\nprint(Solution().checkInclusion(\"hello\", \"ooolleoooleh\"), False)\r\nprint(Solution().checkInclusion(\"mart\", \"karma\"), False)\r\nprint(Solution().checkInclusion(\"abc\", \"ccccbbbbaaaa\"), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-07-27T23:33:04.559Z", "updated_at": "2025-02-02T16:30:06.031Z"}}, {"model": "python_problems.solution", "pk": 56, "fields": {"problem": 56, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def minWindow(self, word1: str, word2: str) -> str:\r\n        pattern = {}  # stores the frequency of characters in `word2` (target)\r\n        window = {}  # tracks character frequencies in the current sliding window of `word1`\r\n        left = 0  # the start pointer for the sliding window\r\n        start = -1  # the start of the shortest window\r\n        min_length = len(word1) + 1\r\n        \r\n        for letter in word2:\r\n            pattern[letter] = pattern.get(letter, 0) + 1\r\n        \r\n        need = len(pattern)  # the number of unique letters left to match the pattern\r\n        \r\n        for right, letter in enumerate(word1):\r\n            if letter in pattern:  # if pattern contains current letter\r\n                window[letter] = window.get(letter, 0) + 1  # Add the current character to the `window` dictionary\r\n                if window[letter] == pattern[letter]:\r\n                    need -= 1\r\n\r\n            while need == 0:  # if pattern is matched\r\n                if right - left + 1 < min_length:  # if current string shorter\r\n                    min_length = right - left + 1  # update shortest window length\r\n                    start = left  # mark the start of the shortest window\r\n        \r\n                # Shrink the window:\r\n                if word1[left] in pattern:\r\n                    if window[word1[left]] == pattern[word1[left]]:\r\n                        need += 1\r\n                    window[word1[left]] -= 1\r\n                left += 1\r\n\r\n        return (word1[start: start + min_length] \r\n                if min_length != len(word1) + 1\r\n                else \"\")", "testcase": "print(Solution().minWindow(\"ADOBECODEBANC\", \"ABC\"), \"BANC\")\r\nprint(Solution().minWindow(\"a\", \"a\"), \"a\")\r\nprint(Solution().minWindow(\"a\", \"aa\"), \"\")\r\nprint(Solution().minWindow(\"a\", \"b\"), \"\")\r\nprint(Solution().minWindow(\"ab\", \"b\"), \"b\")\r\nprint(Solution().minWindow(\"bba\", \"ab\"), \"ba\")\r\nprint(Solution().minWindow(\"abc\", \"a\"), \"a\")\r\nprint(Solution().minWindow(\"jwsdrkqzrthzysvqqazpfnulprulwmwhiqlbcdduxktxepnurpmxegktzegxscfbusexvhruumrydhvvyjucpeyrkeodjvgdnkalutfoizoliliguckmikdtpryanedcqgpkzxahwrvgcdoxiylqjolahjawpfbilqunnvwlmtrqxfphgaxroltyuvumavuomodblbnzvequmfbuganwliwidrudoqtcgyeuattxxlrlruhzuwxieuqhnmndciikhoehhaeglxuerbfnafvebnmozbtdjdo\", \"qruzywfhkcbovewle\"), \"vequmfbuganwliwidrudoqtcgyeuattxxlrlruhzuwxieuqhnmndciik\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-06T14:20:44.210Z", "updated_at": "2025-02-04T22:36:38.675Z"}}, {"model": "python_problems.solution", "pk": 57, "fields": {"problem": 57, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# sliding window, deque, monotonic queue\r\n# monotonic decreasing queue\r\nclass Solution:\r\n    def maxSlidingWindow(self, numbers: list[int], window_size: int) -> list[int]:\r\n        window = deque()  # sliding window as a deque\r\n        left = 0  # left pointer\r\n        maxs_list = []  # stores the maximum values for each sliding window.\r\n\r\n        for right, number in enumerate(numbers):\r\n            # Remove elements from the back of the deque if they are less than or equal to\r\n            # the current number, as they cannot be the maximum in the current \r\n            # or any future window. monotonicly decreasing queue\r\n            while (window and\r\n                   window[-1][1] <= number):\r\n                window.pop()\r\n\r\n            # Remove elements from the front of the deque if they are outside the current window.\r\n            while (window and\r\n                   window[0][0] < left):\r\n                window.popleft()\r\n\r\n            window.append((right, number))  # add the index, number pair to the deque.\r\n\r\n            if right - left + 1 == window_size:  # When the sliding window reaches the required size, record the maximum value.\r\n                maxs_list.append(window[0][1])  # The maximum value in the current window is at the index `window[0][1]`.\r\n                left += 1  # Slide the window forward by incrementing `left`.\r\n\r\n        return maxs_list", "testcase": "print(Solution().maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3), [3, 3, 5, 5, 6, 7])\r\nprint(Solution().maxSlidingWindow([1], 1), [1])\r\nprint(Solution().maxSlidingWindow([7, 2, 4], 2), [7, 4])\r\nprint(Solution().maxSlidingWindow([1, 3, 1, 2, 0, 5], 3), [3, 3, 2, 5])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-08T14:31:43.288Z", "updated_at": "2025-02-04T23:39:40.696Z"}}, {"model": "python_problems.solution", "pk": 58, "fields": {"problem": 58, "language": 1, "owner": 3, "solution": "class MinStack:\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.min_stack = []\r\n\r\n    def push(self, val: int) -> None:\r\n        self.stack.append(val)\r\n        self.min_stack.append(min(val, self.min_stack[-1] if self.min_stack else val))\r\n\r\n    def pop(self) -> None:\r\n        self.stack.pop()\r\n        self.min_stack.pop()\r\n\r\n    def top(self) -> int:\r\n        return self.stack[-1]\r\n\r\n    def getMin(self) -> int:\r\n        return self.min_stack[-1]\r\n\r\n\r\n# Explanation\r\nminStack = MinStack()\r\nminStack.push(-2)\r\nminStack.push(0)\r\nminStack.push(-3)\r\nminStack.getMin() #  return -3\r\nminStack.pop()\r\nminStack.top() #  return 0\r\nminStack.getMin() #  return -2", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-08-08T20:23:58.114Z", "updated_at": "2024-08-08T20:23:58.127Z"}}, {"model": "python_problems.solution", "pk": 59, "fields": {"problem": 59, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def evalRPN(self, tokens: list[str]) -> int:\r\n        stack = []\r\n\r\n        for elem in tokens:\r\n            if elem == \"+\":\r\n                b = stack.pop()\r\n                a = stack.pop()\r\n                stack.append(a + b)\r\n            elif elem == \"-\":\r\n                b = stack.pop()\r\n                a = stack.pop()\r\n                stack.append(a - b)\r\n            elif elem == \"*\":\r\n                b = stack.pop()\r\n                a = stack.pop()\r\n                stack.append(a * b)\r\n            elif elem == \"/\":\r\n                b = stack.pop()\r\n                a = stack.pop()\r\n                stack.append(int(a / b))\r\n            else:\r\n                stack.append(int(elem))\r\n        return stack[0]", "testcase": "(Solution().evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]), 9)\r\n(Solution().evalRPN([\"4\", \"13\", \"5\", \"/\", \"+\"]), 6)\r\n(Solution().evalRPN([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]), 22)\r\n(Solution().evalRPN([\"18\"]), 18)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-08T21:30:57.632Z", "updated_at": "2024-08-08T21:30:57.645Z"}}, {"model": "python_problems.solution", "pk": 60, "fields": {"problem": 60, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack, monotonic stack\r\n# monotonically decreasing stack\r\nclass Solution:\r\n    def dailyTemperatures(self, temps: list[int]) -> list[int]:\r\n        stack = []  # [(day, temperature), ]\r\n        days_delta = [0] * len(temps)\r\n\r\n        for current_day, temp in enumerate(temps):\r\n            while stack and temp > stack[-1][1]:  # check if temp is lower\r\n                previous_day, _ = stack.pop()  # index of the last day in stack\r\n                days_delta[previous_day] = current_day - previous_day  # set days needed to get higher temperature\r\n\r\n            stack.append((current_day, temp))  # apped new temp\r\n\r\n        return days_delta\r\n\r\n\r\n# O(n2), O(1)\r\n# brute force\r\nclass Solution:\r\n    def dailyTemperatures(self, temps: list[int]) -> list[int]:\r\n        days_to_warmer = [0] * len(temps)\r\n\r\n        for left in range(len(temps)):\r\n            for right in range(left + 1, len(temps)):\r\n                if temps[left] < temps[right]:\r\n                    days_to_warmer[left] = right - left\r\n                    break\r\n        \r\n        return days_to_warmer", "testcase": "print(Solution().dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]), [1, 1, 4, 2, 1, 1, 0, 0])\r\nprint(Solution().dailyTemperatures([30, 40, 50, 60]), [1, 1, 1, 0])\r\nprint(Solution().dailyTemperatures([30, 60, 90]), [1, 1, 0])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-09T14:34:30.478Z", "updated_at": "2025-02-07T21:03:13.438Z"}}, {"model": "python_problems.solution", "pk": 61, "fields": {"problem": 61, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def carFleet(self, target, positions, speeds):\r\n        cars = list(zip(positions, speeds))\r\n        cars.sort(reverse=True)  # sort the cars so to start with the one closest to the target\r\n        fleet_stack = []\r\n\r\n        for position, speed in cars:\r\n            curr_dist = (target - position) / speed  # distance to the target\r\n            \r\n            if fleet_stack and fleet_stack[-1] >= curr_dist:  # if the car behind cought up next car\r\n                continue\r\n\r\n            fleet_stack.append(curr_dist)  # append a car to a stack\r\n\r\n        return len(fleet_stack)", "testcase": "(Solution().carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]), 3)\r\n(Solution().carFleet(10, [3], [3]), 1)\r\n(Solution().carFleet(100, [0, 2, 4], [4, 2, 1]), 1)\r\n(Solution().carFleet(10, [0, 4, 2], [2, 1, 3]), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-09T16:05:46.404Z", "updated_at": "2024-08-24T20:13:15.766Z"}}, {"model": "python_problems.solution", "pk": 62, "fields": {"problem": 62, "language": 1, "owner": 3, "solution": "# O(2^n), O(n)\r\n# backtracking\r\n# \"dfs\" method inside \"subsets\" method\r\nclass Solution:\r\n    def subsets(self, numbers: list[int]) -> list[list[int]]:\r\n        subset = []  # current subset\r\n        subset_list = []  # possible subset list\r\n\r\n        def dfs(level):\r\n            if level == len(numbers):  # target level reached\r\n                subset_list.append(subset.copy())  # push subset to subset_list\r\n                return  \r\n\r\n            subset.append(numbers[level])  # Include the current element in the subset\r\n            dfs(level + 1)  # Explore the path with the current element\r\n            subset.pop()  # Backtrack by removing the current element from the subset\r\n            dfs(level + 1)  # Explore the path without including the current element\r\n\r\n        dfs(0)  # start dfs with level = 0\r\n    \r\n        return subset_list\r\n\r\n\r\n# O(2^n), O(n)\r\n# backtracking\r\n# \"dfs\" and \"subset\" methods inside a class\r\nclass Solution:\r\n    def __init__(self) -> None:\r\n        self.subset = []\r\n        self.subset_list = []\r\n\r\n    def subsets(self, numbers: list[int]) -> list[list[int]]:\r\n        self.numbers = numbers\r\n        self.dfs(0)\r\n        \r\n        return self.subset_list\r\n\r\n    def dfs(self, level: int) -> None:\r\n        if level == len(self.numbers):\r\n            self.subset_list.append(self.subset.copy())\r\n            return\r\n        \r\n        self.subset.append(self.numbers[level])\r\n        self.dfs(level + 1)            \r\n        self.subset.pop()\r\n        self.dfs(level + 1)", "testcase": "print(sorted(Solution().subsets([1, 2, 3])), [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]])\r\nprint(sorted(Solution().subsets([0])), [[], [0]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-08-12T19:57:48.338Z", "updated_at": "2024-12-28T03:08:24.698Z"}}, {"model": "python_problems.solution", "pk": 63, "fields": {"problem": 63, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def subsetsWithDup(self, numbers: list[int]) -> list[list[int]]:\r\n        numbers.sort()\r\n        subset = []  # current subset\r\n        subset_list = []  # solution\r\n\r\n        def dfs(index):\r\n            if index == len(numbers):  # target level reached\r\n                subset_list.append(subset.copy())  # push subset to subset_list\r\n                return\r\n\r\n            subset.append(numbers[index])  # Include the current element in the subset\r\n            dfs(index + 1)  # Explore the path with the current element\r\n            subset.pop()  # Backtrack by removing the current element from the subset\r\n\r\n            # Skip over duplicate elements to avoid generating duplicate subsets\r\n            # If number at the `index + 1` (that was poped previously) is the same as\r\n            # the number at current index skip it.\r\n            while (index + 1 < len(numbers) and\r\n                    numbers[index] == numbers[index + 1]):\r\n                index += 1\r\n\r\n            dfs(index + 1)  # Explore the path without including the current element\r\n\r\n        dfs(0)  # start dfs with level = 0\r\n\r\n        return subset_list\r\n\r\n\r\n# use 'sort' to compare and remove duplicates\r\nclass Solution:\r\n    def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:\r\n        solution = []\r\n        subset = []\r\n\r\n        def dfs(level):\r\n            if level == len(nums):\r\n                if not sorted(subset) in solution:\r\n                    solution.append(sorted(subset.copy()))\r\n                return\r\n\r\n            subset.append(nums[level])\r\n            dfs(level + 1)\r\n\r\n            subset.pop()\r\n            dfs(level + 1)\r\n\r\n        dfs(0)\r\n        return solution\r\n\r\n\r\n# use dict to compare and remove duplicates\r\nclass Solution:\r\n    def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:\r\n        solution = []\r\n        subset = []\r\n        sol_list = []\r\n\r\n        def dfs(level):\r\n            if level == len(nums):\r\n                num_count = {}\r\n                for num in subset:\r\n                    num_count[num] = num_count.get(num, 0) + 1\r\n\r\n                if not num_count in solution:\r\n                    solution.append(num_count)\r\n                return\r\n\r\n            subset.append(nums[level])\r\n            dfs(level + 1)\r\n\r\n            subset.pop()\r\n            dfs(level + 1)\r\n\r\n        dfs(0)\r\n\r\n        sol = []\r\n        for sol_elem in solution:\r\n            so = []\r\n            for k, v in sol_elem.items():\r\n                for _ in range(v):\r\n                    so.append(k)\r\n            sol.append(so)\r\n\r\n        return sol", "testcase": "print(Solution().subsetsWithDup([1, 2, 2]), [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]])\r\nprint(Solution().subsetsWithDup([0]), [[], [0]])\r\nprint(Solution().subsetsWithDup([4, 4, 4, 1, 4]), [[], [1], [1, 4], [1, 4, 4], [1, 4, 4, 4], [1, 4, 4, 4, 4], [4], [4, 4], [4, 4, 4], [4, 4, 4, 4]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-08-13T12:02:16.277Z", "updated_at": "2024-12-28T09:07:02.237Z"}}, {"model": "python_problems.solution", "pk": 64, "fields": {"problem": 64, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:\r\n        # sort candidates to ensure that candidate with index + 1 is greater than previous to not reapat solution\r\n        candidates.sort()\r\n        combination = []  # current combination\r\n        combination_list = []  # solution\r\n\r\n\r\n        def dfs(value, start_index):\r\n            if value == target:  # target sum reached\r\n                combination_list.append(combination.copy())  # push subset to subset_list\r\n                return\r\n            elif value > target:\r\n                return\r\n            \r\n            for index in range(start_index, len(candidates)):  # check only equal or higher candidates\r\n                candidate = candidates[index]\r\n                combination.append(candidate)\r\n                dfs(value + candidate, index)\r\n                combination.pop()\r\n               \r\n        dfs(0, 0)\r\n\r\n        return combination_list\r\n\r\n\r\nclass Solution:\r\n    def combinationSum(self, candidates: list[int], target: int) -> list[list[int]]:\r\n        combination_list = []  # solution\r\n        # sort candidates to ensure that candidate with index + 1 is greater than previous to not reapat combination_list\r\n        candidates = list(sorted(set(candidates)))\r\n\r\n        def dfs(index, subset):\r\n            if sum(subset) == target:  # target sum reached\r\n                combination_list.append(subset.copy())  # push subset to subset_list\r\n                return\r\n            \r\n            # index out of obunds or sum too large\r\n            if index == len(candidates) or sum(subset) > target:\r\n                return\r\n            \r\n            # (left) decision to append current candidate\r\n            subset.append(candidates[index])\r\n            dfs(index, subset)\r\n\r\n            # (right) decision to not append current candidate\r\n            subset.pop()\r\n            dfs(index + 1, subset)\r\n\r\n        dfs(0, [])\r\n\r\n        return combination_list", "testcase": "(Solution().combinationSum([2, 3, 6, 7], 7), [[2, 2, 3], [7]])\r\n(Solution().combinationSum([2, 3, 5], 8), [[2, 2, 2, 2], [2, 3, 3], [3, 5]])\r\n(Solution().combinationSum([2], 1), [])", "time_complexity": 8, "space_complexity": 2, "created_at": "2024-08-13T14:46:28.251Z", "updated_at": "2024-09-01T10:09:27.979Z"}}, {"model": "python_problems.solution", "pk": 65, "fields": {"problem": 65, "language": 1, "owner": 3, "solution": "# O(n2^n), O(n)\r\n# backtracking\r\nclass Solution:\r\n    def combinationSum2(self, candidates: list[int], target: int) -> list[list[int]]:\r\n        solution = []\r\n        # sort needed to skip same values\r\n        candidates.sort()\r\n\r\n        def dfs(index, subset):\r\n            # if sum is achieved\r\n            if sum(subset) == target:\r\n                solution.append(subset.copy())\r\n                return\r\n\r\n            # index boundry and sum boundry            \r\n            if index == len(candidates) or sum(subset) > target:\r\n                return\r\n\r\n            # (left node) append candidate\r\n            subset.append(candidates[index])\r\n            dfs(index + 1, subset)\r\n\r\n            # (right node) skip candidate\r\n            subset.pop()\r\n            # skip same values\r\n            while index + 1 < len(candidates) and candidates[index] == candidates[index + 1]:\r\n                index += 1\r\n            dfs(index + 1, subset)\r\n\r\n        dfs(0, [])\r\n\r\n        return solution", "testcase": "print(Solution().combinationSum2([10, 1, 2, 7, 6, 1, 5], 8), [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]])\r\nprint(Solution().combinationSum2([2, 5, 2, 1, 2], 5), [[1, 2, 2], [5]])\r\nprint(Solution().combinationSum2([6], 6), [[6]])\r\nprint(Solution().combinationSum2([2, 2, 2], 2), [[2]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-08-13T19:05:09.214Z", "updated_at": "2024-12-28T11:07:32.797Z"}}, {"model": "python_problems.solution", "pk": 66, "fields": {"problem": 66, "language": 1, "owner": 3, "solution": "# O(n!), O(n)\r\n# backtracking\r\nclass Solution:\r\n    def permute(self, numbers: list[int]) -> list[list[int]]:\r\n        permutation_list = []\r\n\r\n        def dfs(left):\r\n            if left == len(numbers):\r\n                permutation_list.append(numbers.copy())\r\n                return\r\n            \r\n            for right in range(left, len(numbers)):\r\n                numbers[left], numbers[right] = numbers[right], numbers[left]\r\n                dfs(left + 1)\r\n                numbers[left], numbers[right] = numbers[right], numbers[left]\r\n        \r\n        dfs(0)\r\n        return permutation_list\r\n\r\n\r\n# O(n!), O(n!)\r\n# backtracking\r\nclass Solution:\r\n    def permute(self, numbers: list[int]) -> list[list[int]]:\r\n        permutation = []  # Current permutation being built\r\n        permutation_list = []  # List to store all permutations\r\n        \r\n        def dfs(numbers):\r\n            if not numbers:  # Base case: when there are no more numbers to permute\r\n                permutation_list.append(permutation.copy())\r\n                return\r\n            \r\n            for index in range(len(numbers)):  # Loop through all numbers to generate permutations\r\n                permutation.append(numbers[index])  # Choose the current number and add it to the permutation\r\n                dfs(numbers[:index] + numbers[index + 1:])  # Recurse with the remaining numbers (excluding the chosen one)\r\n                permutation.pop()  # Backtrack by removing the last added number\r\n\r\n        dfs(numbers)  # Start the recursive DFS with the initial list of numbers\r\n\r\n        return permutation_list\r\n\r\n\r\n# O(n!), O(n!)\r\n# backtracking\r\nclass Solution:\r\n    def permute(self, numbers: list[int]) -> list[list[int]]:\r\n        permutation_list = []  # List to store all permutations\r\n        \r\n        def dfs(permutation, numbers):\r\n            if not numbers:  # Base case: when there are no more numbers to permute\r\n                permutation_list.append(permutation)\r\n                return\r\n            \r\n            for index in range(len(numbers)):  # Loop through all numbers to generate permutations\r\n                dfs(permutation + [numbers[index]], \r\n                    numbers[:index] + numbers[index + 1:])\r\n\r\n        dfs([], numbers)  # Start the recursive DFS with empy permutation list and the initial list of numbers\r\n\r\n        return permutation_list", "testcase": "(Solution().permute([1, 2, 3]), [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]])\r\n(Solution().permute([0, 1]), [[0, 1], [1, 0]])\r\n(Solution().permute([1]), [[1]])", "time_complexity": 8, "space_complexity": 2, "created_at": "2024-08-13T21:56:06.302Z", "updated_at": "2025-01-06T17:24:21.812Z"}}, {"model": "python_problems.solution", "pk": 67, "fields": {"problem": 67, "language": 1, "owner": 3, "solution": "# O(nm3^k), O(nm)\r\n# backtracking\r\nclass Solution:\r\n    def exist(self, board, word):\r\n        rows = len(board)\r\n        cols = len(board[0])\r\n        tabu = set()  # set of visited (forbidden) cells\r\n        \r\n        def dfs(row, col, index):\r\n            if index == len(word):\r\n                return True\r\n            \r\n            tabu.add((row, col))  # add cell pair to tabu set\r\n\r\n            # check up, down, left, right for neighbouns\r\n            if (col + 1 < cols and  # check if out of bounds and\r\n                word[index] == board[row][col + 1] and  # Check if the current position matches the word's character\r\n                (row, col + 1) not in tabu and  # if cell is not in tabo set\r\n                    dfs(row, col + 1, index + 1)):  # Switch to that letter and check its neighbors\r\n                return True\r\n\r\n            if (row + 1 < rows and\r\n                word[index] == board[row + 1][col] and\r\n                (row + 1, col) not in tabu and\r\n                    dfs(row + 1, col, index + 1)):\r\n                return True\r\n        \r\n            if (col - 1 >= 0 and\r\n                word[index] == board[row][col - 1] and\r\n                (row, col - 1) not in tabu and\r\n                    dfs(row, col - 1, index + 1)):\r\n                return True\r\n\r\n            if (row - 1 >= 0 and\r\n                word[index] == board[row - 1][col] and\r\n                (row - 1, col) not in tabu and\r\n                    dfs(row - 1, col, index + 1)):\r\n                return True\r\n            \r\n            # Backtrack: remove from tabu\r\n            tabu.remove((row, col))\r\n            \r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if word[0] == board[row][col]:  # if first letter matches\r\n                    if dfs(row, col, 1):  # check its heighbors\r\n                        return True\r\n\r\n        return False  # if word was not found return False", "testcase": "print(Solution().exist([[\"C\", \"A\", \"A\"]], \"AA\"), True)\r\nprint(Solution().exist([[\"C\", \"A\", \"A\"], [\"C\", \"C\", \"B\"]], \"AAB\"), True)\r\nprint(Solution().exist([[\"C\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"B\", \"C\", \"D\"]], \"AAB\"), True)\r\nprint(Solution().exist([[\"C\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"B\", \"C\", \"D\"]], \"AACA\"), True)\r\nprint(Solution().exist([[\"A\", \"A\"]], \"AAA\"), False)\r\nprint(Solution().exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"E\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"ABCEFSADEESE\"), True)\r\nprint(Solution().exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"AB\"), True)\r\nprint(Solution().exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"AZ\"), False)\r\nprint(Solution().exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"ABFS\"), True)\r\nprint(Solution().exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"ABCCED\"), True)\r\nprint(Solution().exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"SEE\"), True)\r\nprint(Solution().exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"ABCB\"), False)", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-08-14T14:19:16.776Z", "updated_at": "2024-12-29T05:28:36.040Z"}}, {"model": "python_problems.solution", "pk": 68, "fields": {"problem": 68, "language": 1, "owner": 3, "solution": "# passing dfs(rest of the word) like \"word = (pratition) + (rest of the word)\"\r\nclass Solution:\r\n    def partition(self, word):\r\n        partition_list = []  # This will store all valid palindrome partitions\r\n        current_partition = []  # This will track the current partition\r\n\r\n        def dfs(word):\r\n            if len(word) == 0:  # if word is empty that means all letters folded into palindrom\r\n                partition_list.append(current_partition.copy())\r\n                return\r\n\r\n            for index in range(1, len(word) + 1):  # index starts from '1' because the first element is word[:index]\r\n                substring = word[:index]\r\n\r\n                if substring == substring[::-1]:  # if substring is a palindrme\r\n                    current_partition.append(substring)  # Add it to the current partition\r\n                    dfs(word[index:])  # Recur for the next part of the word\r\n                    current_partition.pop()  # Backtrack by removing the last added palindrome\r\n\r\n        dfs(word)  # Start DFS with \"word\"\r\n        return partition_list\r\n\r\n\r\n# passing indexes in dfs\r\nclass Solution:\r\n    def partition(self, word):\r\n        partition_list = []  # This will store all valid palindrome partitions\r\n        current_partition = []  # This will track the current partition\r\n\r\n        def dfs(start):\r\n            if start == len(word):  # If we reach the end of the word\r\n                partition_list.append(current_partition.copy())  # Add the current partition to the list\r\n                return\r\n\r\n            for end in range(start + 1, len(word) + 1):\r\n                substring = word[start:end]  # Current substring to check\r\n                \r\n                if substring == substring[::-1]:  # Check if the substring is a palindrome\r\n                    current_partition.append(substring)  # Add it to the current partition\r\n                    dfs(end)  # Recur for the next part of the word\r\n                    current_partition.pop()  # Backtrack by removing the last added palindrome\r\n\r\n        dfs(0)  # Start DFS from index 0\r\n        return partition_list\r\n\r\n\r\n# Failed attempt to make it work without a for loop.\r\n# When adding a new letter 1) check if it can be added to exisxting palindrome or\r\n# 2) add it as another element. It fails \"aba\" and complicates the problem unnecessarily.\r\nclass Solution:\r\n    def partition(self, word):\r\n        current_partition = []  # To store the final palindrome partitions\r\n        partition_list = []  # Start with an empty partition\r\n\r\n\r\n        def dfs(index):\r\n            if index == len(word):  # if all letters are used\r\n                partition_list.append(current_partition.copy())\r\n                return\r\n            \r\n\r\n            letter = word[index]\r\n\r\n            # Case 1: Add the current letter to the last element of current_partition (if possible)\r\n            if current_partition:\r\n                temp = current_partition.pop()\r\n                combined = temp + letter\r\n                current_partition.append(combined)\r\n\r\n                if combined == combined[::-1]:\r\n                    dfs(index + 1)\r\n\r\n                # Backtrack to restore the state\r\n                combined = current_partition.pop()\r\n                current_partition.append(combined[:-1])\r\n            \r\n            # Case 2: Add the current letter as a new element in current_partition\r\n            current_partition.append(letter)\r\n            dfs(index + 1)\r\n            current_partition.pop()  # Backtrack after exploring this option\r\n\r\n        dfs(0)  # Start DFS from the first character\r\n\r\n        return partition_list", "testcase": "(Solution().partition(\"a\"), [[\"a\"]])\r\n(Solution().partition(\"aa\"), [['a', 'a'], ['aa']])\r\n(Solution().partition(\"ab\"), [[\"a\", \"b\"]])\r\n(Solution().partition(\"aaa\"), [['a', 'a', 'a'], ['a', 'aa'], ['aa', 'a'], ['aaa']])\r\n(Solution().partition(\"aab\"), [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]])\r\n(Solution().partition(\"aba\"), [[\"a\", \"b\", \"a\"], [\"aba\"]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-08-14T20:44:29.812Z", "updated_at": "2024-09-05T14:07:13.848Z"}}, {"model": "python_problems.solution", "pk": 69, "fields": {"problem": 69, "language": 1, "owner": 3, "solution": "# passing index to dfs, combination as a shared variable (list)\r\nclass Solution:\r\n    def letterCombinations(self, digits: str) -> list[str]:\r\n        if not digits:\r\n            return []\r\n        \r\n        combination = []\r\n        combination_list = []\r\n        digit_to_letter = {\r\n            \"2\": \"abc\",\r\n            \"3\": \"def\",\r\n            \"4\": \"ghi\",\r\n            \"5\": \"jkl\",\r\n            \"6\": \"mno\",\r\n            \"7\": \"pqrs\",\r\n            \"8\": \"tuv\",\r\n            \"9\": \"wxyz\"\r\n        }\r\n\r\n        def dfs(index):\r\n            if index == len(digits):\r\n                combination_list.append(\"\".join(combination))\r\n                return\r\n\r\n            for letter in digit_to_letter[digits[index]]:\r\n                combination.append(letter)\r\n                dfs(index + 1)\r\n                combination.pop()\r\n\r\n        dfs(0)\r\n\r\n        return combination_list\r\n\r\n\r\n# passing digits to dfs\r\nclass Solution:\r\n    def letterCombinations(self, digits: str) -> list[str]:\r\n        if not digits:\r\n            return []\r\n            \r\n        to_letters = {\"2\": \"abc\", \r\n                      \"3\": \"def\", \r\n                      \"4\": \"ghi\", \r\n                      \"5\": \"jkl\", \r\n                      \"6\": \"mno\",\r\n                      \"7\": \"pqrs\",\r\n                      \"8\": \"tuv\",\r\n                      \"9\": \"wxyz\"}\r\n        solution = []\r\n        part = []\r\n\r\n        def dfs(digits):\r\n            if not digits:\r\n                solution.append(\"\".join(part))\r\n                return\r\n\r\n            for letter in to_letters[digits[0]]:\r\n                part.append(letter)\r\n                dfs(digits[1:])\r\n                part.pop()\r\n\r\n        dfs(digits)\r\n\r\n        return solution\r\n\r\n\r\nclass Solution:\r\n    def letterCombinations(self, digits: str) -> list[str]:\r\n        to_letters = {\"2\": \"abc\", \r\n                      \"3\": \"def\", \r\n                      \"4\": \"ghi\", \r\n                      \"5\": \"jkl\", \r\n                      \"6\": \"mno\",\r\n                      \"7\": \"pqrs\",\r\n                      \"8\": \"tuv\",\r\n                      \"9\": \"wxyz\"}\r\n        solution = []\r\n\r\n        def dfs(index, part):\r\n            if index == len(digits):\r\n                solution.append(\"\".join(part))\r\n                return\r\n\r\n            for letter in to_letters[digits[index]]:\r\n                dfs(index + 1, part + letter)\r\n\r\n        if digits:\r\n            dfs(0, \"\")\r\n\r\n        return solution", "testcase": "print(Solution().letterCombinations(\"2\"), [\"a\", \"b\", \"c\"])\r\nprint(Solution().letterCombinations(\"23\"), [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"])\r\nprint(Solution().letterCombinations(\"\"), [])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-08-15T11:07:41.148Z", "updated_at": "2024-12-29T13:22:09.877Z"}}, {"model": "python_problems.solution", "pk": 70, "fields": {"problem": 70, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def solveNQueens(self, n: int) -> list[list[str]]:\r\n        solution = []\r\n        board = [[\".\" for _ in range(n)] for _ in range(n)]  # initiate a board\r\n        tabu_col = set()\r\n        tabu_diag = set()  # for each diagonal (col_ind - row_ind) = const\r\n        tabu_adiag = set()  # for each aiti-diagonal (con_ind + row_ind) = const\r\n\r\n        def dfs(row):\r\n            if row == n:  # if all rows are filled with Queens\r\n                joined_board = [\"\".join(row) for row in board]  # ['.', 'Q', '.', '.'] => ['.Q..']\r\n                solution.append(joined_board)\r\n                return\r\n\r\n            for col in range(n):\r\n                # if there is another Queen in the same diagonal or the same col\r\n                if ((row - col) in tabu_diag or \r\n                    (row + col) in tabu_adiag or \r\n                    col in tabu_col):\r\n                    continue\r\n                \r\n                # update tabu and board\r\n                tabu_col.add(col)\r\n                tabu_diag.add(row - col)\r\n                tabu_adiag.add(row + col)\r\n                board[row][col] = \"Q\"\r\n\r\n                # check another row\r\n                dfs(row + 1)\r\n\r\n                # backtrack\r\n                tabu_col.remove(col)\r\n                tabu_diag.remove(row - col)\r\n                tabu_adiag.remove(row + col)\r\n                board[row][col] = \".\"\r\n\r\n        dfs(0)\r\n        return solution", "testcase": "(Solution().solveNQueens(4), [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]])\r\n(Solution().solveNQueens(1), [[\"Q\"]])", "time_complexity": 8, "space_complexity": 3, "created_at": "2024-08-15T20:20:19.282Z", "updated_at": "2024-09-06T14:57:36.945Z"}}, {"model": "python_problems.solution", "pk": 71, "fields": {"problem": 11, "language": 2, "owner": 3, "solution": "// Set - Early exit\r\n/**\r\n * @param {number[]} nums\r\n * @return {boolean}\r\n */\r\nvar containsDuplicate = (nums) => {\r\n  const seen = new Set();\r\n  \r\n  for (const num of nums) {\r\n    \r\n    if (seen.has(num)) {\r\n      return true\r\n    } else {\r\n      seen.add(num)\r\n    };\r\n  };\r\n\r\n  return false\r\n};\r\n\r\n\r\n// Set\r\n/**\r\n * @param {number[]} nums\r\n * @return {boolean}\r\n */\r\nvar containsDuplicate = (nums) => {\r\n  const seen = new Set(nums);\r\n  \r\n  return !(nums.length == seen.size)\r\n};", "testcase": "(containsDuplicate([1, 2, 3, 1]), true)\r\n(containsDuplicate([1, 2, 3]), false)\r\n(containsDuplicate([1, 2, 3, 4]), false)\r\n(containsDuplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]), true)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-19T15:39:14.573Z", "updated_at": "2024-08-19T15:39:14.587Z"}}, {"model": "python_problems.solution", "pk": 72, "fields": {"problem": 12, "language": 2, "owner": 3, "solution": "// Map\r\nvar isAnagram = (word1, word2) => {\r\n  const word1_count = counter(word1);\r\n  const word2_count = counter(word2);\r\n\r\n  if (word1.length != word2.length) {\r\n    return false\r\n  };\r\n\r\n  for (let key of word1_count.keys()) {\r\n    if (word1_count.get(key) != word2_count.get(key)) {\r\n      return false\r\n    };\r\n  };\r\n  \r\n  return true\r\n};\r\n\r\nconst counter = (word) => {\r\n  const counter = new Map();\r\n\r\n  for (let letter of word) {\r\n    let count = (counter.get(letter) ?? 0) + 1;\r\n    counter.set(letter, count);\r\n  };\r\n\r\n  return counter\r\n};\r\n\r\n\r\n// compare two Objects\r\nvar isAnagram = (word1, word2) => {\r\n  const word1_count = counter(word1);\r\n  const word2_count = counter(word2);\r\n\r\n  for (let key in {...word1_count, ...word2_count}) {\r\n    if (word1_count[key] != word2_count[key]) {\r\n      return false\r\n    };\r\n  };\r\n\r\n  return true\r\n};\r\n\r\nconst counter = (word) => {\r\n  const counter = {};\r\n\r\n  for (let letter of word) {\r\n    if (counter[letter]) {\r\n      counter[letter] = counter[letter] + 1;\r\n    } else {\r\n      counter[letter] = 1;\r\n    };\r\n  };\r\n  return counter\r\n};\r\n\r\n\r\n// subtract one Object from another\r\nvar isAnagram = (word1, word2) => {\r\n  const counter = {};\r\n  const word1_dict = count_add(counter, word1);\r\n  const word2_dict = count_subtract(word1_dict, word2);\r\n\r\n  for (let key in word2_dict) {\r\n    if (word2_dict[key]) {\r\n      return false\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nconst count_add = (counter, word) => {\r\n  for (let letter of word) {\r\n    if (counter[letter]) {\r\n      counter[letter] = counter[letter] + 1;\r\n    } else {\r\n      counter[letter] = 1;\r\n    };\r\n  };\r\n  return counter;\r\n\r\n};\r\n\r\nconst count_subtract = (counter, word) => {\r\n  for (let letter of word) {\r\n    if (counter[letter]) {\r\n      counter[letter] = counter[letter] - 1;\r\n    } else {\r\n      counter[letter] = -1;\r\n    };\r\n  };\r\n  return counter;\r\n\r\n};", "testcase": "console.log(isAnagram(\"anagram\", \"nagaram\"), true)\r\nconsole.log(isAnagram(\"rat\", \"car\"), false)\r\nconsole.log(isAnagram(\"a\", \"ab\"), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-19T19:01:43.922Z", "updated_at": "2024-08-19T20:31:18.394Z"}}, {"model": "python_problems.solution", "pk": 73, "fields": {"problem": 13, "language": 2, "owner": 3, "solution": "// key as a 26 digit string, Map()\r\nvar groupAnagrams = (words) => {\r\n  const groupedAnagrams = new Map();\r\n\r\n  for (let word of words) {\r\n    // Initialize an array to store the frequency of each letter\r\n    const key = new Array(26).fill(0);\r\n\r\n    // Count the frequency of each letter in the word\r\n    for (let letter of word) {\r\n      key[letter.charCodeAt(0) - 'a'.charCodeAt(0)]++;\r\n    }\r\n\r\n    // Convert the frequency array to a string to use as the key in the dictionary\r\n    const keyStr = key.join(',');\r\n\r\n    if (!groupedAnagrams.has(keyStr)) {\r\n      groupedAnagrams.set(keyStr, [])\r\n    }\r\n\r\n    groupedAnagrams.get(keyStr).push(word);\r\n\r\n  }\r\n  return Array.from(groupedAnagrams.values())\r\n}\r\n\r\n\r\n// key as a 26 digit string, Object\r\nvar groupAnagrams = (words) => {\r\n  const groupedAnagrams = {};\r\n\r\n  for (let word of words) {\r\n    // Initialize an array to store the frequency of each letter\r\n    const key = new Array(26).fill(0);\r\n\r\n    // Count the frequency of each letter in the word\r\n    for (let letter of word) {\r\n      key[letter.charCodeAt(0) - 'a'.charCodeAt(0)]++;\r\n    }\r\n\r\n    // Convert the frequency array to a string to use as the key in the dictionary\r\n    const keyStr = key.join(',');\r\n\r\n    if (!groupedAnagrams[keyStr]) {\r\n      groupedAnagrams[keyStr] = [];\r\n    }\r\n\r\n    groupedAnagrams[keyStr].push(word);\r\n\r\n  }\r\n  // return Array.from(groupedAnagrams.values())\r\n  return Object.values(groupedAnagrams)\r\n}\r\n\r\n\r\n// sort(), Map()\r\nvar groupAnagrams = (words) => {\r\n  const groupedAnagrams = new Map();\r\n\r\n  for (let word of words) {\r\n    let key = word.split('').sort().join(); // ''\r\n\r\n    if (!groupedAnagrams.has(key)) {\r\n      groupedAnagrams.set(key, [])\r\n    }\r\n\r\n    groupedAnagrams.get(key).push(word); // key, []\r\n\r\n  }\r\n  return Array.from(groupedAnagrams.values())\r\n}\r\n\r\n\r\n// sort(), Object\r\nvar groupAnagrams = (words) => {\r\n  const groupedAnagrams = {};\r\n\r\n  for (let word of words) {\r\n    let key = word.split('').sort().join('')\r\n\r\n    if (!groupedAnagrams[key]) {\r\n      groupedAnagrams[key] = []\r\n    }\r\n\r\n    groupedAnagrams[key].push(word);\r\n  }\r\n\r\n  return Object.values(groupedAnagrams)\r\n}", "testcase": "console.log(groupAnagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]), [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']])\r\nconsole.log(groupAnagrams([\"\"]), [[\"\"]])\r\nconsole.log(groupAnagrams([\"a\"]), [[\"a\"]])\r\nconsole.log(groupAnagrams([\"tin\", \"ram\", \"zip\", \"cry\", \"pus\", \"jon\", \"zip\", \"pyx\"]), [['tin'], ['ram'], ['zip', 'zip'], ['cry'], ['pus'], ['jon'], ['pyx']])\r\nconsole.log(groupAnagrams([\"bdddddddddd\", \"bbbbbbbbbbc\"]), [[\"bdddddddddd\"], [\"bbbbbbbbbbc\"]])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-20T20:19:17.207Z", "updated_at": "2024-08-20T20:19:17.227Z"}}, {"model": "python_problems.solution", "pk": 74, "fields": {"problem": 14, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\n// Map(), bucket - frequency list\r\nvar topKFrequent = (nums, solution_len) => {\r\n  counts = new Map();\r\n  bucket = new Array(nums.length + 1).fill(0);\r\n  solution = [];\r\n\r\n  // counts values\r\n  for (let num of nums) {\r\n    counts.set(num, (counts.get(num) ?? 0) + 1)\r\n  }\r\n\r\n  // bucket as a list of lists\r\n  // [[], [3], [2], [1], [], [], []]\r\n  for (let [key, val] of counts) {\r\n    if (!bucket[val]) {\r\n      bucket[val] = [];\r\n    }\r\n\r\n    bucket[val].push(key);\r\n  }\r\n\r\n  bucket.reverse()\r\n\r\n  // get top solution_len values\r\n  for (let numbers of bucket) {\r\n    if (numbers) {\r\n      for (let number of numbers) {\r\n        solution.push(number);\r\n\r\n        if (solution.length == solution_len) {\r\n          return solution\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\n// Object(), bucket - frequency list\r\nvar topKFrequent = (nums, solution_len) => {\r\n  counts = {};\r\n  bucket = new Array(nums.length + 1).fill(0);\r\n  solution = [];\r\n\r\n  // counts values\r\n  for (let num of nums) {\r\n    counts[num] = (counts[num] ?? 0) + 1\r\n  }\r\n\r\n  // bucket as a list of lists\r\n  for (let key of Object.keys(counts)) {\r\n    let val = counts[key];\r\n\r\n    if (!bucket[[val]]) {\r\n      bucket[val] = [];\r\n    }\r\n\r\n    bucket[val].push(key);\r\n  }\r\n\r\n  // get top solution_len values\r\n  for (let numbers of bucket.reverse()) {\r\n    if (numbers) {\r\n      for (let number of numbers) {\r\n        solution.push(number);\r\n\r\n        if (solution.length == solution_len) {\r\n          return solution\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\n// Map(), sort()\r\nvar topKFrequent = (nums, solution_len) => {\r\n  counts = new Map();\r\n  bucket = new Map();\r\n  solution = [];\r\n\r\n  // counts values\r\n  for (let num of nums) {\r\n    counts.set(num, (counts.get(num) ?? 0) + 1)\r\n  }\r\n\r\n  // reverse counts {key: val} pairs as bucket\r\n  for (let [key, val] of counts) {\r\n    if (!bucket.has(val)) {\r\n      bucket.set(val, []);\r\n    }\r\n    bucket.get(val).push(key);\r\n  }\r\n\r\n  // sort frequencies descending\r\n  let keys = (Array.from(bucket.keys())).sort((a, b) => b - a);\r\n\r\n  // get top solution_len values\r\n  for (let key of keys) {\r\n    for (let number of bucket.get(key)) {\r\n      solution.push(number);\r\n\r\n      if (solution.length == solution_len) {\r\n        return solution\r\n      }\r\n    }\r\n  }\r\n\r\n  return -1\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\n// Object, sort()\r\nvar topKFrequent = (nums, solution_len) => {\r\n  counts = {};\r\n  bucket = {};\r\n  solution = [];\r\n\r\n  // counts values\r\n  for (let num of nums) {\r\n    counts[num] = (counts[num] ?? 0) + 1;\r\n  }\r\n\r\n  // reverse counts {key: val} pairs as bucket\r\n  for (let key in counts) {\r\n    if (!bucket[counts[key]]) {\r\n      bucket[counts[key]] = [];\r\n    }\r\n\r\n    bucket[counts[key]].push(key);\r\n  }\r\n  \r\n  // sort frequencies descending\r\n  let keys = Object.keys(bucket).sort((a, b) => b - a);\r\n  \r\n  // get top solution_len values\r\n  for (let key of keys) {\r\n    for (let number of bucket[key]) {\r\n      solution.push(number);\r\n\r\n      if (solution.length == solution_len) {\r\n        return solution\r\n      }\r\n    }\r\n  }\r\n\r\n  return -1\r\n}", "testcase": "console.log(topKFrequent([1, 1, 1, 2, 2, 3], 2), [1, 2])\r\nconsole.log(topKFrequent([1], 1), [1])\r\nconsole.log(topKFrequent([5, 1, -1, -8, -7, 8, -5, 0, 1, 10, 8, 0, -4, 3, -1, -1, 4, -5, 4, -3, 0, 2, 2, 2, 4, -2, -4, 8, -7, -7, 2, -8, 0, -8, 10, 8, -8, -2, -9, 4, -7, 6, 6, -1, 4, 2, 8, -3, 5, -9, -3, 6, -8, -5, 5, 10, 2, -5, -1, -5, 1, -3, 7, 0, 8, -2, -3, -1, -5, 4, 7, -9, 0, 2, 10, 4, 4, -4, -1, -1, 6, -8, -9, -1, 9, -9, 3, 5, 1, 6, -1, -2, 4, 2, 4, -6, 4, 4, 5, -5], 7), [4, -1, 2, -5, 0, 8, -8])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-21T17:34:52.073Z", "updated_at": "2024-08-21T17:34:52.090Z"}}, {"model": "python_problems.solution", "pk": 75, "fields": {"problem": 53, "language": 2, "owner": 3, "solution": "var encode = (words) => {\r\n  let encoded = '';\r\n\r\n  for (let word of words) {\r\n    encoded += '';\r\n    encoded += word.length;\r\n    encoded += word;\r\n  }\r\n\r\n  return encoded\r\n}\r\n\r\nvar decode = (word) => {\r\n  let decoded = [];\r\n  \r\n  while (word) {    \r\n    if (word[0] == '') {\r\n      word = word.slice(1);\r\n      let len = '';\r\n      \r\n      while (word && word[0].search(/\\d/) != -1) {\r\n        len += word[0];\r\n        word = word.slice(1);\r\n      }\r\n\r\n      len = Number(len);\r\n      decoded.push(word.slice(0, len));\r\n      word = word.slice(len);\r\n    }\r\n  }\r\n  return decoded\r\n}", "testcase": "console.log(encode([\"code\", \"site\", \"love\", \"you\"]), '4code4site4love3you')\r\nconsole.log(decode(encode([\"code\", \"site\", \"love\", \"you\"])), [\"code\", \"site\", \"love\", \"you\"])\r\nconsole.log(decode(encode([])), [])\r\nconsole.log(decode(encode([''])), [''])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-08-21T20:37:43.608Z", "updated_at": "2024-08-22T13:50:55.174Z"}}, {"model": "python_problems.solution", "pk": 76, "fields": {"problem": 52, "language": 2, "owner": 3, "solution": "var productExceptSelf = (nums) => {\r\n  const prefix = [];\r\n  prefix[0] = 1;\r\n  const postfix = [];\r\n  postfix[nums.length - 1] = 1;\r\n  const solution = [];\r\n  \r\n  for (index = 0; index < nums.length - 1; index++) {\r\n      prefix[index + 1] = nums[index] * prefix[index]\r\n  }\r\n\r\n  for (index = nums.length - 1; index > 0; index--) {\r\n      solution[index] = prefix[index] * postfix[index]\r\n      postfix[index - 1] = nums[index] * postfix[index]\r\n  }\r\n  solution[0] = prefix[0] * postfix[0]\r\n\r\n  return solution\r\n}", "testcase": "console.log(productExceptSelf([2, 3, 4, 5]), [60, 40, 30, 24])\r\nconsole.log(productExceptSelf([1, 2, 3, 4]), [24, 12, 8, 6])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-22T13:12:37.575Z", "updated_at": "2024-08-22T13:13:19.381Z"}}, {"model": "python_problems.solution", "pk": 77, "fields": {"problem": 51, "language": 2, "owner": 3, "solution": "/**\r\n * @param {character[][]} board\r\n * @return {boolean}\r\n */\r\nclass Solution {\r\n  isSubboxValid(row, col) {\r\n    const seen = new Set();\r\n\r\n    for (let r = row; r < row + 3; r++) {\r\n      for (let c = col; c < col + 3; c++) {\r\n        let digit = this.board[r][c];\r\n\r\n        if (digit != '.') {\r\n          if (seen.has(digit)) {\r\n            return false\r\n          } else {\r\n            seen.add(digit);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  isValidSudoku(board) {\r\n    this.board = board\r\n    let rows = board.length;\r\n    let cols = board[0].length;\r\n\r\n    // validating rows\r\n    for (const row of board) {\r\n      const seen = new Set();\r\n\r\n      for (let digit of row) {\r\n        if (digit != '.') {\r\n          if (seen.has(digit)) {\r\n            return false\r\n          } else {\r\n            seen.add(digit);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // validating columns\r\n    for (let col = 0; col < cols; col++) {\r\n      const seen = new Set();\r\n\r\n      for (let row = 0; row < rows; row++) {\r\n        let digit = board[row][col];\r\n\r\n        if (digit != '.') {\r\n          if (seen.has(digit)) {\r\n            return false\r\n          } else {\r\n            seen.add(digit);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // validating sub-boxes\r\n    for (let row = 0; row < 3; row++) {\r\n      for (let col = 0; col < 3; col++) {\r\n        if (!this.isSubboxValid(3 * row, 3 * col)) {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}", "testcase": "console.log(new Solution().isValidSudoku([[\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"], [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"], [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"], [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"], [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"], [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"], [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"], [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"], [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]],), true)\r\nconsole.log(new Solution().isValidSudoku([[\"8\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"], [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"], [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"], [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"], [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"], [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"], [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"], [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"], [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]]), false)\r\nconsole.log(new Solution().isValidSudoku([[\".\", \".\", \".\", \".\", \"5\", \".\", \".\", \"1\", \".\"], [\".\", \"4\", \".\", \"3\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \".\", \".\", \"3\", \".\", \".\", \"1\"], [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \"2\", \".\"], [\".\", \".\", \"2\", \".\", \"7\", \".\", \".\", \".\", \".\"], [\".\", \"1\", \"5\", \".\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\"], [\".\", \"2\", \".\", \"9\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \"4\", \".\", \".\", \".\", \".\", \".\", \".\"]]), false)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-08-22T17:13:21.031Z", "updated_at": "2024-08-22T17:13:21.046Z"}}, {"model": "python_problems.solution", "pk": 78, "fields": {"problem": 15, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar longestConsecutive = (nums) => {\r\n  const numSet = new Set(nums);\r\n  let solution = 0\r\n\r\n  for (let num of numSet.values()) {\r\n    if (!numSet.has(num - 1)) {\r\n      let counter = 1;\r\n\r\n      while (numSet.has(num + counter)) {\r\n        counter++\r\n      }\r\n      solution = Math.max(solution, counter);\r\n    }\r\n  }\r\n  return solution\r\n}", "testcase": "console.log(longestConsecutive([100, 4, 200, 1, 3, 2]), 4)\r\nconsole.log(longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]), 9)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-22T18:28:06.501Z", "updated_at": "2024-08-22T18:28:06.516Z"}}, {"model": "python_problems.solution", "pk": 79, "fields": {"problem": 6, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar isPalindrome = (sentence) => {\r\n  let l = 0;\r\n  let r = sentence.length - 1;\r\n\r\n  while (l < r) {\r\n    while ((l < r) && (sentence[l].match(/[\\W_]/))) {\r\n      l++\r\n    }\r\n    \r\n    while ((l < r) && (sentence[r].match(/[\\W_]/))) {\r\n      r--\r\n    }\r\n    \r\n    if (sentence[l].toLowerCase() != sentence[r].toLowerCase()) {\r\n      return false\r\n    } else {\r\n      l++\r\n      r--\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\n\r\n// O(n), O(n)\r\n/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar isPalindrome = function (s) {\r\n  // Filter alphanumeric\r\n  s = s.replace(/[\\W_]/ig, '').toLowerCase();\r\n\r\n  // Reverse the string\r\n  reversed = s.split('').reverse().join('');\r\n\r\n  return s === reversed\r\n}", "testcase": "console.log(isPalindrome(\"A man, a plan, a canal: Panama\"), true)\r\nconsole.log(isPalindrome(\"race a car\"), false)\r\nconsole.log(isPalindrome(\" \"), true)\r\nconsole.log(isPalindrome(\"0P\"), false)\r\nconsole.log(isPalindrome(\"ab_a\"), true)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-08-22T19:56:03.866Z", "updated_at": "2024-08-22T19:56:03.881Z"}}, {"model": "python_problems.solution", "pk": 80, "fields": {"problem": 2, "language": 2, "owner": 3, "solution": "// Two Sum II - Input Array Is Sorted\r\n/**\r\n * @param {number[]} numbers\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar twoSum = (nums, target) => {\r\n  let left = 0;\r\n  let right = nums.length - 1;\r\n\r\n  while (left < right) {\r\n      currSum = nums[left] + nums[right]\r\n\r\n      if (currSum < target) {\r\n          left++\r\n      } else if (currSum > target) {\r\n          right--\r\n      } else {\r\n          return [++left, ++right]\r\n      }\r\n  }\r\n  return -1\r\n}", "testcase": "console.log(twoSum([2, 7, 11, 15], 9), [1, 2])\r\nconsole.log(twoSum([2, 3, 4], 6), [1, 3])\r\nconsole.log(twoSum([-1, 0], -1), [1, 2])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-08-23T09:29:59.882Z", "updated_at": "2024-08-23T09:46:20.335Z"}}, {"model": "python_problems.solution", "pk": 81, "fields": {"problem": 16, "language": 2, "owner": 3, "solution": "var threeSum = (nums) => {\r\n  nums.sort((a, b) => a - b);\r\n  const solution = [];\r\n\r\n  for (index = 0; index < nums.length - 2; index++) {\r\n      let num = nums[index];\r\n      // Skip positive nums\r\n      if (num > 0) {\r\n          break\r\n      }\r\n\r\n      // Skip same num values\r\n      if (index && nums[index] == nums[index - 1]) {\r\n          continue\r\n      }\r\n      \r\n      let left = index + 1;\r\n      let right = nums.length - 1;\r\n\r\n      // two pointers\r\n      while (left < right) {\r\n          let currSum = num + nums[left] + nums[right];\r\n\r\n          if (currSum < 0) {  // if sum is less than 0\r\n              left++;\r\n          } else if (currSum > 0) {  // if sum is greater than 0\r\n              right--;\r\n          } else {  // if sum is equal to 0\r\n              solution.push([num, nums[left], nums[right]])\r\n              left++;\r\n              right--;\r\n\r\n              // skip same left pointer values\r\n              while ((left < right) && (nums[left] == nums[left - 1])) {\r\n                  left++;\r\n              }\r\n          }\r\n      }\r\n  }\r\n  return solution\r\n}", "testcase": "console.log(threeSum([-1, 0, 1, 2, -1, -4]), [[-1, -1, 2], [-1, 0, 1]])\r\nconsole.log(threeSum([3, 0, -2, -1, 1, 2]), [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]])\r\nconsole.log(threeSum([1, 1, -2]), [[-2, 1, 1]])\r\nconsole.log(threeSum([-1, 1, 1]), [])\r\nconsole.log(threeSum([0, 0, 0]), [[0, 0, 0]])\r\nconsole.log(threeSum([-2, 0, 0, 2, 2]), [[-2, 0, 2]])", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-08-23T10:50:23.330Z", "updated_at": "2024-08-23T10:50:23.345Z"}}, {"model": "python_problems.solution", "pk": 82, "fields": {"problem": 17, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} height\r\n * @return {number}\r\n */\r\nvar maxArea = (heights) => {\r\n    let maxArea = 0;\r\n    let left = 0;\r\n    let right = heights.length - 1;\r\n\r\n    while (left < right) {\r\n        let currArea = (right - left) * Math.min.apply(null, [heights[left], heights[right]]);\r\n        maxArea = Math.max.apply(null, [maxArea, currArea])\r\n\r\n        if (heights[left] < heights[right]) {\r\n            left++;\r\n        } else {\r\n            right--;\r\n        }\r\n    }\r\n    return maxArea\r\n}", "testcase": "console.log(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]), 49)\r\nconsole.log(maxArea([1, 1]), 1)\r\nconsole.log(maxArea([2, 3, 4, 5, 18, 17, 6]), 17)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-08-23T12:06:07.758Z", "updated_at": "2024-08-23T12:06:07.776Z"}}, {"model": "python_problems.solution", "pk": 83, "fields": {"problem": 29, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} height\r\n * @return {number}\r\n */\r\nvar trap = (heights) => {\r\n  let left = 0;\r\n  let right = heights.length - 1;\r\n  let trappedWater = 0;\r\n  let leftMaxHeight = 0;\r\n  let rightMaxHeight = 0;\r\n\r\n  // two pointers\r\n  while (left < right) {\r\n      if (heights[left] < heights[right]) {  // choose the lower height because it gets to higher eventually\r\n          leftMaxHeight = Math.max(leftMaxHeight, heights[left]);\r\n          let currentTrap = leftMaxHeight - heights[left];\r\n          trappedWater += currentTrap;\r\n          left++;\r\n      } else {\r\n          rightMaxHeight = Math.max(rightMaxHeight, heights[right]);\r\n          let currentTrap = rightMaxHeight - heights[right];\r\n          trappedWater += currentTrap;\r\n          right--;\r\n      }\r\n  }\r\n  return trappedWater\r\n}", "testcase": "console.log(trap([1, 3, 2, 1, 2, 1, 5, 3, 3, 4, 2]), 8)\r\nconsole.log(trap([5, 8]), 0)\r\nconsole.log(trap([3, 1, 2]), 1)\r\nconsole.log(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), 6)\r\nconsole.log(trap([4, 2, 0, 3, 2, 5]), 9)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-08-23T12:43:04.781Z", "updated_at": "2024-08-23T13:05:35.049Z"}}, {"model": "python_problems.solution", "pk": 84, "fields": {"problem": 3, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar isValid = (brackets) => {\r\n  const oppos_brackets = { ']': '[', '}': '{', ')': '(' };\r\n  const seen = [];\r\n\r\n  for (let bracket of brackets) {\r\n    if (bracket in oppos_brackets) {\r\n      if (oppos_brackets[bracket] == seen[seen.length - 1]) {\r\n        seen.pop();\r\n      } else {\r\n        return false\r\n      }\r\n    } else {\r\n      seen.push(bracket)\r\n    }\r\n  }\r\n  return !Boolean(seen.length)\r\n}", "testcase": "console.log(isValid(\"()\"), true)\r\nconsole.log(isValid(\"({})\"), true)\r\nconsole.log(isValid(\"(})\"), false)\r\nconsole.log(isValid(\"([)\"), false)\r\nconsole.log(isValid(\"(]\"), false)\r\nconsole.log(isValid(\"\"), true)\r\nconsole.log(isValid(\"[\"), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-23T16:08:21.074Z", "updated_at": "2024-08-23T16:08:21.093Z"}}, {"model": "python_problems.solution", "pk": 85, "fields": {"problem": 4, "language": 2, "owner": 3, "solution": "var dir_reduc = (directions) => {\r\n  const oppos_direction = { \"NORTH\": \"SOUTH\", \"SOUTH\": \"NORTH\", \"EAST\": \"WEST\", \"WEST\": \"EAST\" };\r\n  const seen = [];\r\n\r\n  for (let direction of directions) {\r\n    if (oppos_direction[direction] === seen[seen.length - 1]) {\r\n      seen.pop();\r\n    } else {\r\n      seen.push(direction)\r\n    }\r\n  }\r\n  return seen\r\n}", "testcase": "console.log(dir_reduc(['NORTH', 'SOUTH', 'SOUTH', 'EAST', 'WEST', 'NORTH', 'WEST']), ['WEST'])\r\nconsole.log(dir_reduc(['NORTH', 'EAST', 'WEST', 'SOUTH', 'WEST', 'WEST']), ['WEST', 'WEST'])\r\nconsole.log(dir_reduc(['NORTH', 'WEST', 'SOUTH', 'EAST']), ['NORTH', 'WEST', 'SOUTH', 'EAST'])\r\nconsole.log(dir_reduc([]), [])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-23T16:33:23.213Z", "updated_at": "2024-08-23T16:33:23.228Z"}}, {"model": "python_problems.solution", "pk": 86, "fields": {"problem": 59, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string[]} tokens\r\n * @return {number}\r\n */\r\nfunction evalRPN(tokens) {\r\n  const stack = [];\r\n\r\n  for (let token of tokens) {\r\n    if (token == '+') {\r\n      stack.push(stack.pop() + stack.pop());\r\n    } else if (token == '*') {\r\n      stack.push(stack.pop() * stack.pop());\r\n    } else if (token == '-') {\r\n      let b = stack.pop();\r\n      let a = stack.pop();\r\n      stack.push(a - b);\r\n    } else if (token == '/') {\r\n      let b = stack.pop();\r\n      let a = stack.pop();\r\n      stack.push(Math.trunc(a / b));\r\n    } else {\r\n      stack.push(Number(token));\r\n    }\r\n  }\r\n  return stack[0]\r\n}", "testcase": "console.log(evalRPN([\"2\", \"1\", \"+\", \"3\", \"*\"]), 9)\r\nconsole.log(evalRPN([\"4\", \"13\", \"5\", \"/\", \"+\"]), 6)\r\nconsole.log(evalRPN([\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]), 22)\r\nconsole.log(evalRPN([\"18\"]), 18)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-24T13:36:01.097Z", "updated_at": "2024-08-24T13:36:01.113Z"}}, {"model": "python_problems.solution", "pk": 87, "fields": {"problem": 60, "language": 2, "owner": 3, "solution": "// O(n)\r\nfunction dailyTemperatures(temps) {\r\n  const daysDelta = Array(temps.length).fill(0)\r\n  const stack = [];\r\n\r\n  for (let index = 0; index < temps.length; index++) {\r\n      let temp = temps[index];\r\n\r\n      while (stack.length && stack[stack.length - 1][1] < temp) {    // check for lower temps\r\n          stack_index = stack[stack.length - 1][0];  // take top stack element index\r\n          \r\n          daysDelta[stack_index] = index - stack_index;  // update delta_days\r\n          stack.pop();  // pop lower temp\r\n      }\r\n\r\n      stack.push([index, temp]);\r\n  }\r\n  return daysDelta\r\n}\r\n\r\n\r\n// O(n2)\r\nfunction dailyTemperatures(temps) {\r\n  const daysDelta = Array(temps.length).fill(0)\r\n\r\n  for (let indL = 0; indL < temps.length - 1; indL++) {\r\n      for (let indR = indL + 1; indR < temps.length; indR++) {\r\n          if (temps[indL] < temps[indR]) {\r\n              daysDelta[indL] = indR - indL;\r\n              break\r\n          }\r\n      }\r\n  }\r\n  return daysDelta\r\n}", "testcase": "console.log(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]), [1, 1, 4, 2, 1, 1, 0, 0])\r\nconsole.log(dailyTemperatures([30, 40, 50, 60]), [1, 1, 1, 0])\r\nconsole.log(dailyTemperatures([30, 60, 90]), [1, 1, 0])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-24T17:19:27.260Z", "updated_at": "2024-08-24T17:19:27.275Z"}}, {"model": "python_problems.solution", "pk": 88, "fields": {"problem": 61, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number} target\r\n * @param {number[]} position\r\n * @param {number[]} speed\r\n * @return {number}\r\n */\r\nfunction carFleet(target, positions, speeds) {\r\n  const fleetStack = [];\r\n  \r\n  // const cars = Array(positions.length).fill(0);\r\n  // for (let index = 0; index < positions.length; index++) {  // zip positions and speed\r\n  //     cars[index] = [positions[index], speeds[index]]\r\n  // }\r\n\r\n  const cars = positions.map((position, index) => [position, speeds[index]]);\r\n\r\n  cars.sort((a, b) => (b[0] - a[0]));  // sort the cars so to start with the one closest to the target\r\n\r\n  for (let [position, speed] of cars) {\r\n      let currDist = (target - position) / speed;  // distance to the target\r\n          if (fleetStack && currDist <= fleetStack[fleetStack.length - 1]) {  // if the car behind cought up next car\r\n              continue\r\n          }\r\n      fleetStack.push(currDist);  // push a car to a stack\r\n  }\r\n\r\n  return fleetStack.length\r\n}", "testcase": "console.log(carFleet(12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]), 3)\r\nconsole.log(carFleet(10, [3], [3]), 1)\r\nconsole.log(carFleet(100, [0, 2, 4], [4, 2, 1]), 1)\r\nconsole.log(carFleet(10, [0, 4, 2], [2, 1, 3]), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-24T20:13:43.807Z", "updated_at": "2024-08-24T20:13:43.826Z"}}, {"model": "python_problems.solution", "pk": 89, "fields": {"problem": 47, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nfunction search(nums, target) {\r\n  let left = 0;\r\n  let right = nums.length - 1;\r\n  \r\n  while (left <= right) {  // two poionters\r\n      let mid = Math.trunc((left + right) / 2)  // find mid index\r\n      // let mid = ((left + right) >> 1);  // shift bits\r\n\r\n      if (target == nums[mid]) {  // if target found\r\n          return mid\r\n      } else if (target < nums[mid]) {  // if target is less than middle, choose left chunk\r\n          right = mid - 1;\r\n      } else {  // # if target is greater than middle, choose rigth chunk\r\n          left = mid + 1;\r\n      }\r\n  }\r\n  return -1\r\n}", "testcase": "console.log(search([-1, 0, 3, 5, 9, 12], -1), 0)\r\nconsole.log(search([-1, 0, 3, 5, 9, 12], 0), 1)\r\nconsole.log(search([-1, 0, 3, 5, 9, 12], 3), 2)\r\nconsole.log(search([-1, 0, 3, 5, 9, 12], 5), 3)\r\nconsole.log(search([-1, 0, 3, 5, 9, 12], 9), 4)\r\nconsole.log(search([-1, 0, 3, 5, 9, 12], 12), 5)\r\nconsole.log(search([-1, 0, 3, 5, 9, 12], 2), -1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-08-25T10:29:52.551Z", "updated_at": "2024-08-25T11:05:28.496Z"}}, {"model": "python_problems.solution", "pk": 90, "fields": {"problem": 48, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[][]} matrix\r\n * @param {number} target\r\n * @return {boolean}\r\n */\r\nfunction searchMatrix(matrix, target) {\r\n    let left = 0;  // boundries\r\n    let right = matrix[0].length - 1;\r\n    let top = 0;\r\n    let bottom = matrix.length - 1;\r\n\r\n    while (top <= bottom) {  // two poionters to find the right row\r\n        mid_row = (top + bottom) >> 1;  // find middle row index\r\n\r\n        if (target >= matrix[mid_row][left] &&\r\n            target <= matrix[mid_row][right]) {  // if target row found\r\n            break\r\n        } else if (target < matrix[mid_row][left]) {  // if target is less than the most left, choose top chunk\r\n            bottom = mid_row - 1;\r\n        } else {  // if target is grater than the most right, choose bottom chunk\r\n            top = mid_row + 1;\r\n        }\r\n    }\r\n\r\n    while (left <= right) {  // two poionters to find the right column\r\n        mid_col = (left + right) >> 1;  // find middle column index\r\n\r\n        if (target == matrix[mid_row][mid_col]) {  // if target column found\r\n            return true\r\n        } else if (target < matrix[mid_row][mid_col]) {  // if target is less than middle colum, choose left chunk\r\n            right = mid_col - 1;\r\n        } else {  // if target is greater than middle colum, choose rigth chunk\r\n            left = mid_col + 1;\r\n        }\r\n    }\r\n\r\n    return false\r\n}", "testcase": "console.log(searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 3), true)\r\nconsole.log(searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 13), false)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-08-25T11:34:06.991Z", "updated_at": "2024-08-25T11:34:07.010Z"}}, {"model": "python_problems.solution", "pk": 91, "fields": {"problem": 49, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} piles\r\n * @param {number} h\r\n * @return {number}\r\n */\r\nfunction minEatingSpeed(piles, hours) {\r\n    let left = 1;\r\n    let right = Math.max.apply(null, piles);\r\n    let solution;  // Declare solution outside the loop\r\n\r\n    while (left <= right) {\r\n        let mid = (left + right) >> 1;\r\n\r\n        // let timeToEat = 0\r\n        // for (let pile of piles) {\r\n        //     timeToEat += Math.ceil(pile / mid);\r\n        // }\r\n\r\n        let timeToEat = piles.reduce((totalTime, pile) => totalTime + Math.ceil(pile / mid), 0);\r\n\r\n        // time to guard to get back >= time to eat all bananas\r\n        if (hours >= timeToEat) {  // enough time, this might be the solution but also eat a little slower\r\n            solution = mid;  // Store the potential solution\r\n            right = --mid;  // Try to eat slower\r\n        } else {  // not enough time\r\n            left = ++mid;  // need to eat faster\r\n        }\r\n    }\r\n\r\n    return solution\r\n}", "testcase": "console.log(minEatingSpeed([3, 6, 7, 11], 8), 4)\r\nconsole.log(minEatingSpeed([30, 11, 23, 4, 20], 5), 30)\r\nconsole.log(minEatingSpeed([30, 11, 23, 4, 20], 6), 23)\r\nconsole.log(minEatingSpeed([312884470], 312884469), 2)\r\nconsole.log(minEatingSpeed([3], 2), 2)", "time_complexity": 5, "space_complexity": 1, "created_at": "2024-08-25T15:29:12.474Z", "updated_at": "2024-08-25T17:32:09.424Z"}}, {"model": "python_problems.solution", "pk": 92, "fields": {"problem": 26, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nfunction findMin(nums) {\r\n    let left = 0;\r\n    let right = nums.length - 1;\r\n    let currMin = nums[0];\r\n\r\n    while (left <= right) {\r\n        let mid = (left + right) >> 1;\r\n        currMin = Math.min(currMin, nums[mid])\r\n\r\n        if (nums[mid] < nums[right]) {\r\n            right = --mid;\r\n        } else {\r\n            left = ++mid;\r\n        }\r\n    }\r\n    return currMin\r\n}", "testcase": "console.log(findMin([1, 2, 3, 4]), 1)\r\nconsole.log(findMin([4, 1, 2, 3]), 1)\r\nconsole.log(findMin([2, 3, 4, 1]), 1)\r\nconsole.log(findMin([3, 4, 1, 2]), 1)\r\nconsole.log(findMin([4, 5, 1, 2, 3]), 1)\r\nconsole.log(findMin([5, 1, 2, 3, 4]), 1)\r\nconsole.log(findMin([1, 2, 3, 4, 5]), 1)\r\nconsole.log(findMin([2, 3, 4, 5, 1]), 1)\r\nconsole.log(findMin([3, 4, 5, 1, 2]), 1)\r\nconsole.log(findMin([4, 5, 6, 7, 0, 1, 2]), 0)\r\nconsole.log(findMin([11, 13, 15, 17]), 11)\r\nconsole.log(findMin([1]), 1)\r\nconsole.log(findMin([3, 1, 2]), 1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-08-25T17:57:48.430Z", "updated_at": "2024-08-25T17:57:48.445Z"}}, {"model": "python_problems.solution", "pk": 93, "fields": {"problem": 50, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nfunction search(nums, target) {\r\n  let left = 0;\r\n  let right = nums.length - 1;\r\n\r\n  while (left <= right) {  // two pointers\r\n      let mid = (left + right) >> 1; // get middle index\r\n\r\n      if (target == nums[mid]) {  // if target found\r\n          return mid\r\n      } else if (nums[mid] < nums[right]) {  // [5, 1, 2, 3, 4] the right chunk [3, 4] is ascending the other has a pivot\r\n          if (nums[mid] < target && target <= nums[right]) {\r\n              left = ++mid;\r\n          } else {\r\n              right = --mid;\r\n          }\r\n      } else {  // [2, 3, 4, 5, 1] the left chunk [2, 3] is ascending the other has a pivot\r\n          if (nums[left] <= target && target < nums[mid]) {\r\n              right = --mid;\r\n          } else {\r\n              left = ++mid\r\n          }\r\n      }\r\n  }\r\n  return -1\r\n}", "testcase": "console.log(search([4, 5, 6, 7, 8, 1, 2, 3], 8), 4)\r\nconsole.log(search([1, 3, 5], 5), 2)\r\nconsole.log(search([3, 5, 1], 3), 0)\r\nconsole.log(search([3, 5, 1], 1), 2)\r\nconsole.log(search([5, 1, 3], 3), 2)\r\nconsole.log(search([4, 5, 6, 7, 0, 1, 2], 0), 4)\r\nconsole.log(search([4, 5, 6, 7, 0, 1, 2], 3), -1)\r\nconsole.log(search([1], 0), -1)\r\nconsole.log(search([5, 1, 3], 4), -1)\r\nconsole.log(search([4, 5, 6, 7, 8, 1, 2, 3], 8), 4)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-08-25T19:55:14.646Z", "updated_at": "2024-08-25T19:55:14.661Z"}}, {"model": "python_problems.solution", "pk": 94, "fields": {"problem": 71, "language": 1, "owner": 3, "solution": "class TimeMap:\r\n    def __init__(self):\r\n        self.store = {}\r\n\r\n    def set(self, key: str, value: str, timestamp: int) -> None:\r\n        if not key in self.store:  # if no key at the store add this key with list as value\r\n            self.store[key] = []\r\n        \r\n        self.store[key].append([value, timestamp])  # push value, timestamp pair to the store\r\n\r\n    def get(self, key: str, timestamp: int) -> str:\r\n        if not key in self.store:  # when searching for a key that's not in the store\r\n            return \"\"\r\n        \r\n        values = self.store[key]\r\n\r\n        left = 0\r\n        right = len(values) - 1\r\n        solution = \"\"  # if there is on solution returns \"\"\r\n\r\n        while left <= right:  # two pointers\r\n            mid = (left + right) // 2\r\n            mid_value = values[mid]\r\n\r\n            if timestamp == mid_value[1]:\r\n                return values[mid][0]\r\n            elif timestamp < mid_value[1]:  # if timestamp is lower than middle, that means the middle and all to the right is too high, so check left chunk\r\n                right = mid - 1\r\n            else:  # if temistamp is higher than middle, that means the middle and all to the left is too low, so check right chunk\r\n                left = mid + 1\r\n                solution = mid_value[0]  # save the middle because the higher values migght be too high\r\n\r\n        return solution\r\n\r\n# Your TimeMap object will be instantiated and called as such:\r\n# obj = TimeMap()\r\n# obj.set(key,value,timestamp)\r\n# param_2 = obj.get(key,timestamp)\r\n\r\n# Example 1\r\ntimeMap = TimeMap()\r\ntimeMap.set(\"foo\", \"bar\", 1)\r\ntimeMap.get(\"foo\", 1)\r\ntimeMap.get(\"foo\", 3)\r\ntimeMap.set(\"foo\", \"bar2\", 4)\r\ntimeMap.get(\"foo\", 4)\r\ntimeMap.get(\"foo\", 5)\r\n# Output: [null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]\r\n\r\n# Example 2\r\ntimeMap = TimeMap()\r\ntimeMap.set(\"love\",\"high\",10)\r\ntimeMap.set(\"love\",\"low\",20)\r\ntimeMap.get(\"love\",5)\r\ntimeMap.get(\"love\",10)\r\ntimeMap.get(\"love\",15)\r\ntimeMap.get(\"love\",20)\r\ntimeMap.get(\"love\",25)\r\n# Ouput: [null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"]\r\n\r\n# Example 3\r\ntimeMap = TimeMap()\r\ntimeMap.set(\"a\", \"bar\", 1)\r\ntimeMap.set(\"x\", \"b\", 3)\r\ntimeMap.get(\"b\", 3)\r\ntimeMap.set(\"foo\", \"bar2\", 4)\r\ntimeMap.get(\"foo\", 4)\r\ntimeMap.get(\"foo\", 5)\r\n# Output: [null,null,null,\"\",null,\"bar2\",\"bar2\"]", "testcase": "", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-08-26T21:05:17.395Z", "updated_at": "2024-08-27T11:13:13.237Z"}}, {"model": "python_problems.solution", "pk": 95, "fields": {"problem": 71, "language": 2, "owner": 3, "solution": "// using class, store as Object()\r\nclass TimeMap {\r\n  constructor() {\r\n    this.store = {};\r\n  }\r\n\r\n  set = function (key, value, timestamp) {\r\n    if (!this.store[key]) {\r\n      this.store[key] = [];\r\n    }\r\n\r\n    this.store[key].push([value, timestamp])\r\n  }\r\n\r\n  get = function (key, timestamp) {\r\n    if (!this.store[key]) {\r\n      return ''\r\n    }\r\n\r\n    let left = 0;\r\n    let right = this.store[key].length - 1;\r\n    let solution = '';\r\n\r\n    while (left <= right) {\r\n      let mid = (left + right) >> 1;\r\n      let midValue = this.store[key][mid];\r\n\r\n      if (timestamp == midValue[1]) {\r\n        return midValue[0]\r\n      } else if (timestamp < midValue[1]) {\r\n        right = --mid;\r\n      } else {\r\n        left = ++mid;\r\n        solution = midValue[0];\r\n      }\r\n    }\r\n    return solution\r\n  }\r\n}\r\n\r\n\r\n/** \r\n * Your TimeMap object will be instantiated and called as such:\r\n * var obj = new TimeMap()\r\n * obj.set(key,value,timestamp)\r\n * var param_2 = obj.get(key,timestamp)\r\n */\r\n\r\n// Example 1\r\nobj = new TimeMap()\r\n// console.log(obj.set(\"foo\", \"bar\", 1))\r\n// console.log(obj.get(\"foo\", 1))\r\n// console.log(obj.get(\"foo\", 3))\r\n// console.log(obj.set(\"foo\", \"bar2\", 4))\r\n// console.log(obj.get(\"foo\", 4))\r\n// console.log(obj.get(\"foo\", 5))\r\n// Output: [null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]\r\n\r\n// Example 2\r\nobj = new TimeMap()\r\n// console.log(obj.set(\"love\", \"high\", 10))\r\n// console.log(obj.set(\"love\", \"low\", 20))\r\n// console.log(obj.get(\"love\", 5))\r\n// console.log(obj.get(\"love\", 10))\r\n// console.log(obj.get(\"love\", 15))\r\n// console.log(obj.get(\"love\", 20))\r\n// console.log(obj.get(\"love\", 25))\r\n// Ouput: [null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"]\r\n\r\n// Example 3\r\n// obj = new TimeMap()\r\n// console.log(obj.set(\"a\", \"bar\", 1))\r\n// console.log(obj.set(\"x\", \"b\", 3))\r\n// console.log(obj.get(\"b\", 3))\r\n// console.log(obj.set(\"foo\", \"bar2\", 4))\r\n// console.log(obj.get(\"foo\", 4))\r\n// console.log(obj.get(\"foo\", 5))\r\n// Output: [null,null,null,\"\",null,\"bar2\",\"bar2\"]\r\n\r\n\r\n// methods with prototype, store as Map()\r\nvar TimeMap = function () {\r\n  this.store = new Map();\r\n};\r\n\r\n/** \r\n * @param {string} key \r\n * @param {string} value \r\n * @param {number} timestamp\r\n * @return {void}\r\n */\r\n\r\nTimeMap.prototype.set = function (key, value, timestamp) {\r\n  if (!this.store.has(key)) {\r\n    this.store.set(key, []);\r\n  }\r\n\r\n  this.store.get(key).push([value, timestamp])\r\n};\r\n\r\n/** \r\n * @param {string} key \r\n * @param {number} timestamp\r\n * @return {string}\r\n */\r\nTimeMap.prototype.get = function (key, timestamp) {\r\n  if (!this.store.has(key)) {\r\n    return ''\r\n  }\r\n\r\n  let left = 0;\r\n  let right = this.store.get(key).length - 1;\r\n  let solution = '';\r\n\r\n  while (left <= right) {\r\n    let mid = (left + right) >> 1;\r\n    let midValue = this.store.get(key)[mid];\r\n\r\n    if (timestamp == midValue[1]) {\r\n      return midValue[0]\r\n    } else if (timestamp < midValue[1]) {\r\n      right = --mid;\r\n    } else {\r\n      left = ++mid;\r\n      solution = midValue[0];\r\n    }\r\n  }\r\n  return solution\r\n}\r\n\r\n// Example 3\r\nobj = new TimeMap()\r\nconsole.log(obj.set(\"a\", \"bar\", 1))\r\nconsole.log(obj.set(\"x\", \"b\", 3))\r\nconsole.log(obj.get(\"b\", 3))\r\nconsole.log(obj.set(\"foo\", \"bar2\", 4))\r\nconsole.log(obj.get(\"foo\", 4))\r\nconsole.log(obj.get(\"foo\", 5))\r\n// Output: [null,null,null,\"\",null,\"bar2\",\"bar2\"]", "testcase": "", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-08-27T10:47:58.624Z", "updated_at": "2024-08-27T11:13:23.309Z"}}, {"model": "python_problems.solution", "pk": 96, "fields": {"problem": 23, "language": 2, "owner": 3, "solution": "// pointers as indexes\r\n/**\r\n * @param {number[]} prices\r\n * @return {number}\r\n */\r\nfunction maxProfit(prices) {\r\n  let left = 0;  // the left pointer as index\r\n  let right = 1;  // the right pointer as index\r\n  let maxProfit = 0;\r\n\r\n  while (right < prices.length) {  // bound the right pointer\r\n    if (prices[left] > prices[right]) {  // if price is lower buy\r\n      left = right;\r\n    } else {  // if price is higher calculate revenue\r\n      let currentProfit = prices[right] - prices[left];\r\n      maxProfit = Math.max(maxProfit, currentProfit);\r\n    }\r\n      right++;\r\n  }\r\n  return maxProfit\r\n}\r\n\r\n\r\n// pointers as values\r\n/**\r\n * @param {number[]} prices\r\n * @return {number}\r\n */\r\nfunction maxProfit(prices) {\r\n  let left = prices[0];  // the left pointer as value\r\n  let maxProfit = 0;\r\n\r\n  for (right of prices) {  // the right pointer as value\r\n    if (left > right) {  // if price is lower buy\r\n      left = right;\r\n    } else {  // if price is higher calculate revenue\r\n      let currentProfit = right - left;\r\n      maxProfit = Math.max(maxProfit, currentProfit);\r\n    }\r\n  }\r\n  return maxProfit\r\n}", "testcase": "console.log(maxProfit([7, 1, 5, 3, 6, 4]), 5)\r\nconsole.log(maxProfit([7, 6, 4, 3, 1]), 0)\r\nconsole.log(maxProfit([2, 4, 1]), 2)\r\nconsole.log(maxProfit([2, 1, 2, 1, 0, 1, 2]), 2)\r\nconsole.log(maxProfit([1, 2]), 1)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-08-27T12:20:03.410Z", "updated_at": "2024-08-27T12:20:03.427Z"}}, {"model": "python_problems.solution", "pk": 97, "fields": {"problem": 19, "language": 2, "owner": 3, "solution": "", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-27T14:01:31.518Z", "updated_at": "2024-08-27T14:04:13.896Z"}}, {"model": "python_problems.solution", "pk": 98, "fields": {"problem": 24, "language": 2, "owner": 3, "solution": "// # O(n), O(n)\r\n// window as set()\r\n// both pointers as indexes\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nfunction lengthOfLongestSubstring(word) {\r\n  const window = new Set();  // slidiong window without repeating characters\r\n  let longest = 0;\r\n  let left = 0;  // left pointer\r\n\r\n  for (let right in word) {  // right pointer\r\n    while (window.has(word[right])) {  // if duplicate found\r\n      window.delete(word[left]);  // delete (remove, discard) that charactr with every preceding character\r\n      left++;  // increase the left pointer\r\n    }\r\n\r\n    window.add(word[right]);  // add an unique letter\r\n    longest = Math.max(longest, right - left + 1);  // update the length of the longest substring\r\n  }\r\n  return longest\r\n}\r\n\r\n\r\n// window as set()\r\n// right pointer as a value (letter), left as index\r\n/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nfunction lengthOfLongestSubstring(word) {\r\n  const window = new Set();  // slidiong window without repeating characters\r\n  let longest = 0;\r\n  let index = 0;  // index of the first 'letter' in the 'word'\r\n\r\n  for (let right of word) {  // right pointer\r\n    while (window.has(right)) {  // if duplicate found\r\n      window.delete(word[index]);  // delete (remove, discard) that charactr with every preceding character\r\n      index++;  // increase the index\r\n    }\r\n\r\n    window.add(right);  // add an unique letter\r\n    longest = Math.max(longest, window.size);  // update the length of the longest substring\r\n  }\r\n  return longest\r\n}", "testcase": "console.log(lengthOfLongestSubstring(\"abcabcbb\"), 3)\r\nconsole.log(lengthOfLongestSubstring(\"bbbbb\"), 1)\r\nconsole.log(lengthOfLongestSubstring(\"pwwkew\"), 3)\r\nconsole.log(lengthOfLongestSubstring(\"aabaab!bb\"), 3)\r\nconsole.log(lengthOfLongestSubstring(\"aab\"), 2)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-27T14:02:39.892Z", "updated_at": "2024-08-27T14:02:39.906Z"}}, {"model": "python_problems.solution", "pk": 99, "fields": {"problem": 54, "language": 2, "owner": 3, "solution": "// window as Map()\r\n/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nfunction characterReplacement(word, joker) {\r\n  const window = new Map();\r\n  let left = 0;\r\n  let longest = 0;\r\n\r\n  for (let right in word) {\r\n    window.set(word[right], (window.get(word[right]) ?? 0) + 1)\r\n\r\n    if ((right - left + 1) - Math.max(...window.values()) > joker) {\r\n      window.set(word[left], window.get(word[left]) - 1);\r\n      left++;\r\n    }\r\n\r\n    longest = Math.max(longest, (right - left + 1));\r\n  }\r\n  return longest\r\n}\r\n\r\n\r\n// window as Object()\r\n/**\r\n * @param {string} s\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nfunction characterReplacement(word, joker) {\r\n  const window = {};\r\n  let left = 0;\r\n  let longest = 0;\r\n\r\n  for (let right in word) {\r\n    window[word[right]] = (window[word[right]] ?? 0) + 1\r\n\r\n    if ((right - left + 1) - Math.max(...Object.values(window)) > joker) {\r\n      window[word[left]] -=1;\r\n      left++;\r\n    }\r\n\r\n    longest = Math.max(longest, (right - left + 1));\r\n  }\r\n  return longest\r\n}", "testcase": "console.log(characterReplacement(\"ABAB\", 2), 4)\r\nconsole.log(characterReplacement(\"AABABBA\", 1), 4)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-27T19:50:15.967Z", "updated_at": "2024-08-27T19:50:15.982Z"}}, {"model": "python_problems.solution", "pk": 100, "fields": {"problem": 55, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} s1\r\n * @param {string} s2\r\n * @return {boolean}\r\n */\r\nfunction checkInclusion(s1, s2) {\r\n  let counter = 0;  // counts how many keys (letters) in 'window' have exactly match in 's1_count'\r\n  let left = 0;  // left pointer\r\n  const window = new Map();  // window as Map()\r\n  const s1Count = new Map();  // Map() from s1\r\n\r\n  for (letter of s1) {  // Map() from s1\r\n      s1Count.set(letter, (s1Count.get(letter) ?? 0) + 1);\r\n  }\r\n\r\n  for (right in s2) {  // right pointer\r\n      let letter = s2[right];\r\n      window.set(letter, (window.get(letter) ?? 0) + 1);  // add a letter to the window\r\n\r\n      if (s1Count.get(letter) == window.get(letter)) {  // if letter occurences match\r\n          counter++;\r\n\r\n          if (counter == s1Count.size) {  // if cunter is equal to s1Count that means all letter occurences are matching\r\n              return true\r\n          }\r\n      }\r\n\r\n      if (s1.length > right - left + 1) {  // if window is not long enough\r\n          continue\r\n      }\r\n\r\n      // if the letter at left pointer that's going to be removed is significant then need to lower the 'counter'\r\n      if (s1Count.get(s2[left]) == window.get(s2[left])) { // if letter occurences match\r\n          counter--;\r\n      }\r\n\r\n      window.set(s2[left], window.get(s2[left]) - 1)  // remove a letter at the left pointer from the window\r\n      left++;\r\n  }\r\n  return false\r\n}", "testcase": "console.log(checkInclusion(\"ab\", \"eidbaooo\"), true)\r\nconsole.log(checkInclusion(\"ab\", \"eidboaoo\"), false)\r\nconsole.log(checkInclusion(\"ccc\", \"cbac\"), false)\r\nconsole.log(checkInclusion(\"ab\", \"a\"), false)\r\nconsole.log(checkInclusion(\"abcdxabcde\", \"abcdeabcdx\"), true)\r\nconsole.log(checkInclusion(\"adc\", \"dcda\"), true)\r\nconsole.log(checkInclusion(\"hello\", \"ooolleoooleh\"), false)\r\nconsole.log(checkInclusion(\"mart\", \"karma\"), false)\r\nconsole.log(checkInclusion(\"abc\", \"ccccbbbbaaaa\"), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-28T13:21:34.871Z", "updated_at": "2024-08-28T13:21:34.889Z"}}, {"model": "python_problems.solution", "pk": 101, "fields": {"problem": 56, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {string}\r\n */\r\nfunction minWindow(outer_string, substring) {\r\n  if (outer_string.length < substring.length) {  // when substring in longer than searched string\r\n    return ''\r\n  }\r\n\r\n  const substringCount = new Map();  // substring Map()\r\n  const window = new Map();  // window as Map()\r\n  let counter = 0;  // counts how many keys (letters) in 'window' have exactly match in searched string\r\n  let left = 0;  // left pointer\r\n  let minWindow = outer_string + '';  // holds solution string\r\n\r\n  for (letter of substring) {  // substring Map()\r\n    substringCount.set(letter, (substringCount.get(letter) ?? 0) + 1);\r\n  }\r\n\r\n  for (let right in outer_string) {  // right pointer\r\n    let letter = outer_string[right];\r\n\r\n    if (substringCount.has(letter)) {  // if letter is significant\r\n      window.set(letter, (window.get(letter) ?? 0) + 1);  // add letter to the window\r\n      \r\n      if (window.get(letter) == substringCount.get(letter)) {  // if letter occurences match\r\n        counter++;\r\n      }\r\n      \r\n    }\r\n    while (counter == substringCount.size) {  // if all letter occurences are matching\r\n      if ((right - left + 1) < minWindow.length) {  // if shorter window found\r\n        minWindow = outer_string.slice(left, right + 1);  // update minWindow\r\n        if (minWindow.length == substring.length) {  // if the length of minWindow is as short as it can be => equal to the length of the substring\r\n          return minWindow  // fast exit\r\n        }\r\n      }\r\n      let leftLetter = outer_string[left];  // letter at left poionter\r\n\r\n      if (substringCount.has(leftLetter)) {  // if letter is significant\r\n        if (window.get(leftLetter) == substringCount.get(leftLetter)) {  // if left_letter occurences match\r\n          counter--;  // lower the counter\r\n        }\r\n        window.set(leftLetter, window.get(leftLetter) - 1);  // lower significant letter occurence\r\n      }\r\n      left++;  // update the left counter\r\n    }\r\n  }\r\n  if (minWindow != outer_string + '') {\r\n    return minWindow;\r\n  } else {\r\n    return ''\r\n  }\r\n}", "testcase": "console.log(minWindow(\"ADOBECODEBANC\", \"ABC\"), \"BANC\")\r\nconsole.log(minWindow(\"a\", \"a\"), \"a\")\r\nconsole.log(minWindow(\"a\", \"aa\"), \"\")\r\nconsole.log(minWindow(\"a\", \"b\"), \"\")\r\nconsole.log(minWindow(\"ab\", \"b\"), \"b\")\r\nconsole.log(minWindow(\"bba\", \"ab\"), \"ba\")\r\nconsole.log(minWindow(\"abc\", \"a\"), \"a\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-29T12:53:01.258Z", "updated_at": "2024-08-29T12:53:01.272Z"}}, {"model": "python_problems.solution", "pk": 102, "fields": {"problem": 57, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nfunction maxSlidingWindow(nums, windowSize) {\r\n  const window = [];  // slidiong window as a list\r\n  let left = 0;  // left pointer\r\n  const currentMax = [];  // array with max value from each sliding window\r\n\r\n  for (let right in nums) {  // right pointer\r\n    let num = nums[right];  // current num\r\n\r\n    while (window[0] < left) {  // remove left out of bounds indexes\r\n      window.shift();\r\n    }\r\n\r\n    while (nums[window[window.length - 1]] <= num) {  // remove right indexes with nums less than current num\r\n      window.pop();\r\n    }\r\n\r\n    if (num > num[window[0]]) {  // if num is greater than the left most num append it left\r\n      window.splice(0, 0, right); // append it left\r\n    } else {\r\n      window.push(right);  // append it right\r\n    }\r\n\r\n    if (right - left + 1 == windowSize) {  // if the window is the right size\r\n      currentMax.push(nums[window[0]]);  // get the left (max) value\r\n      left++;  // update left pointer\r\n    }\r\n  }\r\n    return currentMax\r\n}", "testcase": "console.log(maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3), [3, 3, 5, 5, 6, 7])\r\nconsole.log(maxSlidingWindow([1], 1), [1])\r\nconsole.log(maxSlidingWindow([7, 2, 4], 2), [7, 4])\r\nconsole.log(maxSlidingWindow([1, 3, 1, 2, 0, 5], 3), [3, 3, 2, 5])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-08-29T15:58:40.487Z", "updated_at": "2024-08-29T15:58:40.501Z"}}, {"model": "python_problems.solution", "pk": 103, "fields": {"problem": 62, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n * \"dfs\" method inside \"subsets\" method\r\n */\r\nvar subsets = function (nums) {\r\n  const subset = [];  // current subcet\r\n  const subsetList = [];  // solution\r\n\r\n  // let dfs = (level) => {\r\n  function dfs(level) {\r\n    if (level == nums.length) {  // target level reached\r\n      subsetList.push(subset.slice())  // push subset to subset_list\r\n      return\r\n    }\r\n\r\n    subset.push(nums[level]);\r\n    dfs(level + 1);  // (left) decision to append current num\r\n    subset.pop();\r\n    dfs(level + 1);  // (right) decision to not append current num\r\n  }\r\n\r\n  dfs(0);  // start dfs with level = 0\r\n\r\n  return subsetList\r\n}\r\n\r\n\r\n// \"dfs\" and \"subset\" methods inside a class\r\nclass Solution {\r\n  constructor() {\r\n    this.subset = [];\r\n    this.subsetList = [];\r\n  }\r\n\r\n  // dfs = (level) => {\r\n  dfs(level) {\r\n    if (level == this.nums.length) {\r\n      this.subsetList.push(this.subset.slice())\r\n      return\r\n    }\r\n\r\n    this.subset.push(this.nums[level]);\r\n    this.dfs(level + 1);\r\n    this.subset.pop();\r\n    this.dfs(level + 1);\r\n  }\r\n\r\n  // subsets = (nums) => {\r\n    subsets(nums) {\r\n      this.nums = nums;\r\n      this.dfs(0);\r\n  \r\n      return this.subsetList\r\n    }\r\n  \r\n}", "testcase": "console.log(subsets([1, 2, 3]), [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]])\r\nconsole.log(subsets([0]), [[], [0]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-09-01T09:37:04.160Z", "updated_at": "2024-12-28T09:06:07.907Z"}}, {"model": "python_problems.solution", "pk": 104, "fields": {"problem": 63, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nvar subsetsWithDup = function (nums) {\r\n  nums.sort();\r\n  const subset = [];  // current subcet\r\n  const subset_list = [];  // solution\r\n\r\n  function dfs(index) {\r\n    if (index == nums.length) {  // target level reached\r\n      subset_list.push(subset.slice());  // push subset to subset_list\r\n      return\r\n    }\r\n\r\n    subset.push(nums[index]);\r\n    dfs(index + 1);  // (left) decision to append current num\r\n    subset.pop();\r\n\r\n    // If num at the current index (that was poped previously) is the same as\r\n    // the num at next index skip it.\r\n    while (index + 1 < nums.length &&\r\n      nums[index + 1] == nums[index]) {\r\n      index++;\r\n    }\r\n\r\n    dfs(index + 1);  // (right) decision to not append current num\r\n  }\r\n\r\n  dfs(0);  // start dfs with level = 0\r\n\r\n  return subset_list\r\n}", "testcase": "console.log(subsetsWithDup([1, 2, 2]), [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]])\r\nconsole.log(subsetsWithDup([0]), [[], [0]])\r\nconsole.log(subsetsWithDup([4, 4, 4, 1, 4]), [[], [1], [1, 4], [1, 4, 4], [1, 4, 4, 4], [1, 4, 4, 4, 4], [4], [4, 4], [4, 4, 4], [4, 4, 4, 4]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-09-01T09:49:31.566Z", "updated_at": "2024-12-28T09:07:13.600Z"}}, {"model": "python_problems.solution", "pk": 105, "fields": {"problem": 64, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number[][]}\r\n */\r\nvar combinationSum = function (candidates, target) {\r\n  // sort candidates to ensure that candidate with index + 1 is greater than previous to not reapat solution\r\n  candidates.sort();\r\n  const combination = [];  // current combination\r\n  const combinationList = [];  // solution\r\n\r\n  function dfs(value, startIndex) {\r\n    if (value == target) {  // target sum reached\r\n      combinationList.push(combination.slice());  // push subset to subset_list\r\n      return\r\n    } else if (value > target) {  // if value is too large\r\n      return\r\n    }\r\n\r\n    // check only equal or higher candidates\r\n    for (let index = startIndex; index < candidates.length; index++) {\r\n      let candidate = candidates[index];\r\n      combination.push(candidate);\r\n      dfs(value + candidate, index);\r\n      combination.pop();\r\n    }\r\n  }\r\n\r\n  dfs(0, 0);\r\n\r\n  return combinationList\r\n}", "testcase": "console.log(combinationSum([2, 3, 6, 7], 7), [[2, 2, 3], [7]])\r\nconsole.log(combinationSum([2, 3, 5], 8), [[2, 2, 2, 2], [2, 3, 3], [3, 5]])\r\nconsole.log(combinationSum([2], 1), [])", "time_complexity": 8, "space_complexity": 2, "created_at": "2024-09-01T10:21:28.876Z", "updated_at": "2024-09-01T10:21:28.891Z"}}, {"model": "python_problems.solution", "pk": 106, "fields": {"problem": 65, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} candidates\r\n * @param {number} target\r\n * @return {number[][]}\r\n */\r\nvar combinationSum2 = function (candidates, target) {\r\n  candidates.sort();\r\n  const combination = [];\r\n  const combinationList = [];\r\n\r\n\r\n  function dfs(index, value) {\r\n    if (value == target) {\r\n      combinationList.push(combination.slice());\r\n      return\r\n    } else if (index == candidates.length || value > target) {\r\n      return\r\n    }\r\n\r\n    combination.push(candidates[index]);\r\n    dfs(index + 1, value + candidates[index]);\r\n    combination.pop();\r\n\r\n    while (index + 1 < candidates.length && candidates[index + 1] == candidates[index])\r\n      index++\r\n\r\n    dfs(index + 1, value);\r\n  }\r\n\r\n  dfs(0, 0);\r\n\r\n  return combinationList\r\n}", "testcase": "console.log(combinationSum2([10, 1, 2, 7, 6, 1, 5], 8), [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]])\r\nconsole.log(combinationSum2([2, 5, 2, 1, 2], 5), [[1, 2, 2], [5]])", "time_complexity": 6, "space_complexity": 2, "created_at": "2024-09-02T13:52:04.280Z", "updated_at": "2024-09-02T13:52:04.303Z"}}, {"model": "python_problems.solution", "pk": 107, "fields": {"problem": 66, "language": 2, "owner": 3, "solution": "/**\r\n * O(n!), O(n)\r\n * backtracking\r\n * @param {number[]} numbers\r\n * @return {number[][]}\r\n */\r\nvar permute = function (numbers) {\r\n  const permutationList = [];\r\n\r\n  const dfs = (left) => {\r\n    if (left === numbers.length) {\r\n      permutationList.push(numbers.slice());\r\n      return\r\n    }\r\n\r\n    for (let right = left; right < numbers.length; right++) {\r\n      [numbers[left], numbers[right]] = [numbers[right], numbers[left]];\r\n      dfs(left + 1);\r\n      [numbers[left], numbers[right]] = [numbers[right], numbers[left]];\r\n    }\r\n  }\r\n\r\n  dfs(0);\r\n  return permutationList\r\n}\r\n\r\n\r\n/**\r\n * O(n!), O(n!)\r\n * backtracking\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nvar permute = function (nums) {\r\n  const perList = [];\r\n\r\n  function dfs(prefix, postfix) {\r\n    if (prefix.length == nums.length) {\r\n      perList.push([...prefix]); // Copy prefix to perList\r\n      return\r\n    }\r\n\r\n    for (let index = 0; index < postfix.length; index++) {\r\n      dfs([...prefix, postfix[index]],\r\n        [...postfix.slice(0, index), ...postfix.slice(index + 1)]);\r\n    }\r\n  }\r\n\r\n  dfs([], nums)\r\n  return perList\r\n}", "testcase": "console.log(permute([1, 2, 3]), [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]])\r\nconsole.log(permute([0, 1]), [[0, 1], [1, 0]])\r\nconsole.log(permute([1]), [[1]])", "time_complexity": 8, "space_complexity": 2, "created_at": "2024-09-02T13:53:15.964Z", "updated_at": "2025-01-06T17:53:56.125Z"}}, {"model": "python_problems.solution", "pk": 108, "fields": {"problem": 67, "language": 2, "owner": 3, "solution": "/**\r\n * @param {character[][]} board\r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nvar exist = function (board, word) {\r\n  let rows = board.length;\r\n  let cols = board[0].length;\r\n  snake = new Set();  // set of visited (forbidden) cells\r\n\r\n  function dfs(row, col, index, snake) {\r\n      if (index == word.length) return true  // if 'word' it empty all letters matched\r\n\r\n      snake.add(`${row},${col}`);    // add cell pair to tabu set\r\n\r\n      // check up, down, left, right for neighbouns\r\n      if (col + 1 < cols &&  // check if out of bounds and\r\n          !snake.has(`${row},${col + 1}`) &&  // if cell is not in tabo set\r\n          board[row][col + 1] == word[index] &&  // Check if the current position matches the word's character\r\n          dfs(row, col + 1, index + 1, snake)) {  // Switch to that letter and check its neighbors\r\n          return true\r\n      }\r\n\r\n      if (col - 1 >= 0 &&\r\n          !snake.has(`${row},${col - 1}`) &&\r\n          board[row][col - 1] == word[index] &&\r\n          dfs(row, col - 1, index + 1, snake)) {\r\n          return true\r\n      }\r\n\r\n      if (row + 1 < rows &&\r\n          !snake.has(`${row + 1},${col}`) &&\r\n          board[row + 1][col] == word[index] &&\r\n          dfs(row + 1, col, index + 1, snake)) {\r\n          return true\r\n      }\r\n\r\n      if (row - 1 >= 0 &&\r\n          !snake.has(`${row - 1},${col}`) &&\r\n          board[row - 1][col] == word[index] &&\r\n          dfs(row - 1, col, index + 1, snake)) {\r\n          return true\r\n      }\r\n\r\n      snake.delete(`${row},${col}`);  // Backtrack: remove the current cell from tabu set\r\n      \r\n      //return false\r\n  }\r\n\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n      for (let col = 0; col < cols; col++) {\r\n          if (board[row][col] === word[0]) {\r\n              if (dfs(row, col, 1, new Set())) {\r\n                  return true\r\n              }\r\n          }\r\n      }\r\n  }\r\n  return false\r\n}", "testcase": "console.log(exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"A\"), true)\r\nconsole.log(exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"AB\"), true)\r\nconsole.log(exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"AZ\"), false)\r\nconsole.log(exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"ABFS\"), true)\r\nconsole.log(exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"ABCCED\"), true)\r\nconsole.log(exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"SEE\"), true)\r\nconsole.log(exist([[\"A\", \"B\", \"C\", \"E\"], [\"S\", \"F\", \"C\", \"S\"], [\"A\", \"D\", \"E\", \"E\"]], \"ABCB\"), false)\r\nconsole.log(exist([[\"C\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"B\", \"C\", \"D\"]], \"AACA\"), true)\r\nconsole.log(exist([[\"C\", \"A\", \"A\"], [\"A\", \"A\", \"A\"], [\"B\", \"C\", \"D\"]], \"AAB\"), true)\r\nconsole.log(exist([[\"A\", \"A\"]], \"AAA\"), false)", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-09-04T13:22:17.143Z", "updated_at": "2024-09-04T13:22:17.161Z"}}, {"model": "python_problems.solution", "pk": 109, "fields": {"problem": 68, "language": 2, "owner": 3, "solution": "// passing dfs(rest of the word) like \"word = (pratition) + (rest of the word)\"\r\n/**\r\n * @param {string} word\r\n * @return {string[][]}\r\n */\r\nvar partition = function (word) {\r\n  const currenPartition = [];  // This will track the current partition\r\n  const partitionList = [];  // This will store all valid palindrome partitions\r\n\r\n  function isPalindrome(word) {\r\n    let l = 0;\r\n    let r = word.length - 1\r\n\r\n    while (l < r) {\r\n      if (word[l] !== word[r]) return false\r\n\r\n      l++;\r\n      r--;\r\n    }\r\n    return true\r\n  }\r\n\r\n  function dfs(word) {\r\n    if (word.length === 0) {  // if word is empty that means all letters folded into palindrom\r\n      partitionList.push(currenPartition.slice())\r\n    }\r\n\r\n    for (let index = 1; index <= word.length; index++) {  // index starts from '1' because the first element is word[:index]\r\n      let substring = word.slice(0, index);\r\n\r\n      if (isPalindrome(substring)) {  // if substring is a palindrme\r\n        currenPartition.push(substring);  // Add it to the current partition\r\n        dfs(word.slice(index,));  // Recur for the next part of the word\r\n        currenPartition.pop();  // Backtrack by removing the last added palindrome\r\n      }\r\n    }\r\n  }\r\n  dfs(word)  // Start DFS with \"word\"\r\n\r\n  return partitionList\r\n}", "testcase": "console.log(partition(\"aa\"), [['a', 'a'], ['aa']])\r\nconsole.log(partition(\"a\"), [[\"a\"]])\r\nconsole.log(partition(\"ab\"), [[\"a\", \"b\"]])\r\nconsole.log(partition(\"aaa\"), [['a', 'a', 'a'], ['a', 'aa'], ['aa', 'a'], ['aaa']])\r\nconsole.log(partition(\"aab\"), [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]])\r\nconsole.log(partition(\"aba\"), [[\"a\", \"b\", \"a\"], [\"aba\"]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-09-05T14:08:05.499Z", "updated_at": "2024-09-05T14:08:05.518Z"}}, {"model": "python_problems.solution", "pk": 110, "fields": {"problem": 69, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} digits\r\n * @return {string[]}\r\n */\r\nvar letterCombinations = function (digits) {\r\n  if (!digits) return []\r\n\r\n  const combination = [];\r\n  const combinationList = [];\r\n  const digitToLetter = {\r\n    \"2\": \"abc\",\r\n    \"3\": \"def\",\r\n    \"4\": \"ghi\",\r\n    \"5\": \"jkl\",\r\n    \"6\": \"mno\",\r\n    \"7\": \"pqrs\",\r\n    \"8\": \"tuv\",\r\n    \"9\": \"wxyz\"\r\n};\r\n\r\n  function dfs(index) {\r\n    if (index === digits.length) {\r\n      combinationList.push(combination.join(''));\r\n      return\r\n    }\r\n\r\n    for (let digit of digitToLetter[digits[index]]) {\r\n      combination.push(digit)\r\n      dfs(index + 1)\r\n      combination.pop()\r\n    }\r\n  }\r\n\r\n  dfs(0)\r\n\r\n  return combinationList\r\n}", "testcase": "console.log(letterCombinations(\"2\"), [\"a\", \"b\", \"c\"])\r\nconsole.log(letterCombinations(\"23\"), [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"])\r\nconsole.log(letterCombinations(\"\"), [])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-09-06T12:02:43.871Z", "updated_at": "2024-09-06T12:02:43.887Z"}}, {"model": "python_problems.solution", "pk": 111, "fields": {"problem": 70, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number} n\r\n * @return {string[][]}\r\n */\r\nvar solveNQueens = function (n) {\r\n  const solution = [];\r\n  const tabu_col = new Set();\r\n  const tabu_diag = new Set();  // for each diagonal (col_ind - row_ind) = const\r\n  const tabu_adiag = new Set();  // for each aiti-diagonal (con_ind + row_ind) = const\r\n  const board = Array.from({ length: n }, () => Array(n).fill('.'));  // n * n board filled with '.'\r\n\r\n  \r\n  function dfs(row) {\r\n      if (row === n) {  // if all rows are filled with Queens\r\n        // solution.push(board.map(row => row.slice()));\r\n        joinedBoard = board.map(row => row.join(''))  // ['.', 'Q', '.', '.'] => ['.Q..']\r\n        solution.push(joinedBoard);\r\n        return\r\n      }\r\n\r\n      for (let col = 0; col < n; col++) {\r\n        // if there is another Queen in the same diagonal or the same col\r\n        if (tabu_col.has(col) || \r\n        tabu_diag.has(row - col) || \r\n        tabu_adiag.has(row + col)) {\r\n          continue\r\n        }\r\n\r\n        // update tabu and board\r\n        board[row][col] = 'Q';\r\n        tabu_col.add(col);\r\n        tabu_diag.add(row - col)\r\n        tabu_adiag.add(row + col)\r\n        \r\n        // check another row\r\n        dfs(row + 1)\r\n\r\n        // backtrack\r\n        board[row][col] = '.'\r\n        tabu_col.delete(col)\r\n        tabu_diag.delete(row - col);\r\n        tabu_adiag.delete(row + col);\r\n        }\r\n    }\r\n\r\n    dfs(0)\r\n\r\n  return solution\r\n}", "testcase": "console.log(solveNQueens(4), [[\".Q..\", \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", \"Q...\", \"...Q\", \".Q..\"]])\r\nconsole.log(solveNQueens(1), [[\"Q\"]])", "time_complexity": 8, "space_complexity": 3, "created_at": "2024-09-06T14:58:36.351Z", "updated_at": "2024-09-06T14:58:36.370Z"}}, {"model": "python_problems.solution", "pk": 112, "fields": {"problem": 72, "language": 1, "owner": 3, "solution": "# O(n2^n), O(n)\r\n# backtracking\r\nclass Solution:\r\n    def generateParenthesis(self, number: int) -> list[str]:\r\n        parenthesis = []  # current parenthesis sequence\r\n        parenthesis_list = []  # list of parenthesis sequences\r\n\r\n        def dfs(opened, closed):\r\n            if opened + closed == 2 * number:  # if all opening and closing parenthesis are used\r\n                parenthesis_list.append(\"\".join(parenthesis))  # append current sequence\r\n                return\r\n\r\n            if opened < number:  # not all \"(\" have been used\r\n                parenthesis.append(\"(\")\r\n                dfs(opened + 1, closed)  # check this branch\r\n                parenthesis.pop()  # backtrack\r\n\r\n            if closed < opened:  # the number of \")\" must not be greater than \"(\"\r\n                parenthesis.append(\")\")\r\n                dfs(opened, closed + 1)  # check this branch\r\n                parenthesis.pop()  # backtrack\r\n\r\n        dfs(0, 0)  # start with no parenthesis\r\n        return parenthesis_list", "testcase": "print(Solution().generateParenthesis(1), [\"()\"])\r\nprint(Solution().generateParenthesis(2), [\"(())\", \"()()\"])\r\nprint(Solution().generateParenthesis(3), [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-09-06T19:17:09.680Z", "updated_at": "2025-01-07T11:22:58.244Z"}}, {"model": "python_problems.solution", "pk": 113, "fields": {"problem": 72, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number} n\r\n * @return {string[]}\r\n */\r\nvar generateParenthesis = function (num) {\r\n  const parenthesis = [];  // current parenthesis sequence\r\n  const parenthesisList = [];  // list of parenthesis sequences\r\n\r\n  function dfs(open, close) {\r\n    if (open + close === 2 * num) {  // if all opening and closing parenthesis are used\r\n      parenthesisList.push(parenthesis.join(''));  // push current sequence\r\n      return\r\n    }\r\n\r\n    if (open < num) {  // not all \"(\" have been used\r\n      parenthesis.push('(');\r\n      dfs(open + 1, close);  // check this branch\r\n      parenthesis.pop();  // backtrack\r\n    }\r\n\r\n    if (close < open) {  // the number of \")\" must not be greater than \"(\"\r\n      parenthesis.push(')');\r\n      dfs(open, close + 1);  // check this branch\r\n      parenthesis.pop();  // backtrack\r\n    }\r\n  }\r\n\r\n  dfs(0, 0)  // start with no parenthesis\r\n  return parenthesisList\r\n}", "testcase": "console.log(generateParenthesis(1), [\"()\"])\r\nconsole.log(generateParenthesis(2), [\"(())\", \"()()\"])\r\nconsole.log(generateParenthesis(3), [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"])", "time_complexity": 7, "space_complexity": 2, "created_at": "2024-09-07T13:21:45.424Z", "updated_at": "2024-09-07T13:21:45.446Z"}}, {"model": "python_problems.solution", "pk": 114, "fields": {"problem": 30, "language": 2, "owner": 3, "solution": "/**\r\n * Fibonnacci problem\r\n * dp, bottom up with no auxiliary memory space\r\n * O(n), O(1)\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar climbStairs = function (n) {\r\n  if (n < 4) return n\r\n  \r\n  let a = 0;\r\n  let b = 1;\r\n\r\n  for (index = 0; index < n; index++) {\r\n    b = a + b;\r\n    a = b - a;\r\n  }\r\n  return b\r\n}\r\n\r\n\r\n/**\r\n * Fibonnacci problem\r\n * dp, bottom up\r\n * O(n), O(n)\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar climbStairs = function (n) {\r\n  if (n < 4) return n\r\n  \r\n  const dp = new Array(n + 2).fill(0);\r\n  dp[1] = 1;\r\n\r\n  for (index = 2; index < n + 2; index++) {\r\n    dp[index] = dp[index - 1] + dp[index - 2];\r\n  }\r\n\r\n  return dp.slice(-1)[0]\r\n}\r\n\r\n\r\n/**\r\n * Fibonnacci problem\r\n * dp, top down with memoization\r\n * O(n), O(n)\r\n * @param {number} n\r\n * @return {number}\r\n */\r\n\r\nconst memo = new Map();\r\n\r\nvar climbStairs = function (n) {\r\n  if (n < 4) return n\r\n  \r\n  if (memo.has(n)) {\r\n    return memo.get(n)\r\n  } else {\r\n    memo.set(n, (climbStairs(n - 1) + climbStairs(n - 2)));\r\n    return memo.get(n);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Fibonnacci problem\r\n * dp, top down with memoization as a class variable\r\n * O(n), O(n)\r\n * @param {number} n\r\n * @return {number}\r\n */\r\n\r\nclass Solution {\r\n  constructor() {\r\n    this.memo = new Map();\r\n  }\r\n\r\n  //climbStairs = function (n) {\r\n  climbStairs(n) {\r\n  if (n < 4) return n\r\n\r\n  if (this.memo.has(n)) {\r\n    return this.memo.get(n)\r\n  } else {\r\n    this.memo.set(n, (this.climbStairs(n - 1) + this.climbStairs(n - 2)));\r\n    return this.memo.get(n);\r\n  }\r\n}\r\n}\r\n\r\nconsole.log(new Solution().climbStairs(0), 0)\r\nconsole.log(new Solution().climbStairs(1), 1)\r\nconsole.log(new Solution().climbStairs(2), 2)\r\nconsole.log(new Solution().climbStairs(3), 3)\r\nconsole.log(new Solution().climbStairs(4), 5)\r\nconsole.log(new Solution().climbStairs(5), 8)\r\n\r\n\r\n/**\r\n * Fibonnacci problem\r\n * dfs, unefficient\r\n * O(2^n), O(n)\r\n * counter as shared variable (list)\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar climbStairs = function (n) {\r\n  const counter = [];\r\n  \r\n  function dfs(index) {\r\n    if (index > n) return\r\n\r\n    if (index === n) {\r\n      counter.push(1)\r\n      return\r\n    }\r\n\r\n    dfs(index + 1);\r\n    dfs(index + 2);\r\n  }\r\n\r\n  dfs(0)\r\n\r\n  return counter.length\r\n}\r\n\r\n\r\n/**\r\n * Fibonnacci problem\r\n * dfs, unefficient\r\n * O(2^n), O(n)\r\n * 'counter' as a return statement from dfs\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar climbStairs = function (n) {\r\n  function dfs(index) {\r\n    if (index > n) return 0\r\n\r\n    if (index === n) return 1\r\n\r\n    return dfs(index + 1) + dfs(index + 2);\r\n  }\r\n\r\n  return dfs(0)\r\n}", "testcase": "console.log(climbStairs(0), 0)\r\nconsole.log(climbStairs(1), 1)\r\nconsole.log(climbStairs(2), 2)\r\nconsole.log(climbStairs(3), 3)\r\nconsole.log(climbStairs(4), 5)\r\nconsole.log(climbStairs(5), 8)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-09-07T14:08:18.290Z", "updated_at": "2024-09-07T19:13:24.998Z"}}, {"model": "python_problems.solution", "pk": 115, "fields": {"problem": 73, "language": 1, "owner": 3, "solution": "# draft\r\n# cost to move from the i-th step       [1,100,1,1,1,100,1,1,100,1]\r\n# cumulative cost to get to i-th step   [0, 0, 1,1,2, 2, 3,4, 5, 5, 6]\r\n# cumulative cost to get from i-th step [1,100,2,3,3,103,4,5,104,6]\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [cost[0], cost[1]]\r\n\r\n        for index in range(2, len(cost)):\r\n            prev = cache[0]\r\n            prev_prev = cache[1]\r\n            cache = [cache[1], cost[index] + min(prev, prev_prev)]\r\n\r\n        return min(cache[-1], cache[-2])\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        a = cost[0]\r\n        b = cost[1]\r\n\r\n        for index in range(2, len(cost)):\r\n            a, b = b, cost[index] + min(a, b)\r\n\r\n        return min(a, b)\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        mutate input list\r\n        \"\"\"\r\n        cache = [None] * len(cost)\r\n        cache[0] = cost[0]\r\n        cache[1] = cost[1]\r\n\r\n        for index in range(2, len(cost)):\r\n            cost[index] = cost[index] + min(cost[index - 1], cost[index - 2])\r\n\r\n        return min(cost[-1], cost[-2])\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [None] * len(cost)\r\n        cache[0] = cost[0]\r\n        cache[1] = cost[1]\r\n\r\n        for index in range(2, len(cost)):\r\n            cache[index] = cost[index] + min(cache[index - 1], cache[index - 2])\r\n\r\n        return min(cache[-1], cache[-2])\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        # Memoization dictionary to store the minimum cost to reach the top from each step\r\n        memo = {}\r\n\r\n        def dfs(index):\r\n            # Base case: if we're already at or beyond the top, no cost is needed\r\n            if index >= len(cost):\r\n                # No extra cost beyond the last step\r\n                return 0\r\n            # If the result is already computed, return it\r\n            elif index in memo:\r\n                return memo[index]\r\n            \r\n            # Recursively compute the cost of taking 1 step or 2 steps\r\n            # Store the result in the memo dictionary\r\n            memo[index] = cost[index] + min(dfs(index + 1), dfs(index + 2))\r\n            \r\n            return memo[index]\r\n\r\n        # Start from step 0 or step 1, whichever is cheaper\r\n        return min(dfs(0), dfs(1))\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [None] * len(cost)\r\n\r\n        def dfs(index):\r\n            if index >= len(cost):\r\n                return 0  # No extra cost beyond the last step\r\n            elif memo[index]:\r\n                return memo[index]\r\n\r\n            memo[index] = cost[index] + min(dfs(index + 1), dfs(index + 2))\r\n            return memo[index]\r\n\r\n        return min(dfs(0), dfs(1))\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, pure recursion, tle\r\n        converts to top-down      \r\n        \"\"\"\r\n        def dfs(index):\r\n            if index >= len(cost):\r\n                return 0\r\n            \r\n            return cost[index] + min(dfs(index + 1), dfs(index + 2))\r\n\r\n        return min(dfs(0), dfs(1))\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, function argument, tle\r\n        \"\"\"\r\n        self.min_total_cost = sum(cost)\r\n\r\n        def dfs(index, total_cost):\r\n            if index >= len(cost):\r\n                self.min_total_cost = min(self.min_total_cost, total_cost)\r\n                return\r\n\r\n            dfs(index + 1, total_cost + cost[index])\r\n            dfs(index + 2, total_cost + cost[index])\r\n\r\n        dfs(0, 0)\r\n        dfs(1, 0)\r\n        return self.min_total_cost\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, backtracking, tle\r\n        \"\"\"\r\n        self.total_cost = 0\r\n        self.min_total_cost = sum(cost)\r\n\r\n        def dfs(index):\r\n            if index >= len(cost):\r\n                self.min_total_cost = min(self.min_total_cost, self.total_cost)\r\n                return\r\n\r\n            self.total_cost += cost[index]\r\n            dfs(index + 1)\r\n            dfs(index + 2)\r\n            self.total_cost -= cost[index]\r\n\r\n\r\n        dfs(0)\r\n        dfs(1)\r\n        return self.min_total_cost\r\n\r\n\r\nclass Solution:\r\n    def minCostClimbingStairs(self, cost: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, function argument, tle\r\n        \"\"\"\r\n        def dfs(index, total_cost):\r\n            if index >= len(cost):\r\n                return total_cost\r\n\r\n            return min(\r\n                dfs(index + 1, total_cost + cost[index]),\r\n                dfs(index + 2, total_cost + cost[index]))\r\n\r\n        return min(dfs(0, 0), dfs(1, 0))", "testcase": "print(Solution().minCostClimbingStairs([10, 15, 20]), 15)\r\nprint(Solution().minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]), 6)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-09-07T17:28:55.780Z", "updated_at": "2025-02-16T08:57:22.428Z"}}, {"model": "python_problems.solution", "pk": 116, "fields": {"problem": 73, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bottom up\r\n * O(n), O(n)\r\n * @param {number[]} cost\r\n * @return {number}\r\n */\r\nvar minCostClimbingStairs = function (cost) {\r\n  for (let index = 2; index < cost.length; index++) {\r\n    cost[index] = Math.min(cost[index - 1], cost[index - 2]) + cost[index];\r\n  }\r\n  return Math.min.apply(null, cost.slice(-2))\r\n}\r\n\r\n\r\n/**\r\n * dp, bottom up\r\n * O(n), O(1)\r\n * @param {number[]} cost\r\n * @return {number}\r\n */\r\nvar minCostClimbingStairs = function (cost) {\r\n  let a = cost[0];\r\n  let b = cost[1];\r\n  \r\n  for (let index = 2; index < cost.length; index++) {\r\n    let temp = Math.min(a, b) + cost[index];\r\n    a = b;\r\n    b = temp;\r\n  }\r\n\r\n  return Math.min(a, b)\r\n}", "testcase": "console.log(minCostClimbingStairs([10, 15, 20]), 15)\r\nconsole.log(minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]), 6)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-09-07T17:29:26.678Z", "updated_at": "2024-09-07T17:29:26.694Z"}}, {"model": "python_problems.solution", "pk": 117, "fields": {"problem": 42, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bottom up, dp list => 2 variables: cumulative, maxSum\r\n * O(n), O(1)\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxSubArray = function (nums) {\r\n  let cumulative = nums[0];\r\n  let maxSum = nums[0];\r\n\r\n  for (index = 1; index < nums.length; index++) {\r\n    cumulative = Math.max(cumulative, 0) + nums[index];\r\n    maxSum = Math.max(maxSum, cumulative);\r\n  }\r\n\r\n  return maxSum\r\n}\r\n\r\n\r\n/**\r\n * dp, bottom up, use nums as dp\r\n * O(n), O(n)\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxSubArray = function (nums) {\r\n  for (index = 1; index < nums.length; index++) {\r\n    nums[index] += Math.max(nums[index - 1], 0);\r\n  }\r\n\r\n  return Math.max.apply(null, nums)\r\n}\r\n\r\n\r\n/**\r\n * dp, bottom up\r\n * O(n), O(n)\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxSubArray = function (nums) {\r\n  const dp = new Array(nums.length)\r\n  dp[0] = nums[0];\r\n\r\n  for (index = 1; index < nums.length; index++) {\r\n    dp[index] = Math.max(dp[index - 1], 0) + nums[index];\r\n  }\r\n\r\n  return Math.max.apply(null, dp)\r\n}", "testcase": "console.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]), 6)\r\nconsole.log(maxSubArray([1]), 1)\r\nconsole.log(maxSubArray([5, 4, -1, 7, 8]), 23)\r\nconsole.log(maxSubArray([-4, -2, -1, -3]), -1)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-09-08T12:47:15.253Z", "updated_at": "2024-09-08T12:47:15.272Z"}}, {"model": "python_problems.solution", "pk": 118, "fields": {"problem": 31, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bottom up\r\n * O(n), O(1), cache only two last elements\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar rob = function (nums) {\r\n  if (nums.length === 1) {\r\n    return nums[0];\r\n  }\r\n\r\n  house1 = nums[0];\r\n  house2 = Math.max(nums[0], nums[1]);\r\n\r\n  for (index = 2; index < nums.length; index++) {\r\n    let temp = house2;\r\n    house2 = Math.max(nums[index] + house1, house2);\r\n    house1 = temp;\r\n  }\r\n  return house2\r\n}\r\n\r\n\r\n/**\r\n * dp, bottom up\r\n * O(n), O(n), cache every robbery\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar rob = function (nums) {\r\n  if (nums.length === 1) {\r\n    return nums[0];\r\n  }\r\n\r\n  const dp = new Array(nums.length);\r\n  dp[0] = nums[0];\r\n  dp[1] = Math.max(nums[0], nums[1]);\r\n\r\n  for (index = 2; index < nums.length; index++) {\r\n    dp[index] = Math.max(nums[index] + dp[index - 2], dp[index - 1])\r\n  }\r\n  return dp[nums.length - 1]\r\n}\r\n\r\n\r\n/**\r\n * dp, top down, with memoization\r\n * memo as an argument (map) to the rob function\r\n * O(n), O(n)\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\n\r\nvar rob = function (nums, index = 1, memo = new Map()) {  \r\n  if (nums.length === 1) {  // if one element in nums\r\n    return nums[0];\r\n  }\r\n\r\n  if (nums.length - index == 0) {  // if index is 0\r\n    return nums[0]\r\n  }\r\n\r\n  if (nums.length - index == 1) {  // if index is 1\r\n    return Math.max(nums[0], nums[1]);\r\n  }\r\n\r\n  if (!memo.has(index + 1)) {  // if \"index + 1\" is not in the memo\r\n    memo.set(index + 1, rob(nums, index + 1, memo))  // calculate it\r\n  }\r\n  let prev = memo.get(index + 1);  // take it\r\n\r\n  if (!memo.has(index + 2)) {\r\n    memo.set(index + 2, rob(nums, index + 2, memo))\r\n  }\r\n  let prevPrev = memo.get(index + 2);\r\n\r\n  return Math.max(nums[nums.length - index] + prevPrev, prev)\r\n}\r\n\r\n\r\n/**\r\n * class\r\n * dp, top down, with memoization\r\n * O(n), O(n)\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\n\r\nclass Solution {\r\n  constructor() {\r\n    this.memo = new Map();  // memoization cache\r\n  }\r\n\r\n\r\n  rob = function (nums, index = 1, memo = new Map()) {\r\n    if (nums.length === 1) {  // if one element in nums\r\n      return nums[0];\r\n    }\r\n\r\n    if (nums.length - index == 0) {  // if index is 0\r\n      return nums[0]\r\n    }\r\n\r\n    if (nums.length - index == 1) {  // if index is 1\r\n      return Math.max(nums[0], nums[1]);\r\n    }\r\n\r\n    if (!this.memo.has(index + 1)) {  // if \"index + 1\" is not in the this.memo\r\n      this.memo.set(index + 1, this.rob(nums, index + 1))  // calculate it\r\n    }\r\n    let prev = this.memo.get(index + 1);  // take it\r\n\r\n    if (!this.memo.has(index + 2)) {\r\n      this.memo.set(index + 2, this.rob(nums, index + 2))\r\n    }\r\n    let prevPrev = this.memo.get(index + 2);\r\n\r\n    return Math.max(nums[nums.length - index] + prevPrev, prev)\r\n  }\r\n}\r\n\r\nconsole.log(new Solution().rob([2, 100, 9, 3, 100]), 200)\r\n\r\n\r\n/**\r\n * dp, top down, with memoization\r\n * memo inside 'rob' function used as a shared variable (map) between rob_inner \r\n * O(n), O(n)\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\n\r\nvar rob = function (nums, index = 1) {\r\n  const memo = new Map()\r\n \r\n  var rob_inner = function (nums, index) {\r\n    if (nums.length === 1) {  // if one element in nums\r\n      return nums[0];\r\n    }\r\n\r\n    if (nums.length - index == 0) {  // if index is 0\r\n      return nums[0]\r\n    }\r\n\r\n    if (nums.length - index == 1) {  // if index is 1\r\n      return Math.max(nums[0], nums[1]);\r\n    }\r\n\r\n    if (!memo.has(index + 1)) {  // if \"index + 1\" is not in the memo\r\n      memo.set(index + 1, rob_inner(nums, index + 1))  // calculate it\r\n    }\r\n    let prev = memo.get(index + 1);  // take it\r\n\r\n    if (!memo.has(index + 2)) {\r\n      memo.set(index + 2, rob_inner(nums, index + 2))\r\n    }\r\n    let prevPrev = memo.get(index + 2);\r\n\r\n    return Math.max(nums[nums.length - index] + prevPrev, prev)\r\n  }\r\n  return rob_inner(nums, 1)\r\n}", "testcase": "console.log(rob([2, 100, 9, 3, 100]), 200)\r\nconsole.log(rob([100, 9, 3, 100, 2]), 200)\r\nconsole.log(rob([1, 2, 3, 1]), 4)\r\nconsole.log(rob([2, 7, 9, 3, 1]), 12)\r\nconsole.log(rob([0]), 0)\r\nconsole.log(rob([2, 1]), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-09-09T13:25:01.576Z", "updated_at": "2024-09-09T13:25:01.619Z"}}, {"model": "python_problems.solution", "pk": 119, "fields": {"problem": 32, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), 0(1)\r\n * function in function\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar rob = function (nums) {\r\n  if (nums.length < 3) {\r\n    return Math.max.apply(null, nums)\r\n  }\r\n\r\n  function rob_straight(nums) {\r\n    let house1 = nums[0];\r\n    let house2 = Math.max(nums[0], nums[1]);\r\n\r\n    for (let num of nums.slice(2,)) {\r\n      let temp = house2;\r\n      house2 = Math.max(num + house1, house2);\r\n      house1 = temp;\r\n    }\r\n    return house2\r\n  }\r\n  return Math.max(\r\n    rob_straight(nums.slice(0, nums.length - 1)),\r\n    rob_straight(nums.slice(1,)))\r\n}\r\n\r\n\r\n/**\r\n * O(n), 0(1)\r\n * both functions directly under class\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nclass Solution {\r\n  rob = function (nums) {\r\n    if (nums.length < 3) {\r\n      return Math.max.apply(null, nums)\r\n    }\r\n    return Math.max(\r\n      this.rob_straight(nums.slice(0, nums.length - 1)),\r\n      this.rob_straight(nums.slice(1,)))\r\n  }\r\n\r\n  rob_straight(nums) {\r\n    let house1 = nums[0];\r\n    let house2 = Math.max(nums[0], nums[1]);\r\n\r\n    for (let num of nums.slice(2,)) {\r\n      let temp = house2;\r\n      house2 = Math.max(num + house1, house2);\r\n      house1 = temp;\r\n    }\r\n\r\n    return house2\r\n  }\r\n}\r\nconsole.log(new Solution().rob([2, 3, 2]), 3)\r\nconsole.log(new Solution().rob([1, 2, 3, 1]), 4)\r\nconsole.log(new Solution().rob([1, 2, 3]), 3)\r\nconsole.log(new Solution().rob([1]), 1)\r\nconsole.log(new Solution().rob([0, 0]), 0)\r\nconsole.log(new Solution().rob([1, 3, 1, 3, 100]), 103)", "testcase": "console.log(rob([2, 3, 2]), 3)\r\nconsole.log(rob([1, 2, 3, 1]), 4)\r\nconsole.log(rob([1, 2, 3]), 3)\r\nconsole.log(rob([1]), 1)\r\nconsole.log(rob([0, 0]), 0)\r\nconsole.log(rob([1, 3, 1, 3, 100]), 103)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-09T15:05:54.681Z", "updated_at": "2025-01-07T22:02:01.105Z"}}, {"model": "python_problems.solution", "pk": 120, "fields": {"problem": 33, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} word\r\n * @return {string}\r\n */\r\nvar longestPalindrome = function (word) {\r\n  let longestPalindrome = '';\r\n\r\n  for (let index = 0; index < word.length; index++) {\r\n    // odd length palindrome\r\n    let edge = 1;\r\n\r\n    while (index - edge >= 0 &&  // check if not out of bounds left\r\n      index + edge < word.length &&  // check if not out of bounds right\r\n      word.charAt(index - edge) == word.charAt(index + edge)) {  // if letter match\r\n      edge++;  // 1 -> 3, 2i + 1 increase palindrome length\r\n    }\r\n\r\n    if (2 * edge - 1 > longestPalindrome.length) {  // if longer palindrome found\r\n      longestPalindrome = word.slice(index - edge + 1, index + edge)\r\n    }\r\n\r\n    // even lenght palindrome\r\n    edge = 0;\r\n\r\n    while (index - edge >= 0 &&  // check if not out of bounds left\r\n      index + 1 + edge < word.length &&  // check if not out of bounds right\r\n      word.charAt(index - edge) == word.charAt(index + 1 + edge)) {  // if letter match\r\n      edge++;  // 2 -> 4, 2i increase palindrome length\r\n    }\r\n\r\n    if (2 * edge > longestPalindrome.length) {  // if longer palindrome found\r\n      longestPalindrome = word.slice(index - edge + 1, index + edge + 1)\r\n    }\r\n\r\n  }\r\n  return longestPalindrome\r\n}", "testcase": "console.log(longestPalindrome(\"babad\"), \"bab\")\r\nconsole.log(longestPalindrome(\"a\"), \"a\")\r\nconsole.log(longestPalindrome(\"cbbd\"), \"bb\")\r\nconsole.log(longestPalindrome(\"\"), \"\")\r\nconsole.log(longestPalindrome(\"bb\"), \"bb\")\r\nconsole.log(longestPalindrome(\"ab\"), \"a\")\r\nconsole.log(longestPalindrome(\"aacabdkacaa\"), \"aca\")\r\nconsole.log(longestPalindrome(\"abdka\"), \"a\")\r\nconsole.log(longestPalindrome(\"aaaa\"), \"aaaa\")", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-09-10T11:36:21.102Z", "updated_at": "2024-09-10T11:36:21.119Z"}}, {"model": "python_problems.solution", "pk": 121, "fields": {"problem": 34, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} word\r\n * @return {number}\r\n */\r\nvar countSubstrings = function (word) {\r\n  let counterSum = 0;\r\n\r\n  for (index = 0; index < word.length; index++) {\r\n    // odd length palindrome\r\n    let counter = 1;\r\n\r\n    while (index - counter >= 0 &&  // check if not out of bounds left\r\n      index + counter < word.length &&  // check if not out of bounds right\r\n      word[index - counter] == word[index + counter]  // if letter match\r\n    ) {\r\n      counter++;  // update counter_sum\r\n    }\r\n    counterSum += counter;\r\n\r\n    // even length palindrome\r\n    counter = 0;\r\n\r\n    while (index - counter >= 0 &&\r\n      index + 1 + counter < word.length &&\r\n      word[index - counter] == word[index + 1 + counter]\r\n    ) {\r\n      counter++;\r\n    }\r\n    counterSum += counter;\r\n  }\r\n\r\n  return counterSum\r\n}", "testcase": "console.log(countSubstrings(\"abc\"), 3)\r\nconsole.log(countSubstrings(\"aaa\"), 6)", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-09-10T13:08:22.863Z", "updated_at": "2024-09-10T13:08:22.885Z"}}, {"model": "python_problems.solution", "pk": 122, "fields": {"problem": 74, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n[2, 2, 6, 1]\r\n 2  2  6  1\r\n 2    26  1\r\n 22    6  1\r\n                  .\r\n            /           \\\r\n           2            22\r\n        /     \\       /\r\n       2      26     6\r\n     /       /     /\r\n    6       1     1\r\n   /\r\n  1\r\n\r\n[3, 2, 1, 1, (1)]\r\n{0: 3, 1: 2, 2: 1, 3: 1, 4: 1}\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def numDecodings(self, code: str) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        if not code:\r\n            return 0\r\n        \r\n        cache = [1, 1]  # `1` when the whole number is partitioned\r\n\r\n        for index in reversed(range(len(code))):\r\n            cache_0 = 0\r\n\r\n            if code[index] != \"0\":\r\n                cache_0 = cache[0]\r\n\r\n            if (index + 1 < len(code) and\r\n                (code[index] == \"1\" or \r\n                 (code[index] == \"2\" and \r\n                  code[index + 1] <= \"6\"))):\r\n                cache_0 += cache[1]\r\n\r\n            cache = [cache_0, cache[0]]\r\n\r\n        return cache[0]\r\n\r\n\r\nclass Solution:\r\n    def numDecodings(self, code: str) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up, list as cache\r\n        \"\"\"\r\n        if not code:\r\n            return 0\r\n        \r\n        cache = [0] * (len(code) + 1)\r\n        cache[len(code)] = 1  # `1` when the whole number is partitioned\r\n\r\n        for index in reversed(range(len(code))):\r\n            if code[index] != \"0\":\r\n                cache[index] += cache[index + 1]\r\n\r\n            if (index + 1 < len(code) and\r\n                (code[index] == \"1\" or \r\n                 (code[index] == \"2\" and \r\n                  code[index + 1] <= \"6\"))):\r\n                cache[index] += cache[index + 2]\r\n\r\n        return cache[0]\r\n\r\n\r\nclass Solution:\r\n    def numDecodings(self, code: str) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up, hash map as cache\r\n        \"\"\"\r\n        if not code:\r\n            return 0\r\n        \r\n        cache = {len(code): 1}  # `1` when the whole number is partitioned\r\n\r\n        for index in reversed(range(len(code))):\r\n            cache[index] = 0\r\n            \r\n            if code[index] != \"0\":\r\n                cache[index] += cache[index + 1]\r\n\r\n            if (index + 1 < len(code) and\r\n                (code[index] == \"1\" or \r\n                 (code[index] == \"2\" and \r\n                  code[index + 1] <= \"6\"))):\r\n                cache[index] += cache[index + 2]\r\n\r\n        return cache[0]\r\n\r\n\r\nclass Solution:\r\n    def numDecodings(self, code: str) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        if not code:  # if \"code\" is empty\r\n            return 0\r\n        \r\n        memo = {len(code): 1}  # `1` when the whole number is partitioned\r\n\r\n        def dfs(index):            \r\n            if index in memo:  # if memoized\r\n                return memo[index]  # Return memoized result if already computed.\r\n            elif code[index] == \"0\":  # check if number is statring with 0\r\n                return 0  # inwalid number\r\n            \r\n            # one digit number case\r\n            memo[index] = dfs(index + 1)  # Proceed to decode the next number.\r\n\r\n            # two digits number case\r\n            if (index + 1 < len(code) and  # check if second digit within bounds\r\n                (code[index] == \"1\" or  # two digit number starts with one or\r\n                 (code[index] == \"2\" and  # two digit number starts with two and \r\n                  code[index + 1] <= \"6\"))):  # ends with less equal to six\r\n                memo[index] += dfs(index + 2)  # Add the result of two-digit decoding.\r\n\r\n            return memo[index]  # Return the result for this index.\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def numDecodings(self, code: str) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        if not code:  # if \"code\" is empty\r\n            return 0\r\n        \r\n        memo = [None] * (len(code) + 1)\r\n        memo[len(code)] = 1  # `1` when the whole number is partitioned\r\n\r\n        def dfs(index):\r\n            if memo[index] != None:\r\n                return memo[index]\r\n            elif code[index] == \"0\":  # check if number is statring with 0\r\n                return 0  # inwalid number\r\n            \r\n            # one digit number case\r\n            memo[index] = dfs(index + 1)  # Proceed to decode the next number.\r\n\r\n            # two digits number case\r\n            if (index + 1 < len(code) and  # check if second digit within bounds\r\n                (code[index] == \"1\" or  # two digit number starts with one or\r\n                 (code[index] == \"2\" and  # two digit number starts with two and \r\n                  code[index + 1] <= \"6\"))):  # ends with less equal to six\r\n                memo[index] += dfs(index + 2)  # Add the result of two-digit decoding.\r\n\r\n            return memo[index]  # Return the result for this index.\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def numDecodings(self, code: str) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        if not code:  # if \"code\" is empty\r\n            return 0\r\n        \r\n        def dfs(index):\r\n            if index == len(code):\r\n                return 1  # `1` when the whole number is partitioned\r\n            elif code[index] == \"0\":  # check if number is statring with 0\r\n                return 0  # inwalid number\r\n            \r\n            # one digit number case\r\n            one_digit_number = dfs(index + 1)  # Proceed to decode the next number.\r\n\r\n            # two digits number case\r\n            two_digit_number = 0\r\n            if (index + 1 < len(code) and  # check if second digit within bounds\r\n                (code[index] == \"1\" or  # two digit number starts with one or\r\n                 (code[index] == \"2\" and  # two digit number starts with two and \r\n                  code[index + 1] <= \"6\"))):  # ends with less equal to six\r\n                two_digit_number = dfs(index + 2)  # Add the result of two-digit decoding.\r\n\r\n            return one_digit_number + two_digit_number  # Return the result for this index.\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def numDecodings(self, word: str) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, backtracking, tle\r\n        \"\"\"\r\n        if (not word or word[0] == \"0\"):\r\n            return 0\r\n\r\n        decoded = []\r\n        decoded_list = []\r\n\r\n        def dfs(index):\r\n            if index == len(word):\r\n                decoded_list.append(decoded.copy())\r\n                return\r\n\r\n            if (index == len(word) - 1 or  # if last digit or\r\n                    index + 1 < len(word) and  # next index in bounds\r\n                    word[index + 1] != \"0\"):  # next digit is not zero\r\n\r\n                if word[index] != \"0\":\r\n                    decoded.append(word[index])\r\n                    dfs(index + 1)\r\n                    decoded.pop()\r\n\r\n            if (index == len(word) - 2 or  # if two last digits or\r\n                    index + 2 < len(word) and  # next index in bounds\r\n                    word[index + 2] != \"0\"):  # next digit is not zero\r\n\r\n                if (index + 1 < len(word) and\r\n                        word[index: index + 2] <= \"26\"):\r\n                    decoded.append(word[index: index + 2])\r\n                    dfs(index + 2)\r\n                    decoded.pop()\r\n\r\n        dfs(0)\r\n        return len(decoded_list)\r\n\r\n\r\nclass Solution:\r\n    def numDecodings(self, code: str) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, backtracking, tle\r\n        \"\"\"\r\n        if not code:\r\n            return 0\r\n\r\n        decoded = []\r\n        decoded_list = []\r\n\r\n        def dfs(index):\r\n            if index == len(code):\r\n                decoded_list.append(decoded.copy())\r\n                return\r\n\r\n            # check if next digit is not zero\r\n            is_not_zero = True\r\n            if (index + 1 < len(code) and\r\n                    code[index + 1] == \"0\"):\r\n                is_not_zero = False\r\n\r\n            if (code[index] != \"0\" and\r\n                    is_not_zero):\r\n                decoded.append(code[index])\r\n                dfs(index + 1)\r\n                decoded.pop()\r\n\r\n            # check if next next digit is not zero\r\n            is_not_zero = True\r\n            if (index + 2 < len(code) and\r\n                    code[index + 2] == \"0\"):\r\n                is_not_zero = False\r\n\r\n            if (code[index] != \"0\" and\r\n                code[index] <= \"2\" and\r\n                index + 1 < len(code) and\r\n                code[index + 1] <= \"6\" and\r\n                    is_not_zero):\r\n\r\n                decoded.append(code[index: index + 2])\r\n                dfs(index + 2)\r\n                decoded.pop()\r\n\r\n        dfs(0)\r\n        return len(decoded_list)", "testcase": "print(Solution().numDecodings(\"5\"), 1)\r\nprint(Solution().numDecodings(\"226\"), 3)\r\nprint(Solution().numDecodings(\"2261\"), 3)\r\nprint(Solution().numDecodings(\"12\"), 2)\r\nprint(Solution().numDecodings(\"2101\"), 1)\r\nprint(Solution().numDecodings(\"06\"), 0)\r\nprint(Solution().numDecodings(\"0\"), 0)\r\nprint(Solution().numDecodings(\"\"), 0)\r\nprint(Solution().numDecodings(\"111111111111111111111111111111111111111111111\"), 1836311903)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-09-11T19:55:31.905Z", "updated_at": "2025-02-16T17:59:32.164Z"}}, {"model": "python_problems.solution", "pk": 123, "fields": {"problem": 74, "language": 2, "owner": 3, "solution": "/**\r\n * DP, Bottom-up\r\n * O(n), O(n)\r\n * @param {string} code\r\n * @return {number}\r\n */\r\nvar numDecodings = function (code) {\r\n  const dp = new Map([[code.length, 1]]);  // assume \"code\" is a prefix and everything after would be foleded into \"1\" possible path\r\n\r\n  for (index = code.length - 1; index >= 0; index--) {  // check every number in reversed order\r\n    if (code[index] !== '0') {  // check if number is not statring with 0\r\n      // one digit number case\r\n      dp.set(index, (dp.get(index) ?? 0) + (dp.get(index + 1) ?? 0));  // continue legit one digit number path\r\n\r\n      // two digits number case\r\n      if (index + 1 < code.length &&  // if index in bounds\r\n        Number(code.slice(index, index + 2)) <= 26) {  // if two digit number between <10, 27)\r\n        dp.set(index, (dp.get(index) ?? 0) + (dp.get(index + 2) ?? 0));  // continue legit two digit number path\r\n      }\r\n    }\r\n  }\r\n  return dp.get(0) ?? 0  // get first value from the dictionary or if code is not legit return 0\r\n}\r\n\r\n\r\n/**\r\n * DP, Top-down with memoization\r\n * O(n), O(n)\r\n * @param {string} code\r\n * @return {number}\r\n */\r\nvar numDecodings = function (code) {\r\n  const dp = new Map([[code.length, 1]]);  // assume \"code\" is a prefix and everything after would be foleded into \"1\" possible path\r\n\r\n  function dfs(index) {\r\n    if (dp.has(index)) {  // if memoized\r\n      return dp.get(index)  // Return memoized result if already computed.\r\n    }\r\n\r\n    if (code[index] === '0') {  // check if number is not statring with 0\r\n      return 0\r\n    }\r\n\r\n    // one digit number case\r\n    dp.set(index, (dp.get(index) ?? 0) + dfs(index + 1));  // continue legit one digit number path\r\n\r\n    // two digits number case\r\n    if (index + 1 < code.length &&  // if index in bounds\r\n      Number(code.slice(index, index + 2)) <= 26) {  // if two digit number between <10, 27)\r\n      dp.set(index, (dp.get(index) ?? 0) + dfs(index + 2));  // continue legit two digit number path\r\n    }\r\n    \r\n    return dp.get(index)  // Return the result for this index.\r\n  }\r\n\r\n  return dfs(0)  // Start decoding from the first index.\r\n}", "testcase": "console.log(numDecodings(\"12\"), 2)\r\nconsole.log(numDecodings(\"226\"), 3)\r\nconsole.log(numDecodings(\"06\"), 0)\r\nconsole.log(numDecodings(\"0\"), 0)\r\nconsole.log(numDecodings(\"\"), 0)\r\nconsole.log(numDecodings(\"2101\"), 1)\r\nconsole.log(numDecodings(\"111111111111111111111111111111111111111111111\"), 1836311903)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-09-11T19:56:11.115Z", "updated_at": "2024-09-11T19:56:11.134Z"}}, {"model": "python_problems.solution", "pk": 124, "fields": {"problem": 35, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bottom-up\r\n * @param {number[]} coins\r\n * @param {number} amount\r\n * @return {number}\r\n */\r\nvar coinChange = function (coins, amount) {\r\n  // min number of coins needed to get target amount (equal to the index)\r\n  // \"anmount + 1\" an imposbile value stays when the last element of min_coins was not modified\r\n  const minCoins = new Array(amount + 1).fill(amount + 1);\r\n  minCoins[0] = 0;    // no coins needed to get 0\r\n\r\n  for (let coin of coins) {  // check every coin\r\n    for (let index = coin; index <= amount; index++) {  // check each 'minCoins' index\r\n      // choose current amount of coins or get ammount without current coin and add 1\r\n      minCoins[index] = Math.min(minCoins[index], minCoins[index - coin] + 1);\r\n    }\r\n  }\r\n\r\n  if (minCoins[amount] == amount + 1) {  // if the last value was not modified so there is no valid combination\r\n    return -1\r\n  } else {\r\n    return minCoins[amount]  // valid combination\r\n  }\r\n}", "testcase": "console.log(coinChange([2, 5, 10, 1], 27), 4)\r\nconsole.log(coinChange([1, 2, 5], 11), 3)\r\nconsole.log(coinChange([2], 3), -1)\r\nconsole.log(coinChange([1], 0), 0)\r\nconsole.log(coinChange([186, 419, 83, 408], 6249), 20)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-09-12T12:15:25.359Z", "updated_at": "2024-09-12T12:15:25.379Z"}}, {"model": "python_problems.solution", "pk": 125, "fields": {"problem": 36, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bottom-up\r\n * O(n), O(1)\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxProduct = function (nums) {\r\n  dp_0 = [nums[0], nums[0]];  // O(1) cache\r\n  let maxProductVal = nums[0];  // track max product with default value\r\n\r\n  for (index = 1; index < nums.length; index++) {  // check all nums indexes\r\n    // multiply prefix values with current value to get min, max or\r\n    // current value only when prefix is [0, 0]\r\n    const triplet = [\r\n      dp_0[0] * nums[index],\r\n      dp_0[1] * nums[index],\r\n      nums[index]];\r\n\r\n    dp_0 = [Math.max.apply(null, triplet), Math.min.apply(null, triplet)];  // append min, max pair\r\n    maxProductVal = Math.max(maxProductVal, Math.max.apply(null, triplet));  // update max product\r\n\r\n  }\r\n  return maxProductVal\r\n}\r\n\r\n\r\n/**\r\n * dp, bottom-up\r\n * O(n), O(n)\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar maxProduct = function (nums) {\r\n  const dp = new Array(nums.length);  // min, max pair list for tabulation\r\n  dp[0] = [nums[0], nums[0]];  // insert the first element\r\n  let maxProductVal = nums[0];  // track max product with default value\r\n\r\n  for (index = 1; index < nums.length; index++) {  // check all nums indexes\r\n    // multiply prefix values with current value to get min, max or\r\n    // current value only when prefix is [0, 0]\r\n    const triplet = [\r\n      dp[index - 1][0] * nums[index],\r\n      dp[index - 1][1] * nums[index],\r\n      nums[index]];\r\n\r\n    dp[index] = [Math.max.apply(null, triplet), Math.min.apply(null, triplet)];  // append min, max pair\r\n    maxProductVal = Math.max(maxProductVal, Math.max.apply(null, triplet));  // update max product\r\n\r\n  }\r\n  return maxProductVal\r\n}", "testcase": "console.log(maxProduct([-4, -3]), 12)\r\nconsole.log(maxProduct([2, 3, -2, 4]), 6)\r\nconsole.log(maxProduct([-2]), -2)\r\nconsole.log(maxProduct([-4, -3]), 12)\r\nconsole.log(maxProduct([-2, 0, -1]), 0)\r\nconsole.log(maxProduct([-2, -3, 7]), 42)\r\nconsole.log(maxProduct([2, -5, -2, -4, 3]), 24)\r\nconsole.log(maxProduct([-2]), -2)\r\nconsole.log(maxProduct([0]), 0)\r\nconsole.log(maxProduct([-2, 0]), 0)\r\nconsole.log(maxProduct([0, 2]), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-09-12T14:29:18.147Z", "updated_at": "2024-09-12T14:29:18.163Z"}}, {"model": "python_problems.solution", "pk": 126, "fields": {"problem": 38, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} sencence\r\n * @param {string[]} wordList\r\n * @return {boolean}\r\n */\r\nvar wordBreak = function (sentence, wordList) {\r\n  // cache where each elemet tells if sentece can be fold from this index to the right\r\n  const canFold = new Array(sentence.length + 1).fill(false);\r\n  canFold[canFold.length - 1] = true;// dummy element tells that everything after \"sentence can be folded\"\r\n\r\n  for (index = sentence.length; index >= 0; index--) {  // go through every index reversed\r\n    for (word of wordList) {  // go through every word\r\n      if (sentence.slice(index, index + word.length) === word) {  // if found the word\r\n        canFold[index] = canFold[index] || canFold[index + word.length];  // update can fold\r\n      }\r\n    }\r\n  }\r\n  return canFold[0]\r\n}", "testcase": "console.log(wordBreak(\"leetcode\", [\"leet\", \"code\"]), true)\r\nconsole.log(wordBreak(\"applepenapple\", [\"apple\", \"pen\"]), true)\r\nconsole.log(wordBreak(\"catsandog\", [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]), false)\r\nconsole.log(wordBreak(\"cars\", [\"car\", \"ca\", \"rs\"]), true)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-09-12T15:30:27.607Z", "updated_at": "2024-09-12T15:30:27.622Z"}}, {"model": "python_problems.solution", "pk": 127, "fields": {"problem": 39, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar lengthOfLIS = function (nums) {\r\n  const dp = new Array(nums.length).fill(1);  // LIS lengths\r\n\r\n  for (right = 0; right < nums.length; right++) {  // check every right (index)\r\n    for (left = 0; left < right; left++) {  // check every left (index) lower than right\r\n      if (nums[left] < nums[right]) {  // if right num is greater\r\n        dp[right] = Math.max(dp[right], dp[left] + 1);  // update LIS lengths \r\n      }\r\n    }\r\n  }\r\n  return Math.max.apply(null, dp)\r\n}", "testcase": "console.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]), 4)\r\nconsole.log(lengthOfLIS([0, 1, 0, 3, 2, 3]), 4)\r\nconsole.log(lengthOfLIS([7, 7, 7, 7, 7, 7, 7]), 1)", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-09-12T20:29:49.309Z", "updated_at": "2024-09-12T20:29:49.326Z"}}, {"model": "python_problems.solution", "pk": 128, "fields": {"problem": 40, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @return {boolean}\r\n */\r\nvar canPartition = function (nums) {\r\n  if (nums.reduce((a, b) => a + b) % 2) return false  // if odd sum (cannot be split in half)\r\n\r\n  let half = nums.reduce((a, b) => a + b) >> 1;  // half of the sum\r\n  const seen_numbers = new Set();  // numbers seen in previous loop\r\n\r\n  for (let num of nums) {  // for every number\r\n    let new_numbers = new Set(seen_numbers);  // copy of seen numbers\r\n\r\n    for (let new_number of new_numbers) {\r\n      seen_numbers.add(new_number + num);  // add new numbers in current loop\r\n    }\r\n\r\n    seen_numbers.add(num);  // add current num\r\n\r\n    if (seen_numbers.has(half)) {  // check if half is in seen numbers\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}", "testcase": "console.log(canPartition([14, 9, 8, 4, 3, 2]), true)\r\nconsole.log(canPartition([1, 2, 5]), false)\r\nconsole.log(canPartition([1, 5, 11, 5]), true)\r\nconsole.log(canPartition([3, 3, 3, 4, 5]), true)\r\nconsole.log(canPartition([1, 2, 3, 5]), false)\r\nconsole.log(canPartition([1]), false)\r\nconsole.log(canPartition([2, 2, 1, 1]), true)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-09-13T12:15:54.002Z", "updated_at": "2024-09-13T12:15:54.020Z"}}, {"model": "python_problems.solution", "pk": 129, "fields": {"problem": 75, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# dfs, recursion\r\nclass Solution:\r\n    def invertTree(self, root: TreeNode | None) -> TreeNode | None:\r\n        if not root:\r\n            return\r\n\r\n        root.left, root.right = root.right, root.left\r\n        self.invertTree(root.left)\r\n        self.invertTree(root.right)\r\n        \r\n        return root\r\n\r\n\r\n# O(n), O(n)\r\n# dfs, stack, iteration\r\nclass Solution:\r\n    def invertTree(self, root: TreeNode | None) -> TreeNode | None:\r\n        if not root:\r\n            return None\r\n        \r\n        stack = [root]\r\n\r\n        while stack:\r\n            node = stack.pop()\r\n            node.left, node.right = node.right, node.left\r\n            \r\n            if node.left:\r\n                stack.append(node.left)\r\n            if node.right:\r\n                stack.append(node.right)\r\n        \r\n        return root\r\n\r\n\r\n# O(n), O(n)\r\n# bfs, deque, iteration\r\nclass Solution:\r\n    def invertTree(self, root: TreeNode | None) -> TreeNode | None:\r\n        if not root:\r\n            return None\r\n        \r\n        deq = deque([root])\r\n\r\n        while deq:\r\n            node = deq.popleft()\r\n            node.left, node.right = node.right, node.left\r\n            \r\n            if node.left:\r\n                deq.append(node.left)\r\n            if node.right:\r\n                deq.append(node.right)\r\n        \r\n        return root", "testcase": "(Solution().invertTree([4, 2, 7, 1, 3, 6, 9]), [4, 7, 2, 9, 6, 3, 1])\r\n(Solution().invertTree([2, 1, 3]), [2, 3, 1])\r\n(Solution().invertTree([]), [])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-14T11:42:15.039Z", "updated_at": "2024-12-14T14:54:57.487Z"}}, {"model": "python_problems.solution", "pk": 130, "fields": {"problem": 75, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {TreeNode}\r\n */\r\nvar invertTree = function (root) {\r\n  if (root) {\r\n      [root.left, root.right] = [root.right, root.left];\r\n\r\n      invertTree(root.left);\r\n      invertTree(root.right);\r\n  }\r\n  return root\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-14T12:50:59.383Z", "updated_at": "2024-12-14T14:55:14.470Z"}}, {"model": "python_problems.solution", "pk": 131, "fields": {"problem": 76, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# dfs, recursion\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode | None) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        return max(\r\n            self.maxDepth(root.left),  # left branch depth\r\n            self.maxDepth(root.right)  # right branch depth\r\n            ) + 1\r\n\r\n\r\n# O(n), O(n)\r\n# dfs, recursion, explict dfs function\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode | None) -> int:\r\n        def dfs(node):\r\n            if not node:\r\n                return 0\r\n        \r\n            left = dfs(node.left)  # left branch depth\r\n            right = dfs(node.right)  # right branch depth\r\n            \r\n            return max(left, right) + 1\r\n\r\n        return dfs(root)\r\n\r\n\r\n# O(n), O(n)\r\n# bfs, iteration, deque, level order traversal\r\nfrom collections import deque\r\n\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode | None) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        depth = 0\r\n        queue = deque([root])\r\n\r\n        while queue:\r\n            depth += 1\r\n            current_queue_len = len(queue)\r\n\r\n            for _ in range(current_queue_len):\r\n                node = queue.popleft()\r\n\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                \r\n                if node.right:\r\n                    queue.append(node.right)\r\n        \r\n        return depth\r\n\r\n\r\n# O(n), O(n)\r\n# bfs, deque, iteration\r\nfrom collections import deque\r\n\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode | None) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        depth = 1\r\n        deq = deque([(1, root)])\r\n\r\n        while deq:\r\n            level, node = deq.popleft()\r\n            depth = max(depth, level)\r\n            \r\n            if node.left:\r\n                deq.append((level + 1, node.left))\r\n            if node.right:\r\n                deq.append((level + 1, node.right))\r\n        \r\n        return depth\r\n    \r\n\r\n# O(n), O(n)\r\n# dfs, iteration, stack, pre-order traversal\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode | None) -> int:\r\n        if not root:\r\n            return 0\r\n\r\n        stack = [(root, 1)]\r\n        max_depth = 1\r\n\r\n        while stack:\r\n            node, depth = stack.pop()\r\n            max_depth = max(max_depth, depth)\r\n\r\n            if node.left:\r\n                stack.append((node.left, depth + 1))\r\n            \r\n            if node.right:\r\n                stack.append((node.right, depth + 1))\r\n\r\n        return max_depth\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type):\r\n    if not node_list:\r\n        return\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index]:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index]:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().maxDepth(build_tree_from_list([3, 9, 20, None, None, 15, 7], Node)), 3)\r\n(Solution().maxDepth(build_tree_from_list([1, None, 2], Node)), 2)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-19T10:32:51.245Z", "updated_at": "2024-12-14T21:14:36.936Z"}}, {"model": "python_problems.solution", "pk": 132, "fields": {"problem": 76, "language": 2, "owner": 3, "solution": "/**\r\n * dp, dfs, top-down, recursion\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function (root) {\r\n  if (!root) {\r\n    return 0\r\n  }\r\n\r\n  return (Math.max(\r\n    maxDepth(root.left),\r\n    maxDepth(root.right))\r\n    + 1)\r\n}\r\n\r\n\r\n/**\r\n * dp, bfs, iterative, bottom-up, dequeue, level order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function (root) {\r\n  if (!root) {\r\n    return 0\r\n  }\r\n\r\n  const queue = [];\r\n  queue[0] = root;\r\n  let depth = 0;\r\n\r\n  while (queue.length !== 0) {\r\n    depth++;\r\n    const currenQueueLength = queue.length;\r\n\r\n    for (let index = 0; index < currenQueueLength; index++) {\r\n      let node = queue.shift();\r\n      \r\n      if (node.left) {\r\n        queue.push(node.left)\r\n      }\r\n\r\n      if (node.right) {\r\n        queue.push(node.right)\r\n      }\r\n    }\r\n  }\r\n\r\n  return depth\r\n}\r\n\r\n\r\n/**\r\n * dp, dfs, iterative, bottom-up, stack, pre-order dfs\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function (root) {\r\n  if (!root) {\r\n    return 0\r\n  }\r\n\r\n  const stack = [];\r\n  stack.push([root, 1])\r\n  maxDepthValue = 1\r\n\r\n  while (stack.length !== 0) {\r\n    let [node, depth] = stack.pop();\r\n\r\n    if (node.left) {\r\n      stack.push([node.left, depth + 1]);\r\n      maxDepthValue = Math.max(maxDepthValue, depth + 1);\r\n    }\r\n\r\n    if (node.right) {\r\n      stack.push([node.right, depth + 1]);\r\n      maxDepthValue = Math.max(maxDepthValue, depth + 1);\r\n    }\r\n  }\r\n\r\n  return maxDepthValue\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  const root = new TreeNode(nodeList[0]);\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    if (index < nodeList.length && nodeList[index]) {\r\n      // if (index < nodeList.length && nodeList[index] !== null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    if (index < nodeList.length && nodeList[index]) {\r\n      // if (index < nodeList.length && nodeList[index] !== null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}\r\n\r\ntree_from_list = buildTreeFromList([4, 2, 7, 1, 3, 6, 9])", "testcase": "console.log(maxDepth(buildTreeFromList([3, 9, 20, null, null, 15, 7])), 3)\r\nconsole.log(maxDepth(buildTreeFromList(([1, null, 2]))), 2)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-19T10:43:02.624Z", "updated_at": "2024-09-19T10:43:02.643Z"}}, {"model": "python_problems.solution", "pk": 133, "fields": {"problem": 77, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# O(n), O(n)\r\n# dfs, recursion\r\nclass Solution:\r\n    def __init__(self) -> None:\r\n        self.diameter = 0\r\n\r\n    def diameterOfBinaryTree(self, root: TreeNode | None) -> int:\r\n        def dfs(node):\r\n            if not node:\r\n                return 0\r\n        \r\n            left = dfs(node.left)  # left branch depth\r\n            right = dfs(node.right)  # right branch depth\r\n            self.diameter = max(self.diameter, left + right)  # diameter with current node as a root\r\n            \r\n            return max(left, right) + 1  # current node max depth\r\n\r\n        dfs(root)\r\n\r\n        return self.diameter\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type):\r\n    if not node_list:\r\n        return\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index]:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index]:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root\r\n\r\n\r\nbuild_tree_from_list([1, 2, 3, 4, 5], Node)", "testcase": "(Solution().diameterOfBinaryTree(build_tree_from_list([1, 2, 3, 4, 5], Node)), 3)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-19T13:48:46.387Z", "updated_at": "2024-12-14T23:27:24.091Z"}}, {"model": "python_problems.solution", "pk": 134, "fields": {"problem": 77, "language": 2, "owner": 3, "solution": "/**\r\n * dp, dfs, top-down, recursion\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar diameterOfBinaryTree = function (root) {\r\n  let longestDiameter = 0;\r\n\r\n  function dfs(node) {\r\n    if (!node) {\r\n      return 0\r\n    }\r\n\r\n    let left = dfs(node.left);  // left branch depth\r\n    let right = dfs(node.right);  // right branch depth\r\n\r\n    longestDiameter = Math.max(longestDiameter, left + right);  // left + rigth = path between two nodes\r\n\r\n    return Math.max(left, right) + 1  // current node max depth\r\n  }\r\n\r\n  dfs(root)\r\n\r\n  return longestDiameter\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  const root = new TreeNode(nodeList[0]);\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    if (index < nodeList.length && nodeList[index]) {\r\n      // if (index < nodeList.length && nodeList[index] !== null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    if (index < nodeList.length && nodeList[index]) {\r\n      // if (index < nodeList.length && nodeList[index] !== null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(diameterOfBinaryTree(buildTreeFromList([1, 2, 3, 4, 5])), 3)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-19T13:50:06.486Z", "updated_at": "2024-09-19T13:50:06.503Z"}}, {"model": "python_problems.solution", "pk": 135, "fields": {"problem": 78, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dfs, recursive\r\n# O(n), O(n)\r\nclass Solution:\r\n    def isBalanced(self, root: TreeNode | None) -> bool:\r\n        self.is_balanced = True  # default value for balanced tree\r\n        \r\n        def dfs(node):\r\n            if not node:\r\n                return 0\r\n\r\n            left = dfs(node.left)  # left branch depth\r\n            right = dfs(node.right)  # right branch depth\r\n\r\n            if abs(left - right) > 1:  # if deep of the two subtrees differs more than by 1\r\n                self.is_balanced = False  # then tree in not balanced\r\n                return -1  # early return\r\n\r\n            return max(left, right) + 1  # the depth of the current node\r\n\r\n        dfs(root)  # run dfs\r\n\r\n        return self.is_balanced\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type):\r\n    if not node_list:\r\n        return\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index]:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index]:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().isBalanced(build_tree_from_list([3, 9, 20, None, None, 15, 7], Node)), True)\r\n(Solution().isBalanced(build_tree_from_list([1, 2, 2, 3, 3, None, None, 4, 4], Node)), False)\r\n(Solution().isBalanced(build_tree_from_list([1, 2, 2, 3, None, None, 3, 4, None, None, 4], Node)), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-19T19:34:16.492Z", "updated_at": "2024-12-15T13:52:00.584Z"}}, {"model": "python_problems.solution", "pk": 136, "fields": {"problem": 78, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar isBalanced = function (root) {\r\n  let isBalancedBool = true  // default valuef for balanced tree\r\n\r\n  function dfs(node) {\r\n    if (!node) {\r\n      return 0\r\n    }\r\n\r\n    let left = dfs(node.left);  // left branch depth\r\n    let right = dfs(node.right);  // right branch depth\r\n\r\n    if (Math.abs(left - right) > 1) {  // if deep of the two subtrees differs more than by 1\r\n      isBalancedBool = false;  // then tree in not balanced\r\n      return -1  // early return\r\n    }\r\n\r\n    return Math.max(left, right) + 1  // the depth of the current node\r\n  }\r\n\r\n  dfs(root)  // run dfs\r\n\r\n  return isBalancedBool\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  const root = new TreeNode(nodeList[0]);\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    if (index < nodeList.length && nodeList[index]) {\r\n      // if (index < nodeList.length && nodeList[index] !== null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    if (index < nodeList.length && nodeList[index]) {\r\n      // if (index < nodeList.length && nodeList[index] !== null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(isBalanced(buildTreeFromList([3, 9, 20, null, null, 15, 7])), true)\r\nconsole.log(isBalanced(buildTreeFromList([1, 2, 2, 3, 3, null, null, 4, 4])), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-19T19:35:55.480Z", "updated_at": "2024-09-19T19:35:55.499Z"}}, {"model": "python_problems.solution", "pk": 137, "fields": {"problem": 79, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, top-down, recursive\r\n# O(n), O(n)\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode | None, q: TreeNode | None) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        \r\n        if (p and q and p.val == q.val):  # if both nodes exist and have equal values\r\n            return (self.isSameTree(p.left, q.left) and  # left subtree is the same\r\n                    self.isSameTree(p.right, q.right))  # right subtree is the same\r\n        else:\r\n            return False\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, bfs, iterative, queue\r\n# O(n), O(n)\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode | None, q: TreeNode | None) -> bool:\r\n        if not p and not q:  # p and q are empyt\r\n            return True\r\n        \r\n        if not p or not q:  # p or q is empyt\r\n            return False\r\n\r\n        p_queue = deque([p])  # initiate dequeues\r\n        q_queue = deque([q])\r\n\r\n        while p_queue and q_queue:  # if both queues not empty\r\n            for _ in range(max(len(p_queue), len(q_queue))):  # for every node in queue\r\n                p_node = p_queue.popleft()  # take a node\r\n                q_node = q_queue.popleft()\r\n                \r\n                if p_node.val != q_node.val:  # compare p and q values\r\n                    return False\r\n                \r\n                if (not p_node.left and not q_node.left):  # if p and q are None\r\n                    pass\r\n                elif (p_node.left and q_node.left and  # if p and q exist\r\n                        p_node.left.val == q_node.left.val):  # if p and q left value is the same\r\n                    p_queue.append(p_node.left)  # append p left value to queue\r\n                    q_queue.append(q_node.left)  # append q left value to queue\r\n                else:  # in any other case\r\n                    return False\r\n\r\n                if (not p_node.right and not q_node.right):\r\n                    pass\r\n                elif (p_node.right and q_node.right and\r\n                        p_node.right.val == q_node.right.val):\r\n                    p_queue.append(p_node.right)\r\n                    q_queue.append(q_node.right)\r\n                else:\r\n                    return False\r\n\r\n        return True\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type):\r\n    if not node_list:\r\n        return\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index]:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index]:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().isSameTree(build_tree_from_list([1, 2, 3], TreeNode), build_tree_from_list([1, 2, 3], TreeNode)), True)\r\n(Solution().isSameTree(build_tree_from_list([1, 2], TreeNode), build_tree_from_list([1, None, 2], TreeNode)), False)\r\n(Solution().isSameTree(build_tree_from_list([1, 2, 1], TreeNode), build_tree_from_list([1, 1, 2], TreeNode)), False)\r\n(Solution().isSameTree(build_tree_from_list([10, 5, 15], TreeNode), build_tree_from_list([10, 5, None, None, 15], TreeNode)), False)\r\n(Solution().isSameTree(build_tree_from_list([1, None, 2, 3], TreeNode), build_tree_from_list([1, None, 2, None, 3], TreeNode)), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-20T14:40:00.635Z", "updated_at": "2024-09-21T12:04:58.301Z"}}, {"model": "python_problems.solution", "pk": 138, "fields": {"problem": 79, "language": 2, "owner": 3, "solution": "/**\r\n * dp, dfs, top-down, recursive\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function (p, q) {\r\n  if (!p && !q) {  // if both nodes are null\r\n    return true\r\n  }\r\n\r\n  if (\r\n    p && q &&  // if both nodes exist\r\n    p.val == q.val  // and have equal values\r\n  ) {\r\n    return (\r\n      isSameTree(p.left, q.left) &&  // left subtree is the same\r\n      isSameTree(p.right, q.right)  // right subtree is the same\r\n    )\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * dp, bfs, iterative, queue\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function (p, q) {\r\n  if (!p && !q) {  // p and q are empty\r\n    return true\r\n  }\r\n\r\n  if (!p || !q) {  // p or q is empyt\r\n    return false\r\n  }\r\n\r\n  const pQueue = [];  // initiate dequeues\r\n  const qQueue = [];\r\n  pQueue.push(p);\r\n  qQueue.push(q);\r\n\r\n  while (pQueue.length || qQueue.length) {  // if both queues not empty\r\n    let queueLength = Math.max(pQueue.length, qQueue.length);\r\n    \r\n    for (let index = 0; index < queueLength; index++) {  // for every node in queue\r\n      pNode = pQueue.shift();  // take a node\r\n      qNode = qQueue.shift();\r\n\r\n      if (pNode.val != qNode.val) {  // compare p and q values\r\n        return false\r\n      }\r\n\r\n      if (!pNode.left && !qNode.left) {  // if p and q are None\r\n        // pass\r\n      } else if (\r\n        pNode.left && qNode.left &&  // if p and q exist\r\n        pNode.left.val === qNode.left.val) {  // if p and q left value is the same\r\n          pQueue.push(pNode.left);  // append p left value to queue\r\n          qQueue.push(qNode.left);  // append q left value to queue\r\n      } else {\r\n        return false\r\n      }\r\n\r\n      if (!pNode.right && !qNode.right) {\r\n        // pass\r\n      } else if (\r\n        pNode.right && qNode.right &&\r\n        pNode.right.val === qNode.right.val) {\r\n          pQueue.push(pNode.right);\r\n          qQueue.push(qNode.right);\r\n      } else {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  const root = new TreeNode(nodeList[0]);\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    if (index < nodeList.length && nodeList[index]) {\r\n      // if (index < nodeList.length && nodeList[index] !== null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    if (index < nodeList.length && nodeList[index]) {\r\n      // if (index < nodeList.length && nodeList[index] !== null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(isSameTree(buildTreeFromList([1, 2, 3]), buildTreeFromList([1, 2, 3])), true)\r\nconsole.log(isSameTree(buildTreeFromList([1, 2]), buildTreeFromList([1, null, 2])), false)\r\nconsole.log(isSameTree(buildTreeFromList([1, 2, 1]), buildTreeFromList([1, 1, 2])), false)\r\nconsole.log(isSameTree(buildTreeFromList([10, 5, 15]), buildTreeFromList([10, 5, null, null, 15])), false)\r\nconsole.log(isSameTree(buildTreeFromList([1, null, 2, 3]), buildTreeFromList([1, null, 2, null, 3])), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-20T14:40:48.005Z", "updated_at": "2024-09-21T12:04:27.188Z"}}, {"model": "python_problems.solution", "pk": 139, "fields": {"problem": 80, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dfs, recursive\r\n# O(n2), O(n)\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode | None, q: TreeNode | None) -> bool:\r\n        if not p and not q:  # if both nodes are None\r\n            return True\r\n        elif not p or not q:  # if one node is None and the other is not None\r\n            return False\r\n        elif p.val != q.val:  # if both node values are not equal\r\n            return False\r\n\r\n        return (\r\n            self.isSameTree(p.left, q.left) and  # left subtree is the same and\r\n            self.isSameTree(p.right, q.right))  # right subtree is the same    \r\n    \r\n    \r\n    def isSubtree(self, root: TreeNode | None, subRoot: TreeNode | None) -> bool:\r\n        if not subRoot:  # if no subRoot then always True\r\n            return True\r\n        elif not root:  # if no root then no match found\r\n            return False\r\n        elif self.isSameTree(root, subRoot):  # if tres are equal\r\n            return True\r\n        \r\n        return (\r\n            self.isSubtree(root.left, subRoot) or  # check if subtree if in left tree branch\r\n            self.isSubtree(root.right, subRoot))  # check if subtree if in right tree branch\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type=TreeNode):\r\n    if not node_list:\r\n        return\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        # if index < len(node_list) and node_list[index]:\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().isSubtree(build_tree_from_list([3, 4, 5, 1, 2]), build_tree_from_list([4, 1, 2])), True)\r\n(Solution().isSubtree(build_tree_from_list([3, 4, 5, 1, 2, None, None, None, None, 0]), build_tree_from_list([4, 1, 2])), False)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-09-21T12:07:18.610Z", "updated_at": "2024-12-18T23:05:28.021Z"}}, {"model": "python_problems.solution", "pk": 140, "fields": {"problem": 80, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * dp, dfs, recursive\r\n * O(n2), O(n)\r\n * @param {TreeNode} root\r\n * @param {TreeNode} subRoot\r\n * @return {boolean}\r\n */\r\nvar isSubtree = function (root, subRoot) {\r\n  if (!subRoot) {  // if no subRoot then always True\r\n    return true\r\n  }\r\n  if (!root) {  // if no root then no match found\r\n    return false\r\n  }\r\n  if (isSameTree(root, subRoot)) {  // if tres are equal\r\n    return true\r\n  }\r\n  return (\r\n    isSubtree(root.left, subRoot) ||  // check if subtree if in left tree branch\r\n    isSubtree(root.right, subRoot)  // check if subtree if in right tree branch\r\n  )\r\n}\r\n\r\n\r\nvar isSameTree = function (p, q) {\r\n  if (!p && !q) {  // if both nodes are null\r\n    return true\r\n  }\r\n\r\n  if (\r\n    pd && q &&  // if both nodes exist\r\n    p.val == q.val  // and have equal values\r\n  ) {\r\n    return (\r\n      isSameTree(p.left, q.left) &&  // left subtree is the same\r\n      isSameTree(p.right, q.right)  // right subtree is the same\r\n    )\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  const root = new TreeNode(nodeList[0]);\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(isSubtree(buildTreeFromList([3, 4, 5, 1, 2]), buildTreeFromList([4, 1, 2])), true)\r\nconsole.log(isSubtree(buildTreeFromList([3, 4, 5, 1, 2, null, null, null, null, 0]), buildTreeFromList([4, 1, 2])), false)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-09-21T12:09:29.602Z", "updated_at": "2024-09-21T12:09:29.622Z"}}, {"model": "python_problems.solution", "pk": 141, "fields": {"problem": 81, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n# dp, dfs, iterative\r\n# O(logn), O(1)\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        while True:\r\n            if (  # if p and q are lower than the current value\r\n                p.val < root.val and\r\n                q.val < root.val\r\n            ):\r\n                root = root.left  # lower common ancestor node is in the left branch\r\n            elif (  # if p and q are highter than the current value\r\n                p.val > root.val and\r\n                q.val > root.val\r\n            ):\r\n                root = root.right  # lower common ancestor node is in the right branch\r\n            else:  # if one is lower and the other one is higher, THIS is the LCA\r\n                return root\r\n\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n# dp, dfs, recursive\r\n# O(logn), O(h) # O(h) for recursion stack height\r\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        if (  # if p and q are lower than the current value\r\n            p.val < root.val and\r\n            q.val < root.val\r\n        ):\r\n            return self.lowestCommonAncestor(root.left, p, q)  # lower common ancestor node is in the left branch\r\n        elif (  # if p and q are highter than the current value\r\n            p.val > root.val and\r\n            q.val > root.val\r\n        ):\r\n            return self.lowestCommonAncestor(root.right, p, q)  # lower common ancestor node is in the right branch\r\n        else:\r\n            return root\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type=TreeNode):\r\n    if not node_list:\r\n        return\r\n\r\n    if type(node_list) == int:  # case when the node list is a single value\r\n        node_list = [node_list]\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        # if index < len(node_list) and node_list[index]:\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "((Solution().lowestCommonAncestor( build_tree_from_list([6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]), build_tree_from_list(2), build_tree_from_list(8))).val, 6)\r\n((Solution().lowestCommonAncestor( build_tree_from_list([6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]), build_tree_from_list(2), build_tree_from_list(4))).val, 2)\r\n((Solution().lowestCommonAncestor( build_tree_from_list([2, 1]), build_tree_from_list(2), build_tree_from_list(1))).val, 2)\r\n((Solution().lowestCommonAncestor( build_tree_from_list([6, 2, 8, 0, 4, 7, 9, None, None, 3, 5]), build_tree_from_list(3), build_tree_from_list(5))).val, 4)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-09-21T18:51:21.597Z", "updated_at": "2024-09-21T18:51:21.617Z"}}, {"model": "python_problems.solution", "pk": 142, "fields": {"problem": 81, "language": 2, "owner": 3, "solution": "/**\r\n * dp, dfs, iterative\r\n * O(logn), O(1)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {TreeNode}\r\n */\r\nvar lowestCommonAncestor = function (root, p, q) {\r\n  while (true) {\r\n    if (  // if p and q are lower than the current value\r\n      p.val < root.val &&\r\n      q.val < root.val\r\n    ) {\r\n      root = root.left;  // lower common ancestor node is in the left branch\r\n    } else if (  // if p and q are highter than the current value\r\n      p.val > root.val &&\r\n      q.val > root.val\r\n    ) {\r\n      root = root.right;  // lower common ancestor node is in the right branch\r\n    } else {  // if one is lower and the other one is higher, THIS is the LCA\r\n      return root\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * dp, dfs, recursive\r\n * O(logn), O(h) # O(h) for recursion stack height\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {TreeNode}\r\n */\r\nvar lowestCommonAncestor = function (root, p, q) {\r\n  if (  // if p and q are lower than the current value\r\n    p.val < root.val &&\r\n    q.val < root.val\r\n  ) {\r\n    return lowestCommonAncestor(root.left, p, q)  // lower common ancestor node is in the left branch\r\n  } else if (  // if p and q are highter than the current value\r\n    p.val > root.val &&\r\n    q.val > root.val\r\n  ) {\r\n    return lowestCommonAncestor(root.right, p, q)  // lower common ancestor node is in the right branch\r\n  } else {\r\n    return root\r\n  }\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  if (Number.isInteger(nodeList)) {  // case when the node list is a single value\r\n    nodeList = [nodeList];\r\n  }\r\n\r\n  const root = new TreeNode(nodeList[0]);  // Create the root node\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  // Process the list and construct the tree\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    // Assign the left child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    // Assign the right child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log((lowestCommonAncestor( buildTreeFromList([6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]), buildTreeFromList(2), buildTreeFromList(8))).val, 6)\r\nconsole.log((lowestCommonAncestor( buildTreeFromList([6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]), buildTreeFromList(2), buildTreeFromList(4))).val, 2)\r\nconsole.log((lowestCommonAncestor( buildTreeFromList([2, 1]), buildTreeFromList(2), buildTreeFromList(1))).val, 2)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-09-21T18:55:02.301Z", "updated_at": "2024-09-21T18:55:02.323Z"}}, {"model": "python_problems.solution", "pk": 143, "fields": {"problem": 82, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, bfs, iterative, dequeue, level order traversal\r\n# O(n), O(n)\r\nclass Solution:\r\n    def levelOrder(self, root: TreeNode | None) -> list[list[int]]:\r\n        if not root:\r\n            return []\r\n        \r\n        queue = deque([root])  # Create the root node\r\n        level_order_list = [[root.val]]  # solution\r\n\r\n        while queue:  # while queue is not empty\r\n            current_level_list = []  # current level soultion\r\n            \r\n            for _ in range(len(queue)):  # for every node\r\n                node = queue.popleft()  # take that node\r\n\r\n                if node.left != None:  # if left Subnode is not empty\r\n                    queue.append(node.left)  # append it to queue\r\n                    current_level_list.append(node.left.val)  # append its value to current level solution\r\n                \r\n                if node.right != None:  # if right Subnode is not empty\r\n                    queue.append(node.right)  # append it to queue\r\n                    current_level_list.append(node.right.val)  # append its value to current level solution\r\n            \r\n            if current_level_list:  # if current level list has any elements\r\n                level_order_list.append(current_level_list)  # add them to the solution\r\n\r\n        return level_order_list\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type=TreeNode):\r\n    if not node_list:\r\n        return\r\n\r\n    if type(node_list) == int:  # case when the node list is a single value\r\n        node_list = [node_list]\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().levelOrder(build_tree_from_list([3, 9, 20, None, None, 15, 7])), [[3], [9, 20], [15, 7]])\r\n(Solution().levelOrder(build_tree_from_list([1])), [[1]])\r\n(Solution().levelOrder(build_tree_from_list([])), [])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-21T21:31:57.182Z", "updated_at": "2024-09-21T21:31:57.199Z"}}, {"model": "python_problems.solution", "pk": 144, "fields": {"problem": 82, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bfs, iterative, dequeue, level order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[][]}\r\n */\r\nvar levelOrder = function (root) {\r\n  if (!root) {\r\n    return []\r\n  }\r\n\r\n  const queue = [];  // Create the root node\r\n  queue.push(root);\r\n  const levelOrderList = [];  // solution\r\n  levelOrderList.push([root.val]);\r\n\r\n  while (queue.length !== 0) {  // while queue is not empty\r\n    const currentLevelList = [];  // constant queue length for current level\r\n    let queueLength = queue.length  // current level soultion\r\n\r\n    for (index = 0; index < queueLength; index++) {  // for every node\r\n      let node = queue.shift();  // take that node\r\n\r\n      if (node.left) {  // if left Subnode is not empty\r\n        queue.push(node.left);  // append it to queue\r\n        currentLevelList.push(node.left.val)  // append its value to current level solution\r\n      }\r\n\r\n      if (node.right) {  // if right Subnode is not empty\r\n        queue.push(node.right);  // append it to queue\r\n        currentLevelList.push(node.right.val)  // append its value to current level solution\r\n      }\r\n    }\r\n\r\n    if (currentLevelList.length != 0) {  // if current level list has any elements\r\n      levelOrderList.push(currentLevelList);  // add them to the solution\r\n    }\r\n  }\r\n\r\n  return levelOrderList\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  if (Number.isInteger(nodeList)) {  // case when the node list is a single value\r\n    nodeList = [nodeList];\r\n  }\r\n\r\n  const root = new TreeNode(nodeList[0]);  // Create the root node\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  // Process the list and construct the tree\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    // Assign the left child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    // Assign the right child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(levelOrder(buildTreeFromList([3, 9, 20, null, null, 15, 7])), [[3], [9, 20], [15, 7]])\r\nconsole.log(levelOrder(buildTreeFromList([1])), [[1]])\r\nconsole.log(levelOrder(buildTreeFromList([])), [])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-21T21:33:54.752Z", "updated_at": "2024-09-22T11:52:15.113Z"}}, {"model": "python_problems.solution", "pk": 145, "fields": {"problem": 83, "language": 1, "owner": 3, "solution": "from collections import deque\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, bfs, iterative, dequeue, level order traversal\r\n# O(n), O(n)\r\nclass Solution:\r\n    def rightSideView(self, root: TreeNode | None) -> list[int]:\r\n        if not root:\r\n            return []\r\n        \r\n        queue = deque([root])  # Create the root node\r\n        right_side_list = [root.val]  # solution\r\n\r\n        while queue:  # while queue is not empty\r\n            for _ in range(len(queue)):  # for every node\r\n                node = queue.popleft()  # take that node\r\n\r\n                if node.left:  # if left subnode is not empty\r\n                    queue.append(node.left)  # append it to queue\r\n\r\n                if node.right:  # if right subnode is not empty\r\n                    queue.append(node.right)  # append it to queue\r\n\r\n            if queue:  # if queue is not empty\r\n                right_side_list.append(queue[-1].val)  # append the most right value\r\n\r\n        return right_side_list\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type=TreeNode):\r\n    if not node_list:\r\n        return\r\n\r\n    if type(node_list) == int:  # case when the node list is a single value\r\n        node_list = [node_list]\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().rightSideView(build_tree_from_list([1, 2, 3, None, 5, None, 4])), [1, 3, 4])\r\n(Solution().rightSideView(build_tree_from_list([1, None, 3])), [1, 3])\r\n(Solution().rightSideView(build_tree_from_list([])), [])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-22T12:37:30.340Z", "updated_at": "2024-09-22T12:37:30.363Z"}}, {"model": "python_problems.solution", "pk": 146, "fields": {"problem": 83, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bfs, iterative, dequeue, level order traversal\r\n * O(n2), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar rightSideView = function (root) {\r\n  if (!root) {\r\n    return []\r\n  }\r\n\r\n  const queue = [];  // Create the root node\r\n  queue.push(root);\r\n  const rightSideList = [];  // solution\r\n  rightSideList.push(root.val);\r\n\r\n  while (queue.length !== 0) {  // while queue is not empty\r\n    const queueLength = queue.length;  // constant queue length for current level\r\n\r\n    for(let index = 0; index < queueLength; index++)  // for every node\r\n    {\r\n      let node = queue.shift();  // take that node\r\n\r\n      if (node.left) {  // if left subnode is not empty\r\n        queue.push(node.left);  // append it to queue\r\n      }\r\n\r\n      if (node.right) {// if right subnode is not empty\r\n        queue.push(node.right);  // append it to queue\r\n      }\r\n    }\r\n    if (queue.length !== 0) {// if queue is not empty\r\n      rightSideList.push(queue[queue.length - 1].val)  // append the most right value\r\n    }\r\n  }\r\n  return rightSideList\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  if (Number.isInteger(nodeList)) {  // case when the node list is a single value\r\n    nodeList = [nodeList];\r\n  }\r\n\r\n  const root = new TreeNode(nodeList[0]);  // Create the root node\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  // Process the list and construct the tree\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    // Assign the left child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    // Assign the right child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(rightSideView(buildTreeFromList([1, 2, 3, null, 5, null, 4])), [1, 3, 4])\r\nconsole.log(rightSideView(buildTreeFromList([1, null, 3])), [1, 3])\r\nconsole.log(rightSideView(buildTreeFromList([])), [])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-22T12:38:46.158Z", "updated_at": "2024-09-22T12:38:46.179Z"}}, {"model": "python_problems.solution", "pk": 147, "fields": {"problem": 84, "language": 1, "owner": 3, "solution": "from collections import deque\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, bfs, iterative, queue\r\n# O(n), O(n)\r\nclass Solution:\r\n    def goodNodes(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return None\r\n\r\n        queue = deque([(root, root.val)])  # Create the root node\r\n        good_nodes_counter = 1  # solution\r\n\r\n        while queue:  # while queue is not empty\r\n            for _ in range(len(queue)):  # for every node\r\n                node, max_value = queue.popleft()  # take that node\r\n\r\n                if node.left:  # if left subnode is not empty\r\n                    queue.append((node.left, max(max_value, node.left.val)))  # append it to queue\r\n                    if max_value <= node.left.val:  # if max value from root to current node is less or equal to current node left value\r\n                        good_nodes_counter += 1  # increase counter\r\n\r\n                if node.right:  # if right subnode is not empty\r\n                    queue.append((node.right, max(max_value, node.right.val)))  # append it to queue\r\n                    if max_value <= node.right.val:  # if max value from root to current node is less or equal to current node right value\r\n                        good_nodes_counter += 1  # increase counter\r\n\r\n        return good_nodes_counter\r\n\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, iterative, bottom-up, stack, pre-order dfs\r\n# O(n), O(n)\r\nclass Solution:\r\n    def goodNodes(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return None\r\n\r\n        stack = [(root, root.val)]  # create the stack with root node\r\n        good_nodes_counter = 1  # solution\r\n\r\n        while stack:  # while stack is not empty\r\n            node, max_value = stack.pop()  # take that node\r\n\r\n            if node.left:  # if left subnode is not empty\r\n                stack.append((node.left, max(max_value, node.left.val)))  # append it to stack\r\n                if max_value <= node.left.val:  # if max value from root to current node is less or equal to current node left value\r\n                    good_nodes_counter += 1  # increase counter\r\n            \r\n            if node.right:  # if right subnode is not empty\r\n                stack.append((node.right, max(max_value, node.right.val)))  # append it to stack\r\n                if max_value <= node.right.val:  # if max value from root to current node is less or equal to current node right value\r\n                    good_nodes_counter += 1  # increase counter\r\n\r\n        return good_nodes_counter\r\n\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, recursion, top-down, in-order traversal\r\n# purely recursive (functional recursion)\r\n# Functional recursion: Accumulates and passes results back through return values. This is a common approach in functional programming, where you avoid side effects and handle all state within the function's return values.\r\n# O(n), O(n)\r\nclass Solution:\r\n    def goodNodes(self, root: TreeNode) -> int:\r\n        \r\n        def dfs(node, max_till_root):\r\n            if not node:  # if None node (nothing to add)\r\n                return 0\r\n            \r\n            node_val = 1 if max_till_root <= node.val else 0  # if there are no nodes with a value greater than max till root value.\r\n            node_val += dfs(node.left, max(max_till_root, node.val))  # calculate left subnode\r\n            node_val += dfs(node.right, max(max_till_root, node.val))  # calculate right subnode\r\n\r\n            return node_val  # return current level sum\r\n        \r\n        return dfs(root, root.val)\r\n\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, recursion, top-down, in-order traversal\r\n# stateful recursion (side-effect recursion\")\r\n# Stateful recursion: Uses external state (such as class variables) to track information as a side effect. This is more common in imperative or object-oriented programming, where functions may modify shared state.\r\n# O(n), O(n)\r\nclass Solution:\r\n    def __init__(self):\r\n        self.good_nodes_counter = 0\r\n\r\n    def goodNodes(self, root: TreeNode) -> int:        \r\n        def dfs(node, max_till_root):\r\n            if not node:  # if None node (nothing to add)\r\n                return\r\n            \r\n            self.good_nodes_counter += 1 if max_till_root <= node.val else 0  # if there are no nodes with a value greater than max till root value.\r\n            dfs(node.left, max(max_till_root, node.val))  # calculate left subnode\r\n            dfs(node.right, max(max_till_root, node.val))  # calculate right subnode\r\n\r\n        dfs(root, root.val)\r\n\r\n        return self.good_nodes_counter\r\n\r\n\r\n# Functional recursion\r\ndef goodNodes(root: TreeNode) -> int:        \r\n    def dfs(node, max_till_root, good_nodes_counter):\r\n        if not node:  # if None node (nothing to add)\r\n            return 0\r\n        \r\n        good_nodes_counter = 1 if max_till_root <= node.val else 0  # if there are no nodes with a value greater than max till root value.\r\n        good_nodes_counter += dfs(node.left, max(max_till_root, node.val), good_nodes_counter)  # calculate left subnode\r\n        good_nodes_counter += dfs(node.right, max(max_till_root, node.val), good_nodes_counter)  # calculate right subnode\r\n\r\n        return good_nodes_counter\r\n\r\n    return dfs(root, root.val, 0)\r\n\r\n(goodNodes(build_tree_from_list([3, 1, 4, 3, None, 1, 5])), 4)\r\n\r\n\r\n# Stateful recursion\r\ndef goodNodes(root: TreeNode) -> int:        \r\n    good_nodes_counter = 0\r\n\r\n    def dfs(node, max_till_root):\r\n        nonlocal good_nodes_counter\r\n\r\n        if not node:  # if None node (nothing to add)\r\n            return 0\r\n            \r\n        good_nodes_counter += 1 if max_till_root <= node.val else 0  # if there are no nodes with a value greater than max till root value.\r\n        dfs(node.left, max(max_till_root, node.val))  # calculate left subnode\r\n        dfs(node.right, max(max_till_root, node.val))  # calculate right subnode\r\n\r\n    dfs(root, root.val)\r\n\r\n    return good_nodes_counter\r\n\r\n(goodNodes(build_tree_from_list([3, 1, 4, 3, None, 1, 5])), 4)\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, recursion, top-down, in-order traversal\r\n# O(n), O(n)\r\nclass Solution:\r\n    def goodNodes(self, root: TreeNode) -> int:\r\n        \r\n        def dfs(node, max_till_root):\r\n            if not node:  # if None node (nothing to add)\r\n                return 0\r\n            \r\n            node_val = 1 if max_till_root <= node.val else 0  # if there are no nodes with a value greater than max till root value.\r\n            left = dfs(node.left, max(max_till_root, node.val))  # calculate left subnode\r\n            right = dfs(node.right, max(max_till_root, node.val))  # calculate right subnode\r\n\r\n            return node_val + left + right  # return current level sum\r\n        \r\n        return dfs(root, root.val)\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type=TreeNode):\r\n    if not node_list:\r\n        return\r\n\r\n    if type(node_list) == int:  # case when the node list is a single value\r\n        node_list = [node_list]\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().goodNodes(build_tree_from_list([3, 1, 4, 3, None, 1, 5])), 4)\r\n(Solution().goodNodes(build_tree_from_list([3, 3, None, 4, 2])), 3)\r\n(Solution().goodNodes(build_tree_from_list([1])), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-23T14:32:09.964Z", "updated_at": "2024-09-24T13:34:50.438Z"}}, {"model": "python_problems.solution", "pk": 148, "fields": {"problem": 84, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bfs, iterative, queue\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar goodNodes = function (root) {\r\n  if (!root) {\r\n    return null\r\n  }\r\n  \r\n  const queue = [];  // Create the root node\r\n  queue.push([root, root.val]);\r\n  let goodNodesCounter = 1;  // solution\r\n\r\n  while (queue.length !== 0) {  // while queue is not empty\r\n    let queueLength = queue.length;\r\n\r\n    for (let index = 0; index < queueLength;  index++) {  // for every node\r\n      const [node, maxValue] = queue.shift();  // take that node\r\n\r\n      if (node.left) {  // if left subnode is not empty\r\n        queue.push([node.left, Math.max(node.left.val, maxValue)]);  // append it to queue\r\n        if (maxValue <= node.left.val) {  // if max value from root to current node is less or equal to current node left value\r\n          goodNodesCounter++;  // increase counter\r\n        }\r\n      }\r\n\r\n      if (node.right) {  // if right subnode is not empty\r\n        queue.push([node.right, Math.max(node.right.val, maxValue)]);  // append it to queue\r\n        if (maxValue <= node.right.val) {  // if max value from root to current node is less or equal to current node right value\r\n          goodNodesCounter++;  // increase counter\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return goodNodesCounter\r\n}\r\n\r\n\r\n/**\r\n * dp, dfs, iterative, bottom-up, stack, pre-order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar goodNodes = function (root) {\r\n  if (!root) {\r\n    return null\r\n  }\r\n\r\n  const stack = [];  // create the stack with root node\r\n  stack.push([root, root.val]);\r\n  let goodNodesCounter = 1;  // solution\r\n\r\n  while (stack.length !== 0) {  // while stack is not empty\r\n    const [node, maxValue] = stack.pop();  // take that node\r\n\r\n    if (node.left) {  // if left subnode is not empty\r\n      stack.push([node.left, Math.max(node.left.val, maxValue)]);  // append it to stack\r\n      if (maxValue <= node.left.val) {  // if max value from root to current node is less or equal to current node left value\r\n        goodNodesCounter++;  // increase counter\r\n      }\r\n    }\r\n\r\n    if (node.right) {  // if right subnode is not empty\r\n      stack.push([node.right, Math.max(node.right.val, maxValue)]);  // append it to stack\r\n      if (maxValue <= node.right.val) {  // if max value from root to current node is less or equal to current node right value\r\n        goodNodesCounter++;  // increase counter\r\n      }\r\n    }\r\n  }\r\n  return goodNodesCounter\r\n}\r\n\r\n\r\n/**\r\n * dp, dfs, recursion, top-down, in-order traversal, functional recursion\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar goodNodes = function (root) {\r\n  function dfs(node, maxTillRoot) {\r\n    if (!node) {  // if None node (nothing to add)\r\n      return 0\r\n    }\r\n\r\n    let nodeValue = maxTillRoot <= node.val ? 1 : 0;  // if there are no nodes with a value greater than max till root value.\r\n    nodeValue += dfs(node.left, Math.max(maxTillRoot, node.val));  // calculate left subnode\r\n    nodeValue += dfs(node.right, Math.max(maxTillRoot, node.val));  // calculate right subnode\r\n    \r\n    return nodeValue  // return current level sum\r\n  }\r\n\r\n  return dfs(root, root.val)\r\n}\r\n\r\n\r\n/**\r\n * dp, dfs, recursion, top-down, in-order traversal, stateful recursion\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar goodNodes = function (root) {\r\n  let goodNodesCounter = 0;\r\n\r\n  function dfs(node, maxTillRoot) {\r\n    if (!node) {  // if None node (nothing to add)\r\n      return 0\r\n    }\r\n\r\n    goodNodesCounter += maxTillRoot <= node.val ? 1 : 0;  // if there are no nodes with a value greater than max till root value.\r\n    dfs(node.left, Math.max(maxTillRoot, node.val));  // calculate left subnode\r\n    dfs(node.right, Math.max(maxTillRoot, node.val));  // calculate right subnode\r\n  }\r\n\r\n  dfs(root, root.val)\r\n\r\n  return goodNodesCounter\r\n}\r\n\r\n\r\n/**\r\n * class, arrow function\r\n * dp, dfs, recursion, top-down, in-order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nclass Solution {\r\n  constructor() {\r\n    this.goodNodesCounter = 0;\r\n  }\r\n\r\n  goodNodes(root) {\r\n    // The context of this changes inside inner dfs function. To maintain the correct reference to this, arrow funciton is used.\r\n    // Arrow function, which automatically binds this from the outer scope (i.e., the Solution class) and ensures this.goodNodesCounter correctly refers to the class property.\r\n    const dfs = (node, maxTillRoot) => {\r\n      // function dfs(node, maxTillRoot) {  // wrong reference\r\n      // const dfs = function (node, maxTillRoot) {  // wrong reference\r\n      if (!node) {  // if None node (nothing to add)\r\n        return 0\r\n      }\r\n\r\n      this.goodNodesCounter += maxTillRoot <= node.val ? 1 : 0;  // if there are no nodes with a value greater than max till root value.\r\n      dfs(node.left, Math.max(maxTillRoot, node.val));  // calculate left subnode\r\n      dfs(node.right, Math.max(maxTillRoot, node.val));  // calculate right subnode\r\n    }\r\n\r\n    dfs(root, root.val)\r\n\r\n    return this.goodNodesCounter\r\n  }\r\n}\r\nconsole.log(new Solution().goodNodes(buildTreeFromList([3, 1, 4, 3, null, 1, 5])), 4)\r\nconsole.log(new Solution().goodNodes(buildTreeFromList([3, 3, null, 4, 2])), 3)\r\nconsole.log(new Solution().goodNodes(buildTreeFromList([1])), 1)\r\n\r\n\r\n/**\r\n * class, self as this\r\n * dp, dfs, recursion, top-down, in-order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nclass Solution {\r\n  constructor() {\r\n    this.goodNodesCounter = 0;\r\n  }\r\n\r\n  goodNodes(root) {\r\n    // Save a reference to this and use it in the inner function. Assigned 'this' to a 'self' variable\r\n    const self = this;\r\n    // function dfs(node, maxTillRoot) {\r\n    const dfs = function (node, maxTillRoot) {\r\n\r\n      if (!node) {  // if None node (nothing to add)\r\n        return 0\r\n      }\r\n      // used self.goodNodesCounter instad of this.goodNodesCounter\r\n      self.goodNodesCounter += maxTillRoot <= node.val ? 1 : 0;  // if there are no nodes with a value greater than max till root value.\r\n      dfs(node.left, Math.max(maxTillRoot, node.val));  // calculate left subnode\r\n      dfs(node.right, Math.max(maxTillRoot, node.val));  // calculate right subnode\r\n    }\r\n\r\n    dfs(root, root.val)\r\n\r\n    return this.goodNodesCounter\r\n  }\r\n}\r\nconsole.log(new Solution().goodNodes(buildTreeFromList([3, 1, 4, 3, null, 1, 5])), 4)\r\nconsole.log(new Solution().goodNodes(buildTreeFromList([3, 3, null, 4, 2])), 3)\r\nconsole.log(new Solution().goodNodes(buildTreeFromList([1])), 1)\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  if (Number.isInteger(nodeList)) {  // case when the node list is a single value\r\n    nodeList = [nodeList];\r\n  }\r\n\r\n  const root = new TreeNode(nodeList[0]);  // Create the root node\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  // Process the list and construct the tree\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    // Assign the left child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    // Assign the right child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(goodNodes(buildTreeFromList([3, 1, 4, 3, null, 1, 5])), 4)\r\nconsole.log(goodNodes(buildTreeFromList([3, 3, null, 4, 2])), 3)\r\nconsole.log(goodNodes(buildTreeFromList([1])), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-23T14:33:01.157Z", "updated_at": "2024-09-24T13:36:07.075Z"}}, {"model": "python_problems.solution", "pk": 149, "fields": {"problem": 85, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, recursion, top-down, in-order traversal\r\n# O(n), O(n)\r\nclass Solution:\r\n    def isValidBST(self, root: TreeNode | None) -> bool:\r\n        def dfs(node, left_min,  right_max):\r\n            if not node:  # if node is None then the current branch i legit\r\n                return True  \r\n            \r\n            if not left_min < node.val < right_max:  # if value not in bounds\r\n                return False\r\n            \r\n            return (\r\n                dfs(node.left, left_min, node.val) and  # branch left \r\n                dfs(node.right, node.val, right_max)  # branch right\r\n                )\r\n\r\n        return dfs(root, float(\"-inf\"), float(\"inf\"))\r\n        \r\n\r\nfrom collections import deque\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, bfs, iterative, level order traversal\r\n# O(n), O(n)\r\nclass Solution:\r\n    def isValidBST(self, root: TreeNode | None) -> bool:\r\n        if not root:\r\n            return None\r\n        \r\n        queue = deque([(root, float(\"-Inf\"), float(\"Inf\"))])  # Create the root node\r\n\r\n        while queue:  # while queue is not empty\r\n            for _ in range(len(queue)):\r\n                node, min_val, max_val = queue.pop()  # for every node\r\n\r\n                if not min_val < node.val < max_val:  # if node value not in bounds return with False\r\n                    return False\r\n                \r\n                if node.left:  # if left subnode is not empty\r\n                    queue.append((node.left, min_val, min(max_val, node.val)))  # append it to queue\r\n                \r\n                if node.right:  # if right subnode is not empty\r\n                    queue.append((node.right, max(min_val, node.val), max_val))  # append it to queue\r\n\r\n        return True  # every node is legit, so return True\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type=TreeNode):\r\n    if not node_list:\r\n        return\r\n\r\n    if type(node_list) == int:  # case when the node list is a single value\r\n        node_list = [node_list]\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().isValidBST(build_tree_from_list([2, 1, 3])), True)\r\n(Solution().isValidBST(build_tree_from_list([5, 1, 4, None, None, 3, 6])), False)\r\n(Solution().isValidBST(build_tree_from_list([2, 2, 2])), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-24T14:37:44.642Z", "updated_at": "2024-09-24T14:37:44.658Z"}}, {"model": "python_problems.solution", "pk": 150, "fields": {"problem": 85, "language": 2, "owner": 3, "solution": "/**\r\n * dp, dfs, recursion, top-down, in-order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar isValidBST = function (root) {\r\n  function dfs(node, leftMin, rightMax) {\r\n    if (!node) {  // if node is None then the current branch i legit\r\n      return true\r\n    }\r\n\r\n    if (  // if value not in bounds\r\n      (leftMin >= node.val) ||\r\n      (node.val >= rightMax)\r\n    ) {\r\n      return false\r\n    }\r\n\r\n    return (\r\n      dfs(node.left, leftMin, node.val) &&  // branch left\r\n      dfs(node.right, node.val, rightMax)  // branch right\r\n    )\r\n  }\r\n\r\n  return dfs(root, -Infinity, Infinity)\r\n}\r\n\r\n\r\n/**\r\n * dp, bfs, iterative, level order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar isValidBST = function (root) {\r\n  if (!root) {\r\n    return false\r\n  }\r\n\r\n  const queue = [];\r\n  queue.push([root, -Infinity, Infinity]);\r\n\r\n  while (queue.length !== 0) {\r\n    const queueLength = queue.length;\r\n\r\n    for (index = 0; index < queueLength; index++) {\r\n      const [node, minLeft, maxRight] = queue.shift();\r\n\r\n      if (\r\n        node.val <= minLeft ||\r\n        node.val >= maxRight\r\n      ) {\r\n        return false\r\n      }\r\n\r\n      if (node.left) {\r\n        queue.push([node.left, minLeft, Math.min(maxRight, node.val)])\r\n      }\r\n\r\n      if (node.right) {\r\n        queue.push([node.right, Math.max(minLeft, node.val), maxRight])\r\n      }\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  if (Number.isInteger(nodeList)) {  // case when the node list is a single value\r\n    nodeList = [nodeList];\r\n  }\r\n\r\n  const root = new TreeNode(nodeList[0]);  // Create the root node\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  // Process the list and construct the tree\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    // Assign the left child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    // Assign the right child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(isValidBST(buildTreeFromList([2, 1, 3])), true)\r\nconsole.log(isValidBST(buildTreeFromList([5, 1, 4, null, null, 3, 6])), false)\r\nconsole.log(isValidBST(buildTreeFromList([2, 2, 2])), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-24T14:39:08.211Z", "updated_at": "2024-09-24T14:39:08.232Z"}}, {"model": "python_problems.solution", "pk": 151, "fields": {"problem": 86, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, recursion, in-order traversal\r\n# O(n), O(n)\r\nclass Solution:\r\n    def kthSmallest(self, root: TreeNode | None, k: int) -> int:\r\n        value_list = []\r\n\r\n        def dfs(node):\r\n            if node == None:  # if no Node\r\n                return\r\n\r\n            dfs(node.left)  # traverse left\r\n\r\n            if len(value_list) == k:  # early exit\r\n                return\r\n\r\n            value_list.append(node.val)  # append curren node value\r\n            dfs(node.right)  # traverse right\r\n\r\n        dfs(root)\r\n\r\n        return value_list[-1]  # return kth element\r\n\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, iteration, in-order traversal\r\n# O(n), O(n)\r\nclass Solution:\r\n    def kthSmallest(self, root: TreeNode | None, k: int) -> int:\r\n        stack = []\r\n        node = root\r\n        # value_list = []\r\n\r\n        while stack or node:  # while stack and node are not empty\r\n            while node:  # while node is not empty\r\n                stack.append(node)  # append node to stack\r\n                node = node.left  # branch left\r\n\r\n            node = stack.pop()  # take a node\r\n            # value_list.append(node.val)  # append node.val to value list\r\n            k -= 1  #  decrement counter\r\n\r\n            if not k:  # if counter = 0\r\n                return node.val  # current node value is kth element\r\n\r\n            node = node.right  # branch right\r\n\r\n        return False\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# Function to create a binary tree from a list (level-order traversal)\r\ndef build_tree_from_list(node_list, node_type=TreeNode):\r\n    if not node_list:\r\n        return\r\n\r\n    if type(node_list) == int:  # case when the node list is a single value\r\n        node_list = [node_list]\r\n\r\n    root = node_type(node_list[0])  # Create the root node\r\n    queue = deque([root])\r\n    index = 1\r\n\r\n    # Process the list and construct the tree\r\n    while index < len(node_list):\r\n        node = queue.popleft()\r\n\r\n        # Assign the left child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.left = node_type(node_list[index])\r\n            queue.append(node.left)\r\n        index += 1\r\n\r\n        # Assign the right child if available\r\n        if index < len(node_list) and node_list[index] != None:\r\n            node.right = node_type(node_list[index])\r\n            queue.append(node.right)\r\n        index += 1\r\n\r\n    return root", "testcase": "(Solution().kthSmallest(build_tree_from_list([5, 3, 7, 2, 4, None, 8]), 3), 4)\r\n(Solution().kthSmallest(build_tree_from_list([3, 1, 4, None, 2]), 1), 1)\r\n(Solution().kthSmallest(build_tree_from_list([5, 3, 6, 2, 4, None, None, 1]), 3), 3)\r\n(Solution().kthSmallest(build_tree_from_list([41,37,44,24,39,42,48,1,35,38,40,None,43,46,49,0,2,30,36,None,None,None,None,None,None,45,47,None,None,None,None,None,4,29,32,None,None,None,None,None,None,3,9,26,None,31,34,None,None,7,11,25,27,None,None,33,None,6,8,10,16,None,None,None,28,None,None,5,None,None,None,None,None,15,19,None,None,None,None,12,None,18,20,None,13,17,None,None,22,None,14,None,None,21,23]), 25), 24)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-25T12:06:56.117Z", "updated_at": "2024-09-25T12:06:56.138Z"}}, {"model": "python_problems.solution", "pk": 152, "fields": {"problem": 86, "language": 2, "owner": 3, "solution": "/**\r\n * dp, dfs, recursion, in-order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar kthSmallest = function (root, k) {\r\n  const valueList = [];\r\n\r\n  function dfs(node) {\r\n    if (!node) {  // if no Node\r\n      return\r\n    }\r\n\r\n    dfs(node.left)  // traverse left\r\n\r\n    if (valueList.length === k) {  // early exit\r\n      return\r\n    }\r\n\r\n    valueList.push(node.val);  // push current node value\r\n    dfs(node.right)  // traverse right\r\n  }\r\n\r\n  dfs(root)\r\n\r\n  return valueList[valueList.length - 1]  // recurn kth element\r\n}\r\n\r\n\r\n/**\r\n * dp, dfs, iteration, in-order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar kthSmallest = function (root, k) {\r\n  const queue = [];\r\n  let node = root;\r\n\r\n  while (queue || node) {  // while stack and node are not empty\r\n    while (node) {  // while node is not empty\r\n      queue.push(node);  // push node to stack\r\n      node = node.left;  // branch left\r\n    }\r\n\r\n    node = queue.pop();  // take a node\r\n    k--;  //  decrement counter\r\n\r\n    if (!k) {  // if counter = 0\r\n      return node.val  // current node value is kth element\r\n    }\r\n\r\n    node = node.right;  // branch right\r\n  }\r\n  return false\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function to create a binary tree from a list (level-order traversal)\r\nfunction buildTreeFromList(nodeList) {\r\n  if (!nodeList || nodeList.length === 0) return null\r\n\r\n  if (Number.isInteger(nodeList)) {  // case when the node list is a single value\r\n    nodeList = [nodeList];\r\n  }\r\n\r\n  const root = new TreeNode(nodeList[0]);  // Create the root node\r\n  const queue = [];\r\n  queue.push(root);\r\n  let index = 1;\r\n\r\n  // Process the list and construct the tree\r\n  while (index < nodeList.length) {\r\n    let node = queue.shift();\r\n\r\n    // Assign the left child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.left = new TreeNode(nodeList[index]);\r\n      queue.push(node.left)\r\n    }\r\n    index++;\r\n\r\n    // Assign the right child if available\r\n    if (index < nodeList.length && nodeList[index] != null) {\r\n      node.right = new TreeNode(nodeList[index]);\r\n      queue.push(node.right)\r\n    }\r\n    index++;\r\n  }\r\n  return root\r\n}", "testcase": "console.log(kthSmallest(buildTreeFromList([5, 3, 7, 2, 4, null, 8]), 3), 4)\r\nconsole.log(kthSmallest(buildTreeFromList([3, 1, 4, null, 2]), 1), 1)\r\nconsole.log(kthSmallest(buildTreeFromList([5, 3, 6, 2, 4, null, null, 1]), 3), 3)\r\nconsole.log(kthSmallest(buildTreeFromList([41, 37, 44, 24, 39, 42, 48, 1, 35, 38, 40, null, 43, 46, 49, 0, 2, 30, 36, null, null, null, null, null, null, 45, 47, null, null, null, null, null, 4, 29, 32, null, null, null, null, null, null, 3, 9, 26, null, 31, 34, null, null, 7, 11, 25, 27, null, null, 33, null, 6, 8, 10, 16, null, null, null, 28, null, null, 5, null, null, null, null, null, 15, 19, null, null, null, null, 12, null, 18, 20, null, 13, 17, null, null, 22, null, 14, null, null, 21, 23]), 25), 24)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-25T12:07:43.287Z", "updated_at": "2024-09-25T12:07:43.312Z"}}, {"model": "python_problems.solution", "pk": 153, "fields": {"problem": 87, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# dp, dfs, recursion, in-order traversal, pre-order traversal\r\n# O(n), O(n)\r\nclass Solution:\r\n    def buildTree(self, preorder: list[int], inorder: list[int]) -> TreeNode | None:\r\n        if not preorder or not inorder:\r\n            return\r\n        \r\n        node = Node(preorder[0])\r\n        split_index = inorder.index(preorder[0])  # \r\n        node.left = self.buildTree(preorder[1 : split_index + 1], inorder[: split_index])\r\n        node.right = self.buildTree(preorder[split_index + 1 : ], inorder[split_index + 1 :])\r\n        return node\r\n\r\n\r\nclass TreeNode:\r\n    def __init__(self, val=1, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\nfrom binarytree import Node\r\nfrom collections import deque\r\n\r\n# Function create a list from a binary tree in level-order (breadth-first traversal)\r\ndef level_order_traversal(root):\r\n    if not root:\r\n        return []\r\n    \r\n    node_list = []\r\n    queue = deque([root])  # Initialize the queue with the root node\r\n\r\n    while queue:\r\n        node = queue.popleft()  # Pop the current node\r\n\r\n        if node:\r\n            node_list.append(node.val)  # Add the value if node is not None\r\n            queue.append(node.left)  # Append left child (could be None)\r\n            queue.append(node.right)  # Append right child (could be None)\r\n        else:\r\n            node_list.append(None)  # Append None when the node is absent\r\n    \r\n    # Remove trailing None values\r\n    while node_list and node_list[-1] is None:\r\n        node_list.pop()\r\n\r\n    return node_list\r\n\r\n\r\nlevel_order_traversal(Solution().buildTree([3, 9, 20, 15, 7], [9, 3, 15, 20, 7]))", "testcase": "(level_order_traversal(Solution().buildTree([3, 9, 20, 15, 7], [9, 3, 15, 20, 7])), [3, 9, 20, None, None, 15, 7])\r\n(level_order_traversal(Solution().buildTree([-1], [-1])), [-1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-25T15:10:29.897Z", "updated_at": "2024-09-25T15:10:29.915Z"}}, {"model": "python_problems.solution", "pk": 154, "fields": {"problem": 87, "language": 2, "owner": 3, "solution": "/**\r\n * dp, dfs, recursion, in-order traversal, pre-order traversal\r\n * O(n), O(n)\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {number[]} preorder\r\n * @param {number[]} inorder\r\n * @return {TreeNode}\r\n */\r\nvar buildTree = function (preorder, inorder) {\r\n  if (preorder.length === 0 || inorder.length === 0) {\r\n    return null  // if return empty leetcode complains\r\n  }\r\n\r\n  let node = new TreeNode(preorder[0]);\r\n  const split_index = inorder.indexOf(preorder[0]);  \r\n  node.left = buildTree(preorder.slice(1, split_index + 1), inorder.slice(0, split_index));\r\n  node.right = buildTree(preorder.slice(split_index + 1,), inorder.slice(split_index + 1,));\r\n\r\n  return node\r\n}\r\n\r\n\r\nclass TreeNode {\r\n  constructor(val = 0, left = null, right = null) {\r\n    this.val = val\r\n    this.left = left\r\n    this.right = right\r\n  }\r\n}\r\n\r\n\r\n// Function create a list from a binary tree in level-order (breadth-first traversal)\r\nfunction levelOrderTraversal(root) {\r\n  if (root.length === 0) {\r\n    return []\r\n  }\r\n\r\n  const nodeList = [];\r\n  const queue = [];\r\n  queue.push(root);\r\n\r\n  while (queue.length !== 0) {\r\n    let node = queue.shift();\r\n    \r\n    if (node) {\r\n      nodeList.push(node.val);\r\n      queue.push(node.left);\r\n      queue.push(node.right);\r\n    } else {\r\n      nodeList.push(null);\r\n    }\r\n  }\r\n  while (nodeList.length > 0 && nodeList[nodeList.length - 1] === null) {\r\n    nodeList.pop();\r\n  }\r\n\r\n  return nodeList\r\n}\r\n\r\n//console.log(buildTree([3, 9, 20, 15, 7], [9, 3, 15, 20, 7]))", "testcase": "console.log(levelOrderTraversal(buildTree([3, 9, 20, 15, 7], [9, 3, 15, 20, 7])), [3, 9, 20, null, null, 15, 7])\r\nconsole.log(levelOrderTraversal(buildTree([-1], [-1])), [-1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-25T15:12:18.527Z", "updated_at": "2024-09-25T15:12:18.552Z"}}, {"model": "python_problems.solution", "pk": 155, "fields": {"problem": 88, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def combinationSum3(self, k: int, n: int) -> list[list[int]]:\r\n        combination = []\r\n        combination_list = []\r\n\r\n        def dfs(index):\r\n            if (sum(combination) == n and  # if target sum reached and\r\n                len(combination) == k):  # target length reached\r\n                combination_list.append(combination.copy())  # add current solution\r\n                return\r\n            elif (index == 10 or  # if digit out of bounds\r\n                  sum(combination) > n):  # and target sum exceeded\r\n                return\r\n            \r\n            combination.append(index)  # include digit in solution\r\n            dfs(index + 1)  # explore path with current digit\r\n            combination.pop()  # exclude digit from soultion\r\n            dfs(index + 1)  # explore path withou curren digit\r\n\r\n        dfs(1)\r\n\r\n        return combination_list", "testcase": "(Solution().combinationSum3(3, 7), [1, 2, 4])\r\n(Solution().combinationSum3(3, 9), [[1, 2, 6], [1, 3, 5], [2, 3, 4]], [1, 2, 4])\r\n(Solution().combinationSum3(4, 1), [])", "time_complexity": 6, "space_complexity": 2, "created_at": "2024-09-27T19:30:15.314Z", "updated_at": "2024-09-27T19:30:15.333Z"}}, {"model": "python_problems.solution", "pk": 156, "fields": {"problem": 88, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number} k\r\n * @param {number} n\r\n * @return {number[][]}\r\n */\r\nvar combinationSum3 = function (k, n) {\r\n  const combinatioin = [];\r\n  const combinatioinList = [];\r\n\r\n  var dfs = (index) => {\r\n    const combinatioinSum = combinatioin.reduce((a, b) => a + b, 0);\r\n    \r\n    if (\r\n      combinatioinSum === n &&  // if target sum reached and\r\n      combinatioin.length === k  // target length reached\r\n    ) {\r\n      combinatioinList.push(combinatioin.slice());  // add current solution\r\n      return\r\n    } else if (\r\n      combinatioinSum > n ||  // if digit out of bounds\r\n      index === 10  // and target sum exceeded\r\n    ) {\r\n      return\r\n    }\r\n\r\n    combinatioin.push(index);  // include digit in solution\r\n    dfs(index + 1)  // explore path with current digit\r\n    combinatioin.pop();  // exclude digit from soultion\r\n    dfs(index + 1)  // explore path withou curren digit\r\n  }\r\n\r\n  dfs(1)\r\n\r\n  return combinatioinList\r\n}", "testcase": "console.log(combinationSum3(3, 7), [1, 2, 4])\r\nconsole.log(combinationSum3(3, 9), [[1, 2, 6], [1, 3, 5], [2, 3, 4]])\r\nconsole.log(combinationSum3(4, 1), [])", "time_complexity": 6, "space_complexity": 2, "created_at": "2024-09-27T19:43:50.911Z", "updated_at": "2024-09-27T19:43:50.928Z"}}, {"model": "python_problems.solution", "pk": 157, "fields": {"problem": 89, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def combinationSum4(self, numbers: list[int], target: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up with tabulation as list\r\n        \"\"\"\r\n        # Initialize a list of zeros for tabulation, where tab[i] is the number of ways to make sum i\r\n        cache = [0] * (target + 1)\r\n        # Base case: 1 way to make target 0 (empty combination)\r\n        cache[0] = 1\r\n\r\n        for index in range(1, target + 1):\r\n            for number in numbers:\r\n                # If num can be subtracted from index, add the number of ways to make (index - number)\r\n                if index - number >= 0:\r\n                    cache[index] += cache[index - number]\r\n            \r\n        return cache[-1]\r\n\r\n\r\nclass Solution:\r\n    def combinationSum4(self, numbers: list[int], target: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up with tabulation as hash map\r\n        \"\"\"\r\n        # Tabulation dictionary, storing base case: 1 way to make target 0 (empty combination)\r\n        cache = {0: 1}\r\n\r\n        for index in range(1, target + 1):\r\n            for number in numbers:\r\n                if index - number >= 0:\r\n                    # If the number can be used (valid combination), update the tabulation table\r\n                    cache[index] = (cache.get(index, 0) + \r\n                                    cache.get(index - number, 0))\r\n            \r\n        return cache.get(target, 0)\r\n\r\n\r\nclass Solution:\r\n    def combinationSum4(self, numbers: list[int], target: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        # Memoization dictionary, storing base case: 1 way to make target 0 (empty combination)\r\n        memo = {0: 1}\r\n\r\n        def dfs(target: int) -> int:\r\n            if target in memo:\r\n                return memo[target]\r\n            elif target < 0:\r\n                return 0\r\n\r\n            # Recursively compute number of combinations by reducing the target (target - number)\r\n            memo[target] = sum(dfs(target - number)\r\n                               for number in numbers)\r\n            return memo[target]\r\n\r\n        return dfs(target)\r\n\r\n\r\nclass Solution:\r\n    def combinationSum4(self, numbers: list[int], target: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        # Memoization list, storing base case: 1 way to make target 0 (empty combination)\r\n        memo = [None] * (target + 1)\r\n        memo[0] = 1\r\n\r\n        def dfs(target: int) -> int:\r\n            if target < 0:\r\n                return 0\r\n            elif memo[target] is not None:\r\n                return memo[target]\r\n\r\n            # Recursively compute number of combinations by reducing the target (target - number)\r\n            memo[target] = sum(dfs(target - number)\r\n                               for number in numbers)\r\n            return memo[target]\r\n\r\n        return dfs(target)\r\n\r\n\r\nclass Solution:\r\n    def combinationSum4(self, numbers: list[int], target: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        converts to top-down\r\n        \"\"\"\r\n        def dfs(target: int) -> int:\r\n            if target == 0:\r\n                return 1\r\n            elif target < 0:\r\n                return 0\r\n\r\n            return sum(dfs(target - number)\r\n                       for number in numbers)\r\n\r\n        return dfs(target)\r\n\r\n\r\nclass Solution:\r\n    def combinationSum4(self, numbers: list[int], target: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, backtracking, tle\r\n        \"\"\"\r\n        combination = []\r\n        combination_list = []\r\n        self.combination_counter = 0\r\n\r\n        def dfs(target): #\r\n            if target < 0:\r\n                return\r\n            elif target == 0:\r\n                # combination_list.append(combination.copy())\r\n                # combination_list.append(True)\r\n                self.combination_counter += 1\r\n                return\r\n\r\n            for number in numbers:\r\n                combination.append(number)\r\n                dfs(target - number)\r\n                combination.pop()\r\n\r\n        dfs(target)\r\n        # return combination_list\r\n        # return len(combination_list)\r\n        return self.combination_counter", "testcase": "print(Solution().combinationSum4([5], 5), 1)\r\nprint(Solution().combinationSum4([2, 3], 7), 3)\r\nprint(Solution().combinationSum4([1, 2, 3], 4), 7)\r\nprint(Solution().combinationSum4([9], 3), 0)\r\nprint(Solution().combinationSum4([4, 2, 1], 32), 39882198)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-09-28T22:27:56.313Z", "updated_at": "2025-02-19T14:19:32.751Z"}}, {"model": "python_problems.solution", "pk": 158, "fields": {"problem": 89, "language": 2, "owner": 3, "solution": "/**\r\n * dp, bottom-up, iteration, tabulation (with List)\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar combinationSum4 = function (nums, target) {\r\n  // Initialize a list of zeros for tabulation, where tab[i] is the number of ways to make sum i\r\n  const tab = new Array(target + 1).fill(0);\r\n  // Base case: 1 way to make target 0 (empty combination)\r\n  tab[0] = 1;\r\n\r\n  // Iterate through all indices from 1 to target\r\n  for (let index = 1; index <= target; index++) {\r\n    // For each number in nums, check if it can contribute to the current target (index)\r\n    for (const num of nums) {\r\n      // If num can be subtracted from index, add the number of ways to make (index - num)\r\n      if (index - num >= 0) {\r\n        tab[index] += tab[index - num]\r\n      }\r\n    }\r\n  }\r\n  // Return the result for the target, which is stored in the last element of the list\r\n  return tab[tab.length - 1]\r\n}\r\n\r\n\r\n/**\r\n * dp, bottom-up, iteration, tabulation (with Dictionary)\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar combinationSum4 = function (nums, target) {\r\n  // Tabulation dictionary, storing base case: 1 way to make target 0 (empty combination)\r\n  const tab = new Map();\r\n  // Base case: 1 way to make target 0 (empty combination)\r\n  tab.set(0, 1);\r\n\r\n  // Iterate through all indices from 1 to target\r\n  for (let index = 1; index <= target; index++) {\r\n    // For each number in nums, check if it can contribute to the current target (index)\r\n    for (const num of nums) {\r\n      // If num can be subtracted from index, add the number of ways to make (index - num)\r\n      if (index - num >= 0) {\r\n        tab.set(index, (tab.get(index) ?? 0) + (tab.get(index - num) ?? 0))\r\n      }\r\n    }\r\n  }\r\n  // Return the result for the target value, default to 0 if no combinations\r\n  return tab.get(target) ?? 0\r\n}\r\n\r\n\r\n/**\r\n * dp,  dfs, top-down, recursion, memoization (with List)\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar combinationSum4 = function (nums, target) {\r\n  // Memoization dictionary, storing base case: 1 way to make target 0 (empty combination)\r\n  const memo = new Array(target + 1).fill(-1);\r\n  memo[0] = 1;\r\n\r\n  // Helper function that performs depth-first search (DFS)\r\n  var dfs = (index) => {\r\n    // If the index is negative, no valid combination can be made, return 0\r\n    if (index < 0) {\r\n      return 0\r\n      // If the value has already been computed, return it (memoization check)\r\n    } else if (memo[index] !== -1) {\r\n      return memo[index]\r\n    }\r\n    \r\n    // Initialize the number of ways to make the current index\r\n    memo[index] = 0;\r\n\r\n    // Iterate over each number in the list\r\n    for (const num of nums) {\r\n      // Recursively compute number of combinations by reducing the target (index - num)\r\n      memo[index] += dfs(index - num)\r\n    }\r\n    // Return the computed value for the current target (index)\r\n    return memo[index]\r\n  }\r\n\r\n  // Start the recursion with the target value\r\n  return dfs(target)\r\n}", "testcase": "console.log(combinationSum4([1, 2, 3], 4), 7)\r\nconsole.log(combinationSum4([9], 3), 0)\r\nconsole.log(combinationSum4([4, 2, 1], 32), 39882198)\r\nconsole.log(combinationSum4([2, 3], 7), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-09-28T22:28:32.288Z", "updated_at": "2024-09-28T22:28:32.308Z"}}, {"model": "python_problems.solution", "pk": 159, "fields": {"problem": 90, "language": 1, "owner": 3, "solution": "# O(n2), O(n2)\r\n# dfs, recursion\r\nclass Solution:\r\n    \"\"\"\r\n    Starts from not visited land tile, check recursively all neighbours and \r\n    mark them as visited.\r\n    Add one to land counter.\r\n\r\n    Boundary checks: It includes all the boundary \r\n    and visited checks directly in the base case of the recursion.\r\n    \"\"\"\r\n\r\n    def numIslands(self, grid: list[list[str]]) -> int:\r\n        rows = len(grid)  # Number of rows in the grid.\r\n        cols = len(grid[0])  # Number of columns in the grid.\r\n        visited_land = set()  # Set to keep track of visited land cells.\r\n        island_counter = 0  # Counter for the number of islands found.\r\n\r\n        def dfs(row, col):\r\n            # If the cell is out of bounds, water, or already visited, stop exploring.\r\n            if (row < 0 or\r\n                col < 0 or\r\n                row == rows or\r\n                col == cols or\r\n                (row, col) in visited_land or\r\n                    grid[row][col] == \"0\"):\r\n                return\r\n            \r\n            visited_land.add((row, col))  # Mark the current cell as visited.\r\n\r\n            # Explore all four possible directions: right, left, down, up.\r\n            for i, j in ((0, 1), (0, -1), (1, 0), (-1, 0)):\r\n                dfs(row + i, col + j)  # Recursively visit neighboring cells.\r\n\r\n        # Iterate over each cell in the grid.\r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                # Start a new DFS when an unvisited land cell (\"1\") is found.\r\n                if (grid[row][col] == \"1\" and\r\n                        (row, col) not in visited_land):\r\n                    island_counter += 1  # Increment the island counter.\r\n                    dfs(row, col)  # Perform DFS to mark the entire island.\r\n\r\n        return island_counter  # Return the total number of islands found.\r\n\r\n\r\n# O(n2), O(n2)\r\n# dfs, recursion\r\nclass Solution:\r\n    \"\"\"\r\n    Starts from land tile and check recursively all neighbours.\r\n    Mark every visited cell and return area (True) to be counted as a one island.\r\n    Skip visited lands.\r\n    \"\"\"\r\n    \r\n    def numIslands(self, grid: list[list[str]]) -> int:\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        visited_land = set()\r\n        island_counter = 0\r\n\r\n        def dfs(row, col):\r\n            if (row < 0 or \r\n                row == rows or \r\n                col < 0 or \r\n                col == cols or \r\n                grid[row][col] == \"0\" or \r\n                    (row, col) in visited_land):\r\n                return 0\r\n            \r\n            visited_land.add((row, col))\r\n\r\n            return (\r\n                1 +\r\n                dfs(row - 1, col) + \r\n                dfs(row + 1, col) +\r\n                dfs(row, col - 1) +\r\n                dfs(row, col + 1)\r\n            )\r\n\r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if grid[row][col] == \"1\":\r\n                    if dfs(row, col):\r\n                        island_counter += 1\r\n\r\n        return island_counter\r\n\r\n\r\n# O(n2), O(n2)\r\n# dfs, recursion\r\nclass Solution:\r\n    \"\"\"\r\n    Starts from land tile and check recursively all neighbours and \r\n    mark them as water tiles. Add one to land counter.\r\n    Skip visited water.\r\n    \"\"\"\r\n    \r\n    def numIslands(self, grid: list[list[str]]) -> int:\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        island_counter = 0\r\n\r\n        def dfs(row, col):\r\n            if (row < 0 or \r\n                row == rows or \r\n                col < 0 or \r\n                col == cols or \r\n                    grid[row][col] == \"0\"):\r\n                return\r\n            \r\n            grid[row][col] = \"0\"\r\n\r\n            dfs(row - 1, col)\r\n            dfs(row + 1, col)\r\n            dfs(row, col - 1)\r\n            dfs(row, col + 1)\r\n\r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if grid[row][col] == \"1\":\r\n                    dfs(row, col)\r\n                    island_counter += 1\r\n\r\n        return island_counter\r\n\r\n\r\nfrom collections import deque\r\n\r\n# O(n2), O(n2)\r\n# bfs, iterative\r\nclass Solution:\r\n    def numIslands(self, grid: list[list[str]]) -> int:\r\n        rows = len(grid)  # Number of rows in the grid.\r\n        cols = len(grid[0])  # Number of columns in the grid.\r\n        visited_land = set()  # Set to keep track of visited land cells.\r\n        island_counter = 0  # Counter for the number of islands found.\r\n\r\n        # BFS function to explore the island starting from the given cell.\r\n        def bfs(row, col):\r\n            visited_land.add((row, col))  # Mark the current cell as visited.\r\n            queue = deque()  # Initialize a queue for BFS.\r\n            queue.append((row, col))  # Start with the current land cell.\r\n\r\n            while queue:\r\n                row, col = queue.popleft()  # Dequeue the next cell to explore.\r\n\r\n                # Iterate over the possible directions (right, left, down, up).\r\n                for i, j in ((-1, 0), (1, 0), (0, -1), (0, 1)):\r\n                    r = row + i\r\n                    c = col + j\r\n\r\n                    # Check if the neighbor is within bounds, unvisited, and land.\r\n                    if (0 <= r < rows and\r\n                        0 <= c < cols and\r\n                        grid[r][c] == \"1\" and\r\n                            (r, c) not in visited_land):\r\n                        queue.append((r, c))  # Add the land cell to the queue.\r\n                        visited_land.add((r, c))  # Mark it as visited.\r\n\r\n        # Iterate over each cell in the grid.\r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                # If the cell is land and hasn't been visited, start a new BFS.\r\n                if (grid[row][col] == \"1\" and \r\n                        (row, col) not in visited_land):\r\n                    island_counter += 1  # Increment the island counter.\r\n                    bfs(row, col)  # Perform BFS to mark the entire island.\r\n\r\n        return island_counter  # Return the total number of islands found.", "testcase": "print(Solution().numIslands([[\"0\"]]), 0)\r\nprint(Solution().numIslands([[\"1\"]]), 1)\r\nprint(Solution().numIslands([[\"0\", \"0\"], [\"0\", \"1\"]]), 1)\r\nprint(Solution().numIslands([[\"1\", \"0\"], [\"0\", \"1\"]]), 2)\r\nprint(Solution().numIslands([[\"1\", \"0\", \"0\"], [\"0\", \"1\", \"0\"], [\"0\", \"0\", \"1\"]]), 3)\r\nprint(Solution().numIslands([[\"1\", \"1\", \"0\"], [\"0\", \"1\", \"0\"], [\"0\", \"0\", \"1\"]]), 2)\r\nprint(Solution().numIslands([[\"1\", \"1\", \"1\", \"1\", \"0\"], [\"1\", \"1\", \"0\", \"1\", \"0\"], [\"1\", \"1\", \"0\", \"0\", \"0\"], [\"0\", \"0\", \"0\", \"0\", \"0\"]]), 1)\r\nprint(Solution().numIslands([[\"1\", \"1\", \"0\", \"0\", \"0\"], [\"1\", \"1\", \"0\", \"0\", \"0\"], [\"0\", \"0\", \"1\", \"0\", \"0\"], [\"0\", \"0\", \"0\", \"1\", \"1\"]]), 3)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-09-29T17:36:36.932Z", "updated_at": "2025-01-23T16:05:39.885Z"}}, {"model": "python_problems.solution", "pk": 160, "fields": {"problem": 90, "language": 2, "owner": 3, "solution": "/**\r\n * dfs, recursion\r\n * @param {character[][]} grid\r\n * @return {number}\r\n */\r\nvar numIslands = function (grid) {\r\n  const rows = grid.length;  // Number of rows in the grid.\r\n  const cols = grid[0].length;  // Number of columns in the grid.\r\n  const visitedLand = new Set();  // Set to keep track of visited land cells.\r\n  let islandCounter = 0;  // Counter for the number of islands found.\r\n\r\n  const dfs = (row, col) => {\r\n    visitedLand.add(`${row},${col}`);  // Mark the current cell as visited.\r\n\r\n    // Iterate over the possible directions (right, left, down, up).\r\n    for ([di, dj] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\r\n      const i = row + di;\r\n      const j = col + dj;\r\n      \r\n      // If the neighbor is within bounds, not visited, and is land, explore it.\r\n      if (\r\n        i < rows &&\r\n        j < cols &&\r\n        i >= 0 &&\r\n        j >= 0 &&\r\n        !visitedLand.has(`${i},${j}`) &&\r\n        grid[i][j] === '1'\r\n      ) {\r\n        dfs(i, j)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check each cell in the grid.\r\n  for (let row = 0; row < rows; row++) {\r\n    for (let col = 0; col < cols; col++) {\r\n      // Start a new DFS for every unvisited land cell, indicating a new island.\r\n      if (\r\n        grid[row][col] === '1' &&\r\n        !visitedLand.has(`${row},${col}`)\r\n      ) {\r\n          islandCounter++;  // Increment the island counter.\r\n          dfs(row, col)  // Perform DFS to mark the entire island.\r\n        }\r\n    }\r\n  }\r\n\r\n  return islandCounter  // Return the total number of islands found.\r\n}", "testcase": "console.log(numIslands([[\"1\", \"1\", \"1\", \"1\", \"0\"], [\"1\", \"1\", \"0\", \"1\", \"0\"], [\"1\", \"1\", \"0\", \"0\", \"0\"], [\"0\", \"0\", \"0\", \"0\", \"0\"]]), 1)\r\nconsole.log(numIslands([[\"1\", \"1\", \"0\", \"0\", \"0\"], [\"1\", \"1\", \"0\", \"0\", \"0\"], [\"0\", \"0\", \"1\", \"0\", \"0\"], [\"0\", \"0\", \"0\", \"1\", \"1\"]]), 3)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-09-29T17:38:22.813Z", "updated_at": "2024-09-29T17:38:22.833Z"}}, {"model": "python_problems.solution", "pk": 161, "fields": {"problem": 91, "language": 1, "owner": 3, "solution": "# dfs, recursion, check boundary first\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: list[list[int]]) -> int:\r\n        rows = len(grid)  # Get the number of rows and columns in the grid\r\n        cols = len(grid[0])\r\n        visited_land = set()  # Set to keep track of the visited land cells\r\n        max_island_area = 0  # Variable to store the maximum area of an island found so far\r\n        \r\n        def dfs(row, col):  # Depth-First Search (DFS) function to explore an island\r\n            visited_land.add((row, col))  # Mark the current cell as visited\r\n            adjecent_area = 0  # Variable to track the area of the current island's adjacent cells\r\n            directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]  # Possible directions to move: right, down, up, and left\r\n            \r\n            for di, dj in directions:  # Explore the neighboring cells\r\n                i = row + di  # Row in the new direction\r\n                j = col + dj  # Column in the new direction\r\n                \r\n                if (0 <= i < rows and  # Check if the new cell is within bounds, hasn't been visited, and is land (grid[i][j] == 1)\r\n                    0 <= j < cols and\r\n                    not (i, j) in visited_land and\r\n                    grid[i][j] == 1\r\n                ):\r\n                    adjecent_area += dfs(i, j)  # Recursively explore the neighboring land cell and add its area\r\n            \r\n            return adjecent_area + 1  # Return the area of the current cell (1) plus the adjacent area found\r\n                \r\n        for row in range(rows):  # Iterate through each cell in the grid\r\n            for col in range(cols):\r\n                if (grid[row][col] == 1 and  # If the current cell is land and hasn't been visited yet\r\n                    not (row, col) in visited_land\r\n                ):\r\n                    max_island_area = max(max_island_area, dfs(row, col))  # Perform DFS from this cell and update the maximum island area\r\n        \r\n        return max_island_area  # Return the largest island area found\r\n\r\n\r\n# # dfs, recursion, check boundary in recursion\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: list[list[int]]) -> int:\r\n        # Get the number of rows and columns in the grid\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        visited_land = set()  # Set to keep track of the visited land cells\r\n        max_island_area = 0  # Variable to store the maximum area of an island found so far\r\n        \r\n        def dfs(row, col):  # Depth-First Search (DFS) function to explore an island\r\n            if (not 0 <= row < rows or  # Check if the new cell is within bounds, hasn't been visited, and is land (grid[i][j] == 1)\r\n                not 0 <= col < cols or\r\n                (row, col) in visited_land or\r\n                grid[row][col] == 0\r\n            ):\r\n                return 0\r\n                     \r\n            visited_land.add((row, col))  # Mark the current cell as visited\r\n            adjecent_area = 0  # Variable to track the area of the current island's adjacent cells\r\n            directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]  # Possible directions to move: right, down, up, and left\r\n            \r\n            for di, dj in directions:  # Explore the neighboring cells\r\n                i = row + di  # Row in the new direction\r\n                j = col + dj  # Column in the new direction\r\n                adjecent_area += dfs(i, j)  # Recursively explore the neighboring land cell and add its area\r\n            \r\n            return adjecent_area + 1  # Return the area of the current cell (1) plus the adjacent area found\r\n                \r\n        for row in range(rows):  # Iterate through each cell in the grid\r\n            for col in range(cols):\r\n                max_island_area = max(max_island_area, dfs(row, col))  # Perform DFS from this cell and update the maximum island area\r\n        \r\n        return max_island_area  # Return the largest island area found", "testcase": "(Solution().maxAreaOfIsland([[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]]), 6)\r\n(Solution().maxAreaOfIsland([[0, 0, 0, 0, 0, 0, 0, 0]]), 0)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-09-29T19:58:25.971Z", "updated_at": "2024-09-29T19:58:25.988Z"}}, {"model": "python_problems.solution", "pk": 162, "fields": {"problem": 91, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar maxAreaOfIsland = function (grid) {\r\n  const rows = grid.length;  // Get the number of rows and columns in the grid\r\n  const cols = grid[0].length;\r\n  let maxIslandArea = 0;  // Variable to store the maximum island area found so far\r\n  const visitedLand = new Set();  // Set to keep track of visited land cells (as strings of \"row,col\")\r\n  \r\n  const dfs = (row, col) => {  // Depth-First Search (DFS) function to explore the island\r\n    visitedLand.add(`${row},${col}`);  // Mark the current cell as visited\r\n    let adjecentArea = 0;  // Variable to track the adjacent area of the current island\r\n    const directions = [[0, 1], [1, 0], [-1, 0], [0, -1]];  // Define the four possible directions: right, down, up, and left\r\n\r\n    for (const [di, dj] of directions) {  // Explore neighboring cells\r\n      const i = row + di;  // Row in the new direction\r\n      const j = col + dj;  // Column in the new direction\r\n      \r\n      if (  // Check if the new cell is within bounds, hasn't been visited, and is land (grid[i][j] == 1)\r\n        i < rows &&\r\n        j < cols &&\r\n        i >= 0 &&\r\n        j >= 0 &&\r\n        !visitedLand.has(`${i},${j}`) &&\r\n        grid[i][j] === 1\r\n      ) {\r\n        adjecentArea += dfs(i, j);  // Recursively explore neighboring land cells and accumulate their area\r\n      }\r\n    }\r\n    return adjecentArea + 1  // Return the current cell's area (1) plus the adjacent area found\r\n  }\r\n\r\n  for (let row = 0; row < rows; row++) {  // Iterate through each cell in the grid\r\n    for (let col = 0; col < cols; col++) {\r\n      if (  // If the current cell is land and hasn't been visited\r\n        grid[row][col] === 1 &&\r\n        !visitedLand.has(`${row},${col}`)\r\n      ) {\r\n        maxIslandArea = Math.max(maxIslandArea, dfs(row, col));  // Perform DFS from this cell and update the maximum island area\r\n      }\r\n    }\r\n  }\r\n  \r\n  return maxIslandArea;  // Return the largest island area found\r\n}", "testcase": "console.log(maxAreaOfIsland([[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]]), 6)\r\nconsole.log(maxAreaOfIsland([[0, 0, 0, 0, 0, 0, 0, 0]]), 0)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-09-29T19:59:17.521Z", "updated_at": "2024-09-29T19:59:17.543Z"}}, {"model": "python_problems.solution", "pk": 163, "fields": {"problem": 92, "language": 1, "owner": 3, "solution": "# Definition for a Node.\r\nclass Node:\r\n    def __init__(self, val=0, neighbors=[]):\r\n        self.val = val\r\n        self.neighbors = neighbors if neighbors is not None else []\r\n\r\n\r\n# O(n), O(n)\r\n# dfs, recursion\r\nclass Solution:\r\n    def cloneGraph(self, node: Node | None) -> Node | None:\r\n        org_to_copy = {}  # Dictionary to map original nodes to their clones\r\n\r\n        def clone(node):\r\n            if node in org_to_copy:  # If the node is already cloned, return the clone\r\n                return org_to_copy[node]\r\n\r\n            new_node = Node(node.val)  # Create a new node with the same value\r\n            org_to_copy[node] = new_node  # Map the original node to the new clone\r\n\r\n            for neighbor in node.neighbors:  # Iterate through all neighbors\r\n                new_node.neighbors.append(clone(neighbor))  # Recursively clone neighbors and add to the clone's neighbor list\r\n            \r\n            return new_node  # Return the cloned node\r\n\r\n        return clone(node) if node else None  # Return cloned graph or None if input node is None\r\n\r\n\r\n# [[2, 4], [1, 3], [2, 4], [1, 3]]\r\n\r\nnode1 = Node(1)\r\nnode2 = Node(2)\r\nnode3 = Node(3)\r\nnode4 = Node(4)\r\n\r\nnode1.neighbors = [node2, node4]\r\nnode2.neighbors = [node1, node3]\r\nnode3.neighbors = [node2, node4]\r\nnode4.neighbors = [node1, node3]\r\nnode4.neighbors\r\nnode4.neighbors[0].val\r\n\r\nnew_node = Solution().cloneGraph(node1)\r\nnew_node.val", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-30T15:06:00.747Z", "updated_at": "2025-01-30T17:11:36.851Z"}}, {"model": "python_problems.solution", "pk": 164, "fields": {"problem": 92, "language": 2, "owner": 3, "solution": "// Definition for a _Node.\r\nclass _Node {\r\n  constructor(val, neighbors) {\r\n    this.val = val === undefined ? 0 : val;\r\n    this.neighbors = neighbors === undefined ? [] : neighbors;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @param {_Node} node\r\n * @return {_Node}\r\n*/\r\nvar cloneGraph = function (node) {\r\n  if (node === null) {// Return null if input node is null\r\n    return null\r\n  }\r\n  const oldToNew = new Map();  // Dictionary to map original nodes to their clones\r\n\r\n  const clone = (node) => {\r\n    if (oldToNew.has(node)) {  // If the node is already cloned, return the clone\r\n      return oldToNew.get(node)\r\n    }\r\n\r\n    const new_node = new _Node(node.val);  // Create a new node with the same value\r\n    oldToNew.set(node, new_node);  // Map the original node to the new clone\r\n\r\n    for (const neighbor of node.neighbors) {  // Iterate through all neighbors\r\n      new_node.neighbors.push(clone(neighbor))  // Recursively clone neighbors and add to the clone's neighbor list\r\n    }\r\n    \r\n    return new_node  // Return the cloned node\r\n  }\r\n\r\n  return clone(node)  // Return cloned graph\r\n}\r\n\r\n// [[2, 4], [1, 3], [2, 4], [1, 3]]\r\n\r\nnode1 = new _Node(1)\r\nnode2 = new _Node(2)\r\nnode3 = new _Node(3)\r\nnode4 = new _Node(4)\r\n\r\nnode1.neighbors = [node2, node4]\r\nnode2.neighbors = [node1, node3]\r\nnode3.neighbors = [node2, node4]\r\nnode4.neighbors = [node1, node3]\r\n// console.log(node4.neighbors)\r\nconsole.log(node4.neighbors[0].val)\r\n\r\nnew_node = cloneGraph(node1)\r\nconsole.log(new_node.val)", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-09-30T15:43:52.099Z", "updated_at": "2024-09-30T15:43:52.116Z"}}, {"model": "python_problems.solution", "pk": 165, "fields": {"problem": 93, "language": 1, "owner": 3, "solution": "# O(n4), O(n2)\r\n# may vistit the same land more than once\r\n# dfs, recursion\r\nclass Solution:\r\n    def islandsAndTreasure(self, grid: list[list[int]]) -> None:\r\n        # def wallsAndGates(self, grid: list[list[int]]) -> None:\r\n        rows = len(grid)  # Get the number of rows\r\n        cols = len(grid[0])  # Get the number of columns\r\n        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))  # Possible 4 directions\r\n\r\n        def dfs(row, col, distance):\r\n            if (row < 0 or\r\n                row == rows or  # Check if row out of bounds\r\n                col < 0 or\r\n                col == cols or  # Check if column out of bounds\r\n                grid[row][col] == -1 or  # check if water\r\n                (distance and grid[row][col] == 0) or  # check if starting treasure\r\n                    grid[row][col] < distance):  # check if shorter distance is already found\r\n                return\r\n\r\n            grid[row][col] = distance  # Mark the current cell with the distance\r\n\r\n            for i, j in directions:\r\n                dfs(row + i, col + j, distance + 1)\r\n\r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if grid[row][col] == 0:  # check if the cell is a treasure\r\n                    dfs(row, col, 0)  # Start DFS with distance 0\r\n\r\n        return grid\r\n\r\n\r\nfrom collections import deque\r\n\r\n# O(n2), O(n2)\r\n# bfs, iteration, deque\r\nclass Solution:\r\n    def islandsAndTreasure(self, grid: list[list[int]]) -> None:\r\n    # def wallsAndGates(self, grid: list[list[int]]) -> None:\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\r\n        queue = deque()  # Initialize a queue for BFS\r\n        visited = set()  # Set to keep track of visited land\r\n\r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if grid[row][col] == 0:  # If the cell is land (0)\r\n                    queue.append((row, col))  # Add the land cell to the queue\r\n\r\n        distance = 0  # Initialize distance from the treasure\r\n        while queue:  # While there are cells to process\r\n            for _ in range(len(queue)):  # Process each cell in the current layer\r\n                row, col = queue.popleft()  # Get the next cell freom the queue\r\n\r\n                # Check if the cell is in bounds, not water (-1), and not visited    \r\n                if (0 <= row < rows and\r\n                    0 <= col < cols and\r\n                    grid[row][col] != -1 and\r\n                        (row, col) not in visited):\r\n\r\n                    grid[row][col] = distance  # Set the current distance in the grid\r\n                    visited.add((row, col))  # Mark the cell as visited\r\n\r\n                    for i, j in directions:\r\n                        queue.append((row + i, col + j))  # Add the cell to the queue\r\n                    \r\n            distance += 1  # Increment distance for the next layer\r\n\r\n        return grid", "testcase": "print(Solution().islandsAndTreasure([[0, -1], [2147483647, 2147483647]]), [[0, -1], [1, 2]])\r\nprint(Solution().islandsAndTreasure([[2147483647, 2147483647, 2147483647], [2147483647, -1, 2147483647], [0, 2147483647, 2147483647]]), [[2, 3, 4], [1, -1, 3], [0, 1, 2]])\r\nprint(Solution().islandsAndTreasure([[2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647]]), [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]])", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-10-01T20:06:08.607Z", "updated_at": "2025-01-30T19:45:15.355Z"}}, {"model": "python_problems.solution", "pk": 166, "fields": {"problem": 93, "language": 2, "owner": 3, "solution": "class Solution {\r\n  /**\r\n   * dfs, recursion\r\n   * O(n4), O(n2)  - O(n4) = O(n2)2 - may vistit the same land more than once\r\n   * @param {number[][]} grid\r\n   */\r\n  islandsAndTreasure(grid) {\r\n    const rows = grid.length;  // Get the number of rows\r\n    const cols = grid[0].length;  // Get the number of columns\r\n\r\n    const dfs = (row, col, distance) => {\r\n      grid[row][col] = distance;  // Set the distance for the current cell\r\n      const directions = [[0, 1], [1, 0], [-1, 0], [0, -1]];  // Define possible directions\r\n\r\n      for (const [di, dj] of directions) {\r\n        const i = row + di;  // Calculate the new row\r\n        const j = col + dj;  // Calculate the new column\r\n\r\n        if (\r\n          i < rows &&  // Ensure row is within bounds\r\n          j < cols &&  // Ensure column is within bounds\r\n          i >= 0 &&  // Ensure row is not negative\r\n          j >= 0 &&  // Ensure column is not negative\r\n          grid[i][j] != 0 &&  // Skip water cells\r\n          grid[i][j] != -1 &&  // Skip visited cells\r\n          grid[i][j] > distance + 1  // Ensure current distance is valid\r\n        ) {\r\n          dfs(i, j, distance + 1);  // Perform DFS on the next cell\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let row = 0; row < rows; row++) {  // Iterate through each row\r\n      for (let col = 0; col < cols; col++) {  // Iterate through each column\r\n        if (grid[row][col] === 0) {  // If the cell is water, start DFS\r\n          dfs(row, col, 0);  // Start DFS with distance 0\r\n        }\r\n      }\r\n    }\r\n    return grid;  // Return the modified grid\r\n  }\r\n}\r\n\r\n\r\nclass Solution {\r\n  /**\r\n   * bfs, iteration, queue\r\n   * O(n2), O(n2)\r\n   * @param {number[][]} grid\r\n   */\r\n  islandsAndTreasure(grid) {\r\n    const rows = grid.length;  // Get the number of rows\r\n    const cols = grid[0].length;  // Get the number of columns\r\n    const queue = [];  // Initialize an empty queue for BFS\r\n    const visitedLand = new Set();  // Set to keep track of visited cells\r\n\r\n    const bfs = (row, col) => {\r\n      const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];  // Define 4 possible directions (right, down, left, up)\r\n\r\n      for (const [di, dj] of directions) {  // Iterate over each direction\r\n        const i = row + di;  // Calculate new row\r\n        const j = col + dj;  // Calculate new column\r\n\r\n        if (\r\n          i < rows &&  // Ensure row is within bounds\r\n          j < cols &&  // Ensure column is within bounds\r\n          i >= 0 &&  // Ensure row is not negative\r\n          j >= 0 &&  // Ensure column is not negative\r\n          grid[i][j] != -1 &&  // Skip if the cell is water or already processed (-1)\r\n          !visitedLand.has(`${i},${j}`)  // Skip if the cell has already been visited\r\n        ) {\r\n          queue.push([i, j]);  // Add valid neighboring cells to the queue\r\n          visitedLand.add(`${i},${j}`);  // Mark as visited immediately when enqueued\r\n        }\r\n      }\r\n    };\r\n\r\n    for (let row = 0; row < rows; row++) {  // Iterate through each row\r\n      for (let col = 0; col < cols; col++) {  // Iterate through each column\r\n        if (grid[row][col] === 0) {  // If the cell is land (0)\r\n          queue.push([row, col]);  // Add the land cell to the queue\r\n          visitedLand.add(`${row},${col}`);  // Mark it as visited when added to the queue\r\n        }\r\n      }\r\n    }\r\n\r\n    let distance = 0;  // Initialize distance from the treasure\r\n\r\n    while (queue.length !== 0) {  // Continue while there are cells in the queue\r\n      let queueLength = queue.length;  // Get the number of cells in the current layer\r\n\r\n      for (let index = 0; index < queueLength; index++) {  // Iterate over all cells in the current queue\r\n        const [row, col] = queue.shift();  // Dequeue the next cell\r\n        grid[row][col] = distance;  // Set the distance in the grid\r\n        bfs(row, col);  // Explore the neighboring cells\r\n      }\r\n      distance++;  // Increment the distance for the next layer of cells\r\n    }\r\n\r\n    return grid;  // Return the modified grid\r\n  }\r\n}", "testcase": "console.log(new Solution().islandsAndTreasure([[0, -1], [2147483647, 2147483647]]), [[0, -1], [1, 2]])\r\nconsole.log(new Solution().islandsAndTreasure([[2147483647, 2147483647, 2147483647], [2147483647, -1, 2147483647], [0, 2147483647, 2147483647]]), [[2, 3, 4], [1, -1, 3], [0, 1, 2]])\r\nconsole.log(new Solution().islandsAndTreasure([[2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647]]), [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]])", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-10-01T20:06:41.555Z", "updated_at": "2024-10-02T12:15:59.657Z"}}, {"model": "python_problems.solution", "pk": 167, "fields": {"problem": 94, "language": 1, "owner": 3, "solution": "from collections import deque\r\n\r\nclass Solution:\r\n    def orangesRotting(self, grid: list[list[int]]) -> int:\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        queue = deque()\r\n        visited_cell = set()\r\n        fresh_orange = set()\r\n\r\n        def bfs(row, col):\r\n            directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Define the four possible directions (right, down, left, up)\r\n            \r\n            for di, dj in directions:  # Explore each direction\r\n                i = row + di\r\n                j = col + dj\r\n\r\n                if (0 <= i < rows and  # Check if within row bounds\r\n                    0 <= j < cols and  # Check if within column bounds\r\n                    (i, j) not in visited_cell and  # Ensure the cell has not been visited\r\n                    grid[i][j] == 1  # Ensure it's a fresh orange\r\n                ):\r\n                    queue.append((i, j))  # Add fresh orange to the queue to rot\r\n                    visited_cell.add((i, j))  # Mark it as visited\r\n                    fresh_orange.discard((i, j))  # Remove it from the fresh oranges set\r\n\r\n        # Initialize BFS with all rotting oranges and record fresh oranges\r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if grid[row][col] == 2:  # Rotting orange\r\n                    queue.append((row, col))  # Add to the queue\r\n                    visited_cell.add((row, col))  # Mark it as visited\r\n                elif grid[row][col] == 1:  # Fresh orange\r\n                    fresh_orange.add((row, col))  # Add to the fresh orange set\r\n    \r\n        if not fresh_orange:\r\n            return 0\r\n\r\n        counter = -1  # Initialize counter for time\r\n\r\n        # BFS to rot all fresh oranges\r\n        while queue:\r\n            counter += 1  # Increment time for each level/layer of BFS (each minute)\r\n\r\n            for _ in range(len(queue)):\r\n                row, col = queue.popleft()  # Process the current rotten orange\r\n                bfs(row, col)  # Try to rot neighboring fresh oranges\r\n\r\n        # If there are still fresh oranges left, return -1, otherwise return the time taken\r\n        return -1 if fresh_orange else counter", "testcase": "(Solution().orangesRotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]]), 4)\r\n(Solution().orangesRotting([[2, 1, 1], [0, 1, 1], [1, 0, 1]]), -1)\r\n(Solution().orangesRotting([[0, 2]]), 0)\r\n(Solution().orangesRotting([[0]]), 0)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-10-02T15:00:21.549Z", "updated_at": "2024-10-02T15:01:35.706Z"}}, {"model": "python_problems.solution", "pk": 168, "fields": {"problem": 94, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar orangesRotting = function (grid) {\r\n  const rows = grid.length;\r\n  const cols = grid[0].length;\r\n  const queue = [];\r\n  const visitedCells = new Set();\r\n  const freshOranges = new Set();\r\n\r\n  // BFS to process adjacent cells\r\n  const bfs = (row, col) => {\r\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];  // Right, down, left, up\r\n\r\n    for (const [di, dj] of directions) {\r\n      const i = row + di;\r\n      const j = col + dj;\r\n\r\n      if (\r\n        i < rows &&   // Check row bounds\r\n        j < cols &&   // Check column bounds\r\n        i >= 0 && \r\n        j >= 0 &&\r\n        !visitedCells.has(`${i},${j}`) &&  // Cell should not have been visited\r\n        grid[i][j] === 1  // Must be a fresh orange\r\n      ) {\r\n        queue.push([i, j]);  // Add fresh orange to the queue\r\n        visitedCells.add(`${i},${j}`);  // Mark as visited\r\n        freshOranges.delete(`${i},${j}`);  // Remove from fresh oranges set\r\n      }\r\n    }\r\n  };\r\n\r\n  // Iterate over the grid to initialize the queue and fresh oranges set\r\n  for (let row = 0; row < rows; row++) {\r\n    for (let col = 0; col < cols; col++) {\r\n      if (grid[row][col] === 2) {  // Rotten orange\r\n        queue.push([row, col]);  // Add to queue for BFS\r\n        visitedCells.add(`${row},${col}`);  // Mark as visited\r\n      } else if (grid[row][col] === 1) {  // Fresh orange\r\n        freshOranges.add(`${row},${col}`);  // Add to the fresh oranges set\r\n      }\r\n    }\r\n  }\r\n\r\n  // If there are no fresh oranges, return 0\r\n  if (freshOranges.size === 0) {\r\n    return 0;\r\n  }\r\n\r\n  let counter = -1;  // Initialize counter for time\r\n\r\n  // Perform BFS\r\n  while (queue.length !== 0) {\r\n    counter++;  // increment the time\r\n    const queueLength = queue.length;\r\n\r\n    for (let index = 0; index < queueLength; index++) {\r\n      const [row, col] = queue.shift();  // Dequeue rotten orange\r\n      bfs(row, col);  // Rot neighboring fresh oranges\r\n    }\r\n\r\n  }\r\n  \r\n  // If there are still fresh oranges, return -1. Otherwise, return the time counter.\r\n  return freshOranges.size === 0 ? counter : -1;\r\n}", "testcase": "console.log(orangesRotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]]), 4)\r\nconsole.log(orangesRotting([[2, 1, 1], [0, 1, 1], [1, 0, 1]]), -1)\r\nconsole.log(orangesRotting([[0, 2]]), 0)\r\nconsole.log(orangesRotting([[0]]), 0)", "time_complexity": 3, "space_complexity": 3, "created_at": "2024-10-02T15:00:50.056Z", "updated_at": "2024-10-02T15:00:50.075Z"}}, {"model": "python_problems.solution", "pk": 169, "fields": {"problem": 95, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\n# Define 3 nodes\r\nnode2 = ListNode(2)\r\nnode2.next\r\nnode1 = ListNode(1, node2)\r\nnode1.next\r\nnode0 = ListNode(0, node1)\r\nnode0.next\r\nnode0.next.next\r\n\r\n# original Linked List\r\n# Node0(0, Node1) => Node1(1, Node2) => Node2(2, None) => None\r\n\r\n# reversed Linked List\r\n# None <= Node0(0, None) <= Node1(1, Node0) <= Node2(2, Node1)\r\n\r\n# previous   current            next\r\n# None <= Node0(0, None) <= Node1(1, Node2)\r\n\r\n\r\n# O(n), O(1)\r\n# Iteration, two pointers\r\nclass Solution:\r\n    def reverseList(self, head: ListNode) -> ListNode:\r\n        node = head  # assign head to node\r\n        previous = None\r\n\r\n        while node:\r\n            next_node = node.next  # save next node pointer\r\n            node.next = previous  # reverse pointer\r\n            \r\n            previous = node  # shift pointer\r\n            node = next_node  # shift pointer\r\n        \r\n        return previous\r\n\r\nSolution().reverseList(node0)", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-11T22:45:14.068Z", "updated_at": "2024-11-29T22:38:14.480Z"}}, {"model": "python_problems.solution", "pk": 170, "fields": {"problem": 95, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar reverseList = function (head) {\r\n  let currenNode = head;\r\n  let previousNode = null;\r\n\r\n  while (currenNode) {\r\n    const nextNode = currenNode.next;\r\n    currenNode.next = previousNode;\r\n    previousNode = currenNode;\r\n    currenNode = nextNode;\r\n  }\r\n\r\n  return previousNode\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-12T00:31:43.526Z", "updated_at": "2024-11-12T00:31:43.544Z"}}, {"model": "python_problems.solution", "pk": 171, "fields": {"problem": 96, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack\r\n# monotonically increasing stack\r\nclass Solution:\r\n    def largestRectangleArea(self, heights: list[int]) -> int:\r\n        stack = []  # [(index, height), ]\r\n        max_area = 0\r\n\r\n        for index, height in enumerate(heights):\r\n            width = 0\r\n            while stack and height < stack[-1][1]:\r\n                width = index - stack[-1][0]\r\n                max_area = max(max_area, width * stack[-1][1])\r\n                stack.pop()\r\n\r\n            stack.append((index - width, height))  # width: extend the width (index) by width of popped heights\r\n            \r\n        while stack:\r\n            width = len(heights) - stack[-1][0]\r\n            max_area = max(max_area, width * stack[-1][1])\r\n            stack.pop()\r\n\r\n        return max_area\r\n\r\n\r\n# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def largestRectangleArea(self, heights: list[int]) -> int:\r\n        # Stack to keep track of indices and heights of rectangles\r\n        stack = []\r\n        # Variable to store the maximum area found so far\r\n        max_area = 0\r\n\r\n        for index, height in enumerate(heights):\r\n            # Store the starting index for the current rectangle\r\n            prev_index = index\r\n\r\n            # If the current height is less than the height of the rectangle\r\n            # on top of the stack, calculate the area of the rectangle\r\n            # with the height on top of the stack as the smallest height\r\n            while stack and height < stack[-1][1]:\r\n                prev_index, prev_height = stack.pop()\r\n                # Update max_area with the area of the rectangle\r\n                # formed by the popped height\r\n                max_area = max(max_area, prev_height * (index - prev_index))\r\n\r\n            # Push the current index and height onto the stack\r\n            stack.append((prev_index, height))\r\n        \r\n        # Process any remaining rectangles in the stack\r\n        for index, height in stack:\r\n            # Calculate the area for rectangles extending to the end of the array\r\n            max_area = max(max_area, height * (len(heights) - index))\r\n        \r\n        # Return the largest rectangle area found\r\n        return max_area\r\n\r\n\r\n# O(n2), O(1)\r\n# brute force\r\nclass Solution:\r\n    def largestRectangleArea(self, heights: list[int]) -> int:\r\n        max_area = 0\r\n\r\n        for left in range(len(heights)):\r\n            min_height = heights[left]\r\n            \r\n            for right in range(left, len(heights)):\r\n                min_height = min(min_height, heights[right])\r\n                current_area = min_height * (right - left + 1)\r\n                max_area = max(max_area, current_area)\r\n        \r\n        return max_area", "testcase": "print(Solution().largestRectangleArea([2, 1, 5, 6, 2, 3]), 10)\r\nprint(Solution().largestRectangleArea([2, 4]), 4)\r\nprint(Solution().largestRectangleArea([2, 1, 2]), 3)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-20T22:28:26.419Z", "updated_at": "2025-02-14T22:02:59.890Z"}}, {"model": "python_problems.solution", "pk": 172, "fields": {"problem": 96, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} heights - An array representing the heights of histogram bars.\r\n * @return {number} - The largest rectangle area that can be formed.\r\n */\r\nvar largestRectangleArea = function (heights) {\r\n  const stack = [];  // Stack to store [index, height] pairs.\r\n  let maxArea = 0;   // Variable to track the maximum rectangle area found.\r\n\r\n  // Iterate through the histogram bars.\r\n  for (let index = 0; index < heights.length; index++) {\r\n    const height = heights[index]; // Current bar height.\r\n    let startIndex = index;        // Initialize the start index of the rectangle.\r\n\r\n    // While the stack is not empty and the current height is less than\r\n    // the height of the bar at the top of the stack.\r\n    while (stack.length !== 0 && height < stack[stack.length - 1][1]) {\r\n      // Pop the top bar from the stack.\r\n      const [prevIndex, prevHeight] = stack.pop();\r\n      \r\n      // Calculate the area with the popped bar as the smallest height.\r\n      maxArea = Math.max(maxArea, prevHeight * (index - prevIndex));\r\n      \r\n      // Update the start index to the index of the popped bar\r\n      // as it defines the left boundary of the rectangle.\r\n      startIndex = prevIndex;\r\n    }\r\n\r\n    // Push the current bar onto the stack with the updated start index.\r\n    stack.push([startIndex, height]);\r\n  }\r\n\r\n  // Process the remaining bars in the stack.\r\n  for (const [index, height] of stack) {\r\n    // Calculate the area for rectangles extending to the end of the array.\r\n    maxArea = Math.max(maxArea, height * (heights.length - index));\r\n  }\r\n\r\n  // Return the largest rectangle area found.\r\n  return maxArea\r\n}", "testcase": "console.log(largestRectangleArea([2, 1, 5, 6, 2, 3]), 10)\r\nconsole.log(largestRectangleArea([2, 4]), 4)\r\nconsole.log(largestRectangleArea([2, 1, 2]), 3)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-20T23:28:20.199Z", "updated_at": "2024-11-20T23:28:20.216Z"}}, {"model": "python_problems.solution", "pk": 173, "fields": {"problem": 97, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def getConcatenation(self, numbers: list[int]) -> list[int]:\r\n        concat_array = [0] * len(numbers) * 2\r\n\r\n        for index, number in enumerate(numbers):\r\n            concat_array[index] = number\r\n            concat_array[index + len(numbers)] = number\r\n        \r\n        return concat_array", "testcase": "print(Solution().getConcatenation([1, 2, 1]), [1, 2, 1, 1, 2, 1])\r\nprint(Solution().getConcatenation([1, 3, 2, 1]), [1, 3, 2, 1, 1, 3, 2, 1])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-21T13:31:12.633Z", "updated_at": "2024-11-21T13:31:12.658Z"}}, {"model": "python_problems.solution", "pk": 174, "fields": {"problem": 97, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar getConcatenation = function (numbers) {\r\n  return [...numbers, ...numbers]\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar getConcatenation = function (numbers) {\r\n  return Array.from({ length: numbers.length * 2 }, (_, index) => numbers[index % numbers.length])\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar getConcatenation = function (numbers) {\r\n  const concatArray = Array(numbers.length * 2);\r\n  const numbersLength = numbers.length;\r\n\r\n  for (let index = 0; index < numbersLength; index++) {\r\n    concatArray[index] = numbers[index];\r\n    concatArray[index + numbers.length] = numbers[index];\r\n  }\r\n\r\n  return concatArray\r\n}", "testcase": "console.log(getConcatenation([1, 2, 1]), [1, 2, 1, 1, 2, 1])\r\nconsole.log(getConcatenation([1, 3, 2, 1]), [1, 3, 2, 1, 1, 3, 2, 1])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-21T13:53:40.777Z", "updated_at": "2024-11-21T13:53:40.797Z"}}, {"model": "python_problems.solution", "pk": 175, "fields": {"problem": 98, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\nclass Solution:\r\n    def validPalindrome(self, word: str) -> bool:\r\n        left = 0\r\n        right = len(word) - 1\r\n\r\n        while left < right:\r\n            if word[left] == word[right]:\r\n                left += 1\r\n                right -= 1\r\n            else:\r\n                # check if palindrome is valid after skipping one character\r\n                # from the left or from the right\r\n                word_skip_left = word[left + 1: right + 1]\r\n                word_skip_right = word[left:right]\r\n\r\n                return (word_skip_left == word_skip_left[::-1] or\r\n                        word_skip_right == word_skip_right[::-1])\r\n\r\n        return True\r\n\r\n\r\n# O(n), O(n)\r\n# recurrence\r\nclass Solution:\r\n    def validPalindrome(self, word: str, joker: bool = True) -> bool:\r\n        left = 0\r\n        right = len(word) - 1\r\n\r\n        while left < right:\r\n            if word[left] == word[right]:\r\n                left += 1\r\n                right -= 1\r\n            elif joker:\r\n                return (self.validPalindrome(word[left + 1: right + 1], joker=False) or\r\n                        self.validPalindrome(word[left: right], joker=False))\r\n            else:\r\n                return False\r\n\r\n        return True", "testcase": "print(Solution().validPalindrome(\"aba\"), True)\r\nprint(Solution().validPalindrome(\"abca\"), True)\r\nprint(Solution().validPalindrome(\"abc\"), False)\r\nprint(Solution().validPalindrome(\"eeccccbebaeeabebccceea\"), False)\r\nprint(Solution().validPalindrome(\"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\"), True)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-21T15:39:37.587Z", "updated_at": "2024-11-21T15:40:19.462Z"}}, {"model": "python_problems.solution", "pk": 176, "fields": {"problem": 98, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar validPalindrome = function (word) {\r\n  let left = 0;\r\n  let right = word.length - 1;\r\n\r\n  while (left < right) {\r\n    if (word[left] === word[right]) {\r\n      left++;\r\n      right--;\r\n    } else {\r\n      const wordSkipLeft = word.slice(left + 1, right + 1);\r\n      const wordSkipRight = word.slice(left, right);\r\n\r\n      return (\r\n        // wordSkipLeft === wordSkipLeft.split('').reverse().join('') ||\r\n        // wordSkipRight === wordSkipRight.split('').reverse().join('')\r\n        isPalindrome(wordSkipLeft) ||\r\n        isPalindrome(wordSkipRight)\r\n      )\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction isPalindrome(word) {\r\n  let left = 0;\r\n  let right = word.length - 1\r\n\r\n  while (left < right) {\r\n    if (word[left] != word[right]) return false\r\n    left++;\r\n    right--;\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n\r\n/**\r\n * @param {string} s\r\n * @return {boolean}\r\n */\r\nvar validPalindrome = function (word) {\r\n  let left = 0;\r\n  let right = word.length - 1;\r\n\r\n  while (left < right) {\r\n    if (word[left] === word[right]) {\r\n      left++;\r\n      right--;\r\n    } else {\r\n      const wordSkipLeft = word.slice(left + 1, right + 1);\r\n      const wordSkipRight = word.slice(left, right);\r\n\r\n      return (\r\n        wordSkipLeft === wordSkipLeft.split('').reverse().join('') ||\r\n        wordSkipRight === wordSkipRight.split('').reverse().join('')\r\n      )\r\n    }\r\n  }\r\n  return true\r\n}", "testcase": "console.log(validPalindrome(\"aba\"), true)\r\nconsole.log(validPalindrome(\"abca\"), true)\r\nconsole.log(validPalindrome(\"abc\"), false)\r\nconsole.log(validPalindrome(\"eeccccbebaeeabebccceea\"), false)\r\nconsole.log(validPalindrome(\"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga\"), true)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-21T15:51:47.568Z", "updated_at": "2024-11-21T15:51:47.589Z"}}, {"model": "python_problems.solution", "pk": 177, "fields": {"problem": 99, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def calPoints(self, operations: list[str]) -> int:\r\n        stack = []\r\n\r\n        for operation in operations:\r\n            if operation == \"C\":\r\n                stack.pop()\r\n            elif operation == \"D\":\r\n                stack.append(stack[-1] * 2)\r\n            elif operation == \"+\":\r\n                prev = stack.pop()\r\n                last = stack[-1] + prev\r\n                stack.extend([prev, last])\r\n            else:\r\n                stack.append(int(operation))\r\n    \r\n        return sum(stack)", "testcase": "print(Solution().calPoints([\"5\",\"2\",\"C\",\"D\",\"+\"]), 30)\r\nprint(Solution().calPoints([\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]), 27)\r\nprint(Solution().calPoints([\"1\",\"C\"]), 0)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-21T16:13:12.981Z", "updated_at": "2025-02-07T01:50:08.826Z"}}, {"model": "python_problems.solution", "pk": 178, "fields": {"problem": 99, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string[]} operations\r\n * @return {number}\r\n */\r\nvar calPoints = function (operations) {\r\n  const stack = [];\r\n\r\n  for (const operation of operations) {\r\n    if (operation === 'C') {\r\n      stack.pop()\r\n    } else if (operation === 'D') {\r\n      stack.push(stack[stack.length - 1] * 2)\r\n    } else if (operation === '+') {\r\n      const x = stack.pop();\r\n      const y = stack.pop();\r\n      stack.push(y);\r\n      stack.push(x);\r\n      stack.push(x + y);\r\n    } else {\r\n      stack.push(Number(operation));\r\n    }\r\n  }\r\n\r\n  return stack.reduce((total, current) => total + current, 0)\r\n}", "testcase": "console.log(calPoints([\"5\", \"2\", \"C\", \"D\", \"+\"]), 30)\r\nconsole.log(calPoints([\"5\", \"-2\", \"4\", \"C\", \"D\", \"9\", \"+\", \"+\"]), 27)\r\nconsole.log(calPoints([\"1\", \"C\"]), 0)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-21T16:20:34.838Z", "updated_at": "2024-11-21T16:20:34.856Z"}}, {"model": "python_problems.solution", "pk": 179, "fields": {"problem": 100, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\nclass Solution:\r\n    def replaceElements(self, numbers: list[int]) -> list[int]:\r\n        greatest_right = [-1] * len(numbers)\r\n\r\n        for index, number in enumerate(numbers[::-1][:-1], 1):\r\n            greatest_right[index] = max(number, greatest_right[index - 1])\r\n        \r\n        greatest_right.reverse()\r\n        \r\n        return greatest_right\r\n\r\n\r\n# O(n), O(n)\r\nclass Solution:\r\n    def replaceElements(self, numbers: list[int]) -> list[int]:\r\n        numbers.pop(0)\r\n        numbers.append(-1)\r\n\r\n        for index in range(len(numbers) - 1)[::-1]:\r\n            numbers[index] = max(numbers[index], numbers[index + 1])\r\n        \r\n        return numbers", "testcase": "print(Solution().replaceElements([17, 18, 5, 4, 6, 1]), [18, 6, 6, 6, 1, -1])\r\nprint(Solution().replaceElements([400]), [-1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-23T11:51:19.266Z", "updated_at": "2024-11-23T11:51:19.288Z"}}, {"model": "python_problems.solution", "pk": 180, "fields": {"problem": 100, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar replaceElements = function (numbers) {\r\n  const greatestRight = Array(numbers.length).fill(-1);\r\n  const numbersReversed = numbers.reverse()\r\n\r\n  for (let index = 0; index < numbers.length - 1; index++) {\r\n    greatestRight[index + 1] = Math.max(greatestRight[index], numbersReversed[index]);\r\n  }\r\n\r\n  return greatestRight.reverse()\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar replaceElements = function (numbers) {\r\n  const greatestRight = Array(numbers.length).fill(-1);\r\n\r\n  for (let index = numbers.length - 2; index >= 0; index--) {\r\n    greatestRight[index] = Math.max(greatestRight[index + 1], numbers[index + 1]);\r\n  }\r\n\r\n  return greatestRight\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar replaceElements = function (numbers) {\r\n  numbers.shift();\r\n  numbers.push(-1)\r\n\r\n  for (let index = numbers.length - 2; index >= 0; index--) {\r\n    numbers[index] = Math.max(numbers[index], numbers[index + 1]);\r\n  }\r\n\r\n  return numbers\r\n}", "testcase": "console.log(replaceElements([17, 18, 5, 4, 6, 1]), [18, 6, 6, 6, 1, -1])\r\nconsole.log(replaceElements([400]), [-1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-23T11:52:19.947Z", "updated_at": "2024-11-23T11:52:19.966Z"}}, {"model": "python_problems.solution", "pk": 181, "fields": {"problem": 101, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def minimumDifference(self, numbers: list[int], k: int) -> int:\r\n        numbers.sort()\r\n\r\n        return min(numbers[index + k - 1] - numbers[index]\r\n                   for index in range(len(numbers) - k + 1))", "testcase": "print(Solution().minimumDifference([90], 1), 0)\r\nprint(Solution().minimumDifference([9, 4, 1, 7], 2), 2)\r\nprint(Solution().minimumDifference([87063, 61094, 44530, 21297, 95857, 93551, 9918], 6), 74560)", "time_complexity": 5, "space_complexity": 2, "created_at": "2024-11-23T22:05:01.848Z", "updated_at": "2024-11-23T22:05:13.312Z"}}, {"model": "python_problems.solution", "pk": 182, "fields": {"problem": 101, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar minimumDifference = function (numbers, k) {\r\n  numbers.sort((a, b) => a - b);\r\n  let min_value = Infinity\r\n\r\n  for (let index = 0; index < numbers.length - k + 1; index++) {\r\n    const current_min = numbers[index + k - 1] - numbers[index]\r\n    \r\n    if (current_min < min_value) {\r\n      min_value = current_min;\r\n    }\r\n  }\r\n  \r\n  return min_value\r\n}", "testcase": "console.log(minimumDifference([90], 1), 0)\r\nconsole.log(minimumDifference([9, 4, 1, 7], 2), 2)\r\nconsole.log(minimumDifference([87063, 61094, 44530, 21297, 95857, 93551, 9918], 6), 74560)", "time_complexity": 5, "space_complexity": 2, "created_at": "2024-11-23T22:05:43.703Z", "updated_at": "2024-11-23T22:05:43.723Z"}}, {"model": "python_problems.solution", "pk": 183, "fields": {"problem": 102, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def mergeAlternately(self, word1: str, word2: str) -> str:\r\n        concat = \"\"\r\n\r\n        for index in range(max(len(word1), len(word2))):\r\n            letter = word1[index] if index < len(word1) else \"\"\r\n            concat += letter\r\n            letter = word2[index] if index < len(word2) else \"\"\r\n            concat += letter\r\n\r\n        return concat", "testcase": "print(Solution().mergeAlternately(\"abc\", \"pqr\"), \"apbqcr\")\r\nprint(Solution().mergeAlternately(\"ab\", \"pqrs\"), \"apbqrs\")\r\nprint(Solution().mergeAlternately(\"abcd\", \"pq\"), \"apbqcd\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-24T00:24:16.498Z", "updated_at": "2024-11-24T00:24:16.520Z"}}, {"model": "python_problems.solution", "pk": 184, "fields": {"problem": 102, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} word1\r\n * @param {string} word2\r\n * @return {string}\r\n */\r\nvar mergeAlternately = function (word1, word2) {\r\n  let merged = '';\r\n  \r\n  for (let index = 0; index < Math.max(word1.length, word2.length); index++) {\r\n    merged += word1[index] || '';\r\n    merged += word2[index] ?? '';\r\n  }\r\n\r\n  return merged\r\n}", "testcase": "console.log(mergeAlternately(\"abc\", \"pqr\"), \"apbqcr\")\r\nconsole.log(mergeAlternately(\"ab\", \"pqrs\"), \"apbqrs\")\r\nconsole.log(mergeAlternately(\"abcd\", \"pq\"), \"apbqcd\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-24T00:24:46.731Z", "updated_at": "2024-11-24T00:24:46.751Z"}}, {"model": "python_problems.solution", "pk": 185, "fields": {"problem": 103, "language": 1, "owner": 3, "solution": "from collections import deque\r\n\r\nclass MyStack:\r\n\r\n    def __init__(self):\r\n        self.queue = deque()\r\n\r\n    def push(self, x: int) -> None:\r\n        self.queue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        for _ in range(len(self.queue) - 1):\r\n            self.queue.append(self.queue.popleft())\r\n        return self.queue.popleft()\r\n\r\n    def top(self) -> int:\r\n        for _ in range(len(self.queue) - 1):\r\n            self.queue.append(self.queue.popleft())\r\n        popped = self.queue.popleft()\r\n        self.queue.append(popped)\r\n        return popped\r\n\r\n    def empty(self) -> bool:\r\n        return not self.queue\r\n\r\n\r\n# Your MyStack object will be instantiated and called as such:\r\n# obj = MyStack()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.top()\r\n# param_4 = obj.empty()", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-24T01:53:43.690Z", "updated_at": "2024-11-24T01:53:43.706Z"}}, {"model": "python_problems.solution", "pk": 186, "fields": {"problem": 103, "language": 2, "owner": 3, "solution": "var MyStack = function() {\r\n  this.queue = [];\r\n}\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nMyStack.prototype.push = function(x) {\r\n  this.queue.push(x);\r\n}\r\n\r\n/**\r\n* @return {number}\r\n*/\r\nMyStack.prototype.pop = function() {\r\n  for (let index = 0; index < this.queue.length - 1; index++) {\r\n      this.queue.push(this.queue.shift());\r\n  }\r\n  return this.queue.shift()\r\n}\r\n\r\n/**\r\n* @return {number}\r\n*/\r\nMyStack.prototype.top = function() {\r\n  for (let index = 0; index < this.queue.length - 1; index++) {\r\n      this.queue.push(this.queue.shift());\r\n  }\r\n  const popped = this.queue.shift();\r\n  this.queue.push(popped);\r\n  return popped\r\n}\r\n\r\n/**\r\n* @return {boolean}\r\n*/\r\nMyStack.prototype.empty = function() {\r\n  return this.queue.length === 0 ? true : false\r\n};\r\n\r\n/** \r\n* Your MyStack object will be instantiated and called as such:\r\n* var obj = new MyStack()\r\n* obj.push(x)\r\n* var param_2 = obj.pop()\r\n* var param_3 = obj.top()\r\n* var param_4 = obj.empty()\r\n*/", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-24T01:54:19.428Z", "updated_at": "2024-11-24T01:54:19.446Z"}}, {"model": "python_problems.solution", "pk": 187, "fields": {"problem": 104, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def isSubsequence(self, word1: str, word2: str) -> bool:\r\n        if not word1: \r\n            return True\r\n        \r\n        left = 0\r\n\r\n        for letter in word2:\r\n            if letter == word1[left]:\r\n                left += 1\r\n\r\n            if left == len(word1):\r\n                return True\r\n        \r\n        return False", "testcase": "print(Solution().isSubsequence(\"abc\", \"ahbgdc\"), True)\r\nprint(Solution().isSubsequence(\"axc\", \"ahbgdc\"), False)\r\nprint(Solution().isSubsequence(\"\", \"ahbgdc\"), True)\r\nprint(Solution().isSubsequence(\"\", \"\"), True)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-25T01:18:01.125Z", "updated_at": "2024-11-25T01:18:01.142Z"}}, {"model": "python_problems.solution", "pk": 188, "fields": {"problem": 104, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} s\r\n * @param {string} t\r\n * @return {boolean}\r\n */\r\nvar isSubsequence = function (word1, word2) {\r\n  if (word1.length === 0) return true\r\n\r\n  let left = 0;\r\n\r\n  for (let right = 0; right < word2.length; right++) {\r\n    if (word2[right] === word1[left]) {\r\n      left++;\r\n    }\r\n\r\n    if (left === word1.length) return true\r\n  }\r\n\r\n  return false\r\n}", "testcase": "console.log(isSubsequence(\"abc\", \"ahbgdc\"), true)\r\nconsole.log(isSubsequence(\"axc\", \"ahbgdc\"), false)\r\nconsole.log(isSubsequence(\"\", \"ahbgdc\"), true)\r\nconsole.log(isSubsequence(\"\", \"\"), true)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-25T01:18:36.818Z", "updated_at": "2024-11-25T01:18:36.835Z"}}, {"model": "python_problems.solution", "pk": 189, "fields": {"problem": 105, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def lengthOfLastWord(self, text: str) -> int:\r\n        return len(text.split()[-1])", "testcase": "print(Solution().lengthOfLastWord(\"Hello World\"), 5)\r\nprint(Solution().lengthOfLastWord(\"   fly me   to   the moon  \"), 4)\r\nprint(Solution().lengthOfLastWord(\"luffy is still joyboy\"), 6)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-25T17:06:17.288Z", "updated_at": "2024-11-25T17:06:17.309Z"}}, {"model": "python_problems.solution", "pk": 190, "fields": {"problem": 105, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar lengthOfLastWord = function (text) {\r\n  return text.trim().split(' ').reverse()[0].length\r\n}", "testcase": "console.log(lengthOfLastWord(\"Hello World\"), 5)\r\nconsole.log(lengthOfLastWord(\"   fly me   to   the moon  \"), 4)\r\nconsole.log(lengthOfLastWord(\"luffy is still joyboy\"), 6)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-25T17:06:43.451Z", "updated_at": "2024-11-25T17:06:43.474Z"}}, {"model": "python_problems.solution", "pk": 191, "fields": {"problem": 106, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# build-in function\r\nclass Solution:\r\n    def reverseString(self, s: list[str]) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify s in-place instead.\r\n        \"\"\"\r\n        s.reverse()\r\n\r\n\r\n# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def reverseString(self, s: list[str]) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify s in-place instead.\r\n        \"\"\"\r\n        \r\n        left = 0\r\n        right = len(s) - 1\r\n\r\n        while left < right:\r\n            s[left], s[right] = s[right], s[left]\r\n            left += 1\r\n            right -= 1\r\n\r\n\r\n# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def reverseString(self, s: list[str]) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify s in-place instead.\r\n        \"\"\"\r\n        \r\n        stack = []\r\n\r\n        for letter in s:\r\n            stack.append(letter)\r\n\r\n        for index in range(len(s)):\r\n            s[index] = stack.pop()\r\n\r\n\r\n# O(n), O(n)\r\n# recursion\r\nclass Solution:\r\n    def reverseString(self, s: list[str]) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify s in-place instead.\r\n        \"\"\"\r\n        \r\n        def local_reverse(left, right):\r\n            if left < right:\r\n                s[left], s[right] = s[right], s[left]\r\n                local_reverse(left + 1, right - 1)\r\n\r\n        local_reverse(0, len(s) - 1)", "testcase": "(Solution().reverseString([\"h\", \"e\", \"l\", \"l\", \"o\"]), [\"o\", \"l\", \"l\", \"e\", \"h\"])\r\n(Solution().reverseString([\"H\", \"a\", \"n\", \"n\", \"a\", \"h\"]), [\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-25T21:11:40.616Z", "updated_at": "2024-11-25T21:43:02.198Z"}}, {"model": "python_problems.solution", "pk": 192, "fields": {"problem": 106, "language": 2, "owner": 3, "solution": "/**\r\n * @param {character[]} s\r\n * @return {void} Do not return anything, modify s in-place instead.\r\n */\r\nvar reverseString = function (s) {\r\n  s = s.reverse();\r\n}/**\r\n * O(n), O(1)\r\n * build-in function\r\n * @param {character[]} s\r\n * @return {void} Do not return anything, modify s in-place instead.\r\n */\r\nvar reverseString = function (s) {\r\n  s = s.reverse();\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(1)\r\n * two pointers\r\n * @param {character[]} s\r\n * @return {void} Do not return anything, modify s in-place instead.\r\n */\r\nvar reverseString = function (s) {\r\n  let left = 0;\r\n  let right = s.length - 1;\r\n\r\n  while (left < right) {\r\n    [s[left], s[right]] = [s[right], s[left]];\r\n    left++;\r\n    right--;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * stack\r\n * @param {character[]} s\r\n * @return {void} Do not return anything, modify s in-place instead.\r\n */\r\nvar reverseString = function (s) {\r\n  const stack = [];\r\n\r\n  for (const letter of s) {\r\n    stack.push(letter);\r\n  }\r\n\r\n  let index = 0;\r\n\r\n  while (stack.length !== 0) {\r\n    s[index] = stack.pop();\r\n    index++;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * recursion\r\n * @param {character[]} s\r\n * @return {void} Do not return anything, modify s in-place instead.\r\n */\r\nvar reverseString = function (s) {\r\n  function localReverse(left, right) {\r\n    if (left < right) {\r\n        [s[left], s[right]] = [s[right], s[left]]\r\n        localReverse(left + 1, right - 1)\r\n    }\r\n  }\r\n  localReverse(0, s.length - 1)\r\n}\r\n\r\n\r\n/**\r\n * @param {character[]} s\r\n * @return {void} Do not return anything, modify s in-place instead.\r\n */\r\nvar reverseString = function (s) {\r\n  let left = 0;\r\n  let right = s.length - 1;\r\n\r\n  while (left < right) {\r\n    [s[left], s[right]] = [s[right], s[left]];\r\n    left++;\r\n    right--;\r\n  }\r\n}", "testcase": "console.log(reverseString([\"h\", \"e\", \"l\", \"l\", \"o\"]), [\"o\", \"l\", \"l\", \"e\", \"h\"])\r\nconsole.log(reverseString([\"H\", \"a\", \"n\", \"n\", \"a\", \"h\"]), [\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-25T21:12:18.699Z", "updated_at": "2024-11-25T21:43:20.569Z"}}, {"model": "python_problems.solution", "pk": 193, "fields": {"problem": 107, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def containsNearbyDuplicate(self, numbers: list[int], window_length: int) -> bool:\r\n        left = 0\r\n        window = set()\r\n\r\n        for right, number in enumerate(numbers):\r\n            if number in window:\r\n                return True\r\n            else:\r\n                window.add(number)\r\n\r\n            if right - left + 1 == window_length + 1:\r\n                window.remove(numbers[left])  # discard\r\n                left += 1\r\n\r\n        return False\r\n\r\n\r\n# O(n2), O(1)\r\n# brute force\r\nclass Solution:\r\n    def containsNearbyDuplicate(self, numbers: list[int], window_length: int) -> bool:\r\n        for index in range(len(numbers) - window_length):\r\n            subarray = numbers[index: index + window_length + 1]\r\n            if len(subarray) != len(set(subarray)):\r\n                return True\r\n            \r\n        return False", "testcase": "print(Solution().containsNearbyDuplicate([1, 2, 3, 1], 3), True)\r\nprint(Solution().containsNearbyDuplicate([1, 0, 1, 1], 1), True)\r\nprint(Solution().containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-25T22:46:02.317Z", "updated_at": "2025-02-02T16:34:43.740Z"}}, {"model": "python_problems.solution", "pk": 194, "fields": {"problem": 107, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * sliding window\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {boolean}\r\n */\r\nvar containsNearbyDuplicate = function (numbers, window_length) {\r\n  const window = new Set();\r\n  let left = 0;\r\n\r\n  for (let right = 0; right < numbers.length; right++) {\r\n    const number = numbers[right];\r\n\r\n    if (window.has(number)) return true\r\n    else window.add(number)\r\n\r\n    if (right - left + 1 !== window_length + 1) continue\r\n\r\n    window.delete(numbers[left]);\r\n    left++;\r\n  }\r\n\r\n  return false\r\n}", "testcase": "console.log(containsNearbyDuplicate([1, 2, 3, 1], 3), true)\r\nconsole.log(containsNearbyDuplicate([1, 0, 1, 1], 1), true)\r\nconsole.log(containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-25T22:46:46.149Z", "updated_at": "2024-11-25T22:46:46.166Z"}}, {"model": "python_problems.solution", "pk": 195, "fields": {"problem": 108, "language": 1, "owner": 3, "solution": "# O(1), O(n)\r\n# sliding window\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.stack_reversed = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.stack_reversed:\r\n            return self.stack_reversed.pop()\r\n\r\n        while self.stack:\r\n            self.stack_reversed.append(self.stack.pop())\r\n        \r\n        return self.stack_reversed.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if self.stack_reversed:\r\n            return self.stack_reversed[-1]\r\n\r\n        while self.stack:\r\n            self.stack_reversed.append(self.stack.pop())\r\n        \r\n        return self.stack_reversed[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return (not self.stack and \r\n                not self.stack_reversed)\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()", "testcase": "print(Solution().containsNearbyDuplicate([1, 2, 3, 1], 3), True)\r\nprint(Solution().containsNearbyDuplicate([1, 0, 1, 1], 1), True)\r\nprint(Solution().containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2), False)", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-11-26T00:37:43.338Z", "updated_at": "2024-11-26T00:37:43.358Z"}}, {"model": "python_problems.solution", "pk": 196, "fields": {"problem": 108, "language": 2, "owner": 3, "solution": "var MyQueue = function () {\r\n  this.stack = [];\r\n  this.stackReversed = [];\r\n}\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  if (this.stackReversed.length !== 0) {\r\n    return this.stackReversed.pop();\r\n  }\r\n\r\n  while (this.stack.length !== 0) {\r\n    this.stackReversed.push(this.stack.pop());\r\n  }\r\n\r\n  return this.stackReversed.pop()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  if (this.stackReversed.length !== 0) {\r\n    return this.stackReversed[this.stackReversed.length - 1]\r\n  }\r\n\r\n  while (this.stack.length !== 0) {\r\n    this.stackReversed.push(this.stack.pop());\r\n  }\r\n\r\n  return this.stackReversed[this.stackReversed.length - 1]\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  if (this.stack.length === 0 &&\r\n    this.stackReversed.length === 0\r\n  ) return true\r\n  else return false\r\n};\r\n\r\n/** \r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */", "testcase": "console.log(containsNearbyDuplicate([1, 2, 3, 1], 3), true)\r\nconsole.log(containsNearbyDuplicate([1, 0, 1, 1], 1), true)\r\nconsole.log(containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2), false)", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-11-26T00:51:18.907Z", "updated_at": "2024-11-26T00:51:18.926Z"}}, {"model": "python_problems.solution", "pk": 197, "fields": {"problem": 109, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def longestCommonPrefix(self, words: list[str]) -> str:\r\n        prefix = words[0]\r\n\r\n        for word in words[1:]:\r\n            for index, letter in enumerate(prefix):\r\n                if (index < len(word) and\r\n                        letter == word[index]):\r\n                    continue\r\n                else:\r\n                    prefix = prefix[:index]\r\n                    break\r\n\r\n        return prefix\r\n\r\n\r\nclass Solution:\r\n    def longestCommonPrefix(self, words: list[str]) -> str:\r\n        prefix = words[0]\r\n\r\n        for word in words[1:]:\r\n            for index, letter in enumerate(prefix):\r\n                if (index == len(word) or\r\n                        letter != word[index]):\r\n                    prefix = prefix[:index]\r\n                    break\r\n\r\n        return prefix\r\n\r\n\r\nclass Solution:\r\n    def longestCommonPrefix(self, words: list[str]) -> str:\r\n        prefix = \"\"\r\n\r\n        for index, letter in enumerate(words[0]):\r\n            for word in words:\r\n                if (index == len(word) or\r\n                        letter != word[index]):\r\n                    return prefix\r\n            \r\n            prefix += letter", "testcase": "print(Solution().longestCommonPrefix([\"flower\", \"flow\", \"flight\"]), \"fl\")\r\nprint(Solution().longestCommonPrefix([\"dog\", \"racecar\", \"car\"]), \"\")", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-11-27T01:18:54.220Z", "updated_at": "2024-11-27T01:25:02.560Z"}}, {"model": "python_problems.solution", "pk": 198, "fields": {"problem": 109, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string[]} words\r\n * @return {string}\r\n */\r\nvar longestCommonPrefix = function (words) {\r\n  let prefix = words[0];\r\n\r\n  for (const word of words.slice(1,)) {\r\n    for (let index = 0; index < prefix.length; index++) {\r\n      if (prefix[index] !== word[index]) {\r\n        prefix = prefix.slice(0, index)\r\n        break\r\n      }\r\n    }\r\n  }\r\n  return prefix\r\n}", "testcase": "console.log(longestCommonPrefix([\"flower\", \"flow\", \"flight\"]), \"fl\")\r\nconsole.log(longestCommonPrefix([\"dog\", \"racecar\", \"car\"]), \"\")", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-11-27T01:19:38.007Z", "updated_at": "2024-11-27T01:19:38.027Z"}}, {"model": "python_problems.solution", "pk": 199, "fields": {"problem": 110, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# in-place method, start from the end of the list\r\nclass Solution:\r\n    def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify nums1 in-place instead.\r\n        \"\"\"\r\n        m -= 1\r\n        n -= 1\r\n        \r\n        for index in reversed(range(m + n + 2)):\r\n            # if all nums from nums2 are used, all nums from nums2 are already in the correct place\r\n            if n == -1:\r\n                return nums1\r\n            \r\n            # if all nums from nums1 are used, the rest of the nums from nums2 need to \r\n            # replace the nums in nums1 from the start\r\n            if m == -1:\r\n                break\r\n            \r\n            if nums1[m] > nums2[n]:\r\n                nums1[index] = nums1[m]\r\n                m -= 1\r\n            else:\r\n                nums1[index] = nums2[n]\r\n                n -= 1\r\n            \r\n        # reaplacing nums1 with nums2 from the start\r\n        if n != -1:\r\n            for index in range(n + 1):\r\n                nums1[index] = nums2[index]\r\n\r\n        return nums1\r\n\r\n\r\n# O(n), O(n)\r\n# temp list, start from the beginning of the list\r\nclass Solution:\r\n    def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify nums1 in-place instead.\r\n        \"\"\"\r\n        l1 = 0\r\n        l2 = 0\r\n        index = 0\r\n        # sum_numbers = [0] * (m + n)\r\n        sum_numbers = []\r\n\r\n        while (l1 < m and l2 < n):\r\n            if nums1[l1] < nums2[l2]:\r\n                # sum_numbers[index] = nums1[l1]\r\n                sum_numbers.append(nums1[l1])\r\n                l1 += 1\r\n            else:\r\n                # sum_numbers[index] = nums2[l2]\r\n                sum_numbers.append(nums2[l2])\r\n                l2 += 1\r\n\r\n            index += 1\r\n\r\n        if l2 != n:\r\n            sum_numbers.extend(nums2[l2:])\r\n        elif l1 != m:\r\n            sum_numbers.extend(nums1[l1: m])\r\n\r\n        for index in range(len(nums1)):\r\n            nums1[index] = sum_numbers[index]\r\n\r\n        return sum_numbers\r\n\r\n\r\n# O(n), O(1)\r\n# in-place method, deque, start from the beginning of the list\r\nfrom collections import deque\r\n\r\nclass Solution:\r\n    def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify nums1 in-place instead.\r\n        \"\"\"\r\n        if not nums2:\r\n            return\r\n\r\n        l2 = 0\r\n        index = 0\r\n        temp = deque()\r\n\r\n        for index in range(m + n):\r\n            if temp:\r\n                if index < m:\r\n                    temp.append(nums1[index])\r\n\r\n                if l2 < n and temp[0] < nums2[l2]:\r\n                    nums1[index] = temp.popleft()\r\n                elif l2 == n:\r\n                    nums1[index] = temp.popleft()\r\n                else:\r\n                    nums1[index] = nums2[l2]\r\n                    l2 += 1\r\n            else:\r\n                if (index >= m and nums1[index] == 0):\r\n                    nums1[index] = nums2[l2]\r\n                    l2 += 1\r\n                elif nums1[index] > nums2[l2]:\r\n                    temp.append(nums1[index])\r\n                    nums1[index] = nums2[l2]\r\n                    l2 += 1\r\n\r\n        return nums1", "testcase": "print(Solution().merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3), [1, 2, 2, 3, 5, 6])\r\nprint(Solution().merge([1], 1, [], 0), [1])\r\nprint(Solution().merge([0], 0, [1], 1), [1])\r\nprint(Solution().merge([2, 0], 1, [1], 1), [1, 2])\r\nprint(Solution().merge([-1, 0, 0, 3, 3, 3, 0, 0, 0], 6, [1, 2, 2], 3), [-1, 0, 0, 1, 2, 2, 3, 3, 3])\r\nprint(Solution().merge([4, 5, 6, 0, 0, 0], 3, [1, 2, 3], 3), [1, 2, 3, 4, 5, 6])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-27T16:33:08.121Z", "updated_at": "2024-11-27T20:15:16.318Z"}}, {"model": "python_problems.solution", "pk": 200, "fields": {"problem": 110, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums1\r\n * @param {number} m\r\n * @param {number[]} nums2\r\n * @param {number} n\r\n * @return {void} Do not return anything, modify nums1 in-place instead.\r\n */\r\nvar merge = function (nums1, m, nums2, n) {\r\n  m--;\r\n  n--;\r\n\r\n  for (let index = m + n + 1; index >= 0; index--) {\r\n    if (n === -1) return nums1\r\n\r\n    if (m === - 1) break\r\n\r\n    if (nums1[m] > nums2[n]) {\r\n      nums1[index] = nums1[m];\r\n      m--;\r\n    } else {\r\n      nums1[index] = nums2[n];\r\n      n--;\r\n    }\r\n  }\r\n\r\n  for (let index = 0; index <= n; index++) {\r\n    nums1[index] = nums2[index];\r\n  }\r\n\r\n  return nums1\r\n}", "testcase": "console.log(merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3), [1, 2, 2, 3, 5, 6])\r\nconsole.log(merge([1], 1, [], 0), [1])\r\nconsole.log(merge([0], 0, [1], 1), [1])\r\nconsole.log(merge([2, 0], 1, [1], 1), [1, 2])\r\nconsole.log(merge([-1, 0, 0, 3, 3, 3, 0, 0, 0], 6, [1, 2, 2], 3), [-1, 0, 0, 1, 2, 2, 3, 3, 3])\r\nconsole.log(merge([4, 5, 6, 0, 0, 0], 3, [1, 2, 3], 3), [1, 2, 3, 4, 5, 6])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-27T20:17:02.261Z", "updated_at": "2024-11-27T20:17:02.280Z"}}, {"model": "python_problems.solution", "pk": 201, "fields": {"problem": 111, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def numOfSubarrays(self, numbers: list[int], size: int, threshold: int) -> int:\r\n        left = 0\r\n        window = 0\r\n        counter = 0\r\n\r\n        for right, number in enumerate(numbers):\r\n            window += number\r\n\r\n            # check threshold\r\n            if right - left + 1 == size:  # if window is the right size\r\n                if window / size >= threshold:  # if average is greather equal than threshold\r\n                    counter += 1\r\n\r\n                # remove left\r\n                window -= numbers[left]\r\n                left += 1\r\n\r\n        return counter\r\n\r\n\r\n# O(n2), O(1)\r\n# brute force\r\nclass Solution:\r\n    def numOfSubarrays(self, numbers: list[int], size: int, threshold: int) -> int:\r\n            counter = 0\r\n\r\n            for index in range(len(numbers) - size + 1):\r\n                subarray = numbers[index: index + size]\r\n                \r\n                if sum(subarray) / size >= threshold:\r\n                    counter += 1\r\n            \r\n            return counter", "testcase": "print(Solution().numOfSubarrays([2, 2, 2, 2, 5, 5, 5, 8], 3, 4), 3)\r\nprint(Solution().numOfSubarrays([11, 13, 17, 23, 29, 31, 7, 5, 2, 3], 3, 5), 6)\r\nprint(Solution().numOfSubarrays([8246,1867,193,4539,2650,4721,2944,5777,8055,7502,4334,2137,3658,4156,4628,1139,7963,8035,6008,8427,1841,9169,1059,6158,9116,8052,7074,7866,584,666,192,8081,8273,2809,3017,7852,1869,3395,4649,5366,8834,9100,1643,9511,4136,3897,7193,2500,2721,8477,2887,8300,3922,579,4228,7983,4247,5362,5581,9270,8602,1944,240,6044,6036,1219,6901,2007,2123,9699,3388,390,9144,7697,5160,6442,7078,9758,8841,2064,4096,146,7362,3952,2346,4171,7598,1201,1860,9101,8979,8437,1989,5349,5148,9422,7217,1406,8414,3586,5935,7395,2257,7802,9449,3824,6874,3684,4252,3947,8985,1052,7295,2976,2045,2315,4887,307,8784,988,942,7960,747,1593,1112,7874], 1, 307), 122)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-27T23:44:34.091Z", "updated_at": "2025-02-02T16:33:32.864Z"}}, {"model": "python_problems.solution", "pk": 202, "fields": {"problem": 111, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} numbers\r\n * @param {number} size\r\n * @param {number} threshold\r\n * @return {number}\r\n */\r\nvar numOfSubarrays = function (numbers, size, threshold) {\r\n  let counter = 0;\r\n  let subarraySum = 0;\r\n\r\n  for (let index = 0; index < numbers.length - size + 1; index++) {\r\n    if (index === 0) {\r\n      subarraySum = numbers.slice(0, size).reduce((total, current) => total + current)\r\n    } else {\r\n      subarraySum += - numbers[index - 1] + numbers[index + size - 1]\r\n    }\r\n\r\n    if (subarraySum / size >= threshold) {\r\n      counter++;\r\n    }\r\n  }\r\n  \r\n  return counter\r\n}", "testcase": "console.log(numOfSubarrays([2, 2, 2, 2, 5, 5, 5, 8], 3, 4), 3)\r\nconsole.log(numOfSubarrays([11, 13, 17, 23, 29, 31, 7, 5, 2, 3], 3, 5), 6)\r\nconsole.log(numOfSubarrays([8246,1867,193,4539,2650,4721,2944,5777,8055,7502,4334,2137,3658,4156,4628,1139,7963,8035,6008,8427,1841,9169,1059,6158,9116,8052,7074,7866,584,666,192,8081,8273,2809,3017,7852,1869,3395,4649,5366,8834,9100,1643,9511,4136,3897,7193,2500,2721,8477,2887,8300,3922,579,4228,7983,4247,5362,5581,9270,8602,1944,240,6044,6036,1219,6901,2007,2123,9699,3388,390,9144,7697,5160,6442,7078,9758,8841,2064,4096,146,7362,3952,2346,4171,7598,1201,1860,9101,8979,8437,1989,5349,5148,9422,7217,1406,8414,3586,5935,7395,2257,7802,9449,3824,6874,3684,4252,3947,8985,1052,7295,2976,2045,2315,4887,307,8784,988,942,7960,747,1593,1112,7874], 1, 307), 122)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-27T23:45:50.888Z", "updated_at": "2024-11-27T23:45:50.910Z"}}, {"model": "python_problems.solution", "pk": 203, "fields": {"problem": 112, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def makeGood(self, word: str) -> str:\r\n        stack = []\r\n\r\n        for letter in word:\r\n            if (stack and  # Check if the stack is not empty\r\n                letter != stack[-1] and # and if the top of the stack differs the current letter\r\n                    letter == stack[-1].upper()):  # and both lowercase are the same\r\n                stack.pop()\r\n            else:\r\n                stack.append(letter)\r\n\r\n        return \"\".join(stack)", "testcase": "print(Solution().makeGood(\"leEeetcode\"), \"leetcode\")\r\nprint(Solution().makeGood(\"abBAcC\"), \"\")\r\nprint(Solution().makeGood(\"s\"), \"s\")\r\nprint(Solution().makeGood(\"Mc\"), \"Mc\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-28T20:25:07.822Z", "updated_at": "2025-02-07T03:14:01.744Z"}}, {"model": "python_problems.solution", "pk": 204, "fields": {"problem": 112, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} word astats\r\n * @return {string}\r\n */\r\nvar makeGood = function (word) {\r\n  const stack = []; // Initialize an empty stack to store characters.\r\n\r\n  // Iterate through each character in the input string.\r\n  for (let letter of word) {\r\n    if (\r\n      stack.length !== 0 &&  // stack not empty\r\n      letter !== stack[stack.length - 1] &&  // and if the top of the stack differs the current letter\r\n      letter.toLowerCase() === stack[stack.length - 1].toLowerCase()  // and both lowercase are the same\r\n     ) {\r\n      stack.pop(); // Remove the top character from the stack.\r\n    } else {\r\n      stack.push(letter); // Otherwise, add the current character to the stack.\r\n    }\r\n  }\r\n\r\n  // Return the resulting string by joining the stack.\r\n  return stack.join('');\r\n}\r\n\r\n\r\n/**\r\n * Adds a method to the `String` prototype to check if a string is entirely in lowercase.\r\n * @return {boolean} Returns true if the string is in lowercase, otherwise false.\r\n */\r\nString.prototype.isLowerCase = function () {\r\n  // Compare the string to its lowercase version.\r\n  return this === this.toLowerCase() ? true : false;\r\n}\r\n\r\n/**\r\n * Removes adjacent pairs of letters that are the same character but with differing cases\r\n * (e.g., 'aA' or 'Bb') from the input string, until no such pairs remain.\r\n * @param {string} word The input string to be processed.\r\n * @return {string} A new string with all problematic pairs removed.\r\n */\r\nString.prototype.isUpperCase = function () {\r\n  // Compare the string to its uppercase version.\r\n  return this === this.toUpperCase() ? true : false;\r\n}\r\n\r\n/**\r\n * @param {string} word astats\r\n * @return {string}\r\n */\r\nvar makeGood = function (word) {\r\n  const stack = []; // Initialize an empty stack to store characters.\r\n\r\n  // Iterate through each character in the input string.\r\n  for (let letter of word) {\r\n    // Check if the stack is not empty and if the top of the stack matches the current letter\r\n    // in a case-insensitive way, while being opposite in case sensitivity.\r\n    if (\r\n      stack.length !== 0 &&\r\n      letter.toLowerCase() === stack[stack.length - 1].toLowerCase() && // Same character ignoring case\r\n      (\r\n        (letter.isLowerCase() && stack[stack.length - 1].isUpperCase()) || // One is lowercase, the other is uppercase\r\n        (letter.isUpperCase() && stack[stack.length - 1].isLowerCase())\r\n      )\r\n    ) {\r\n      stack.pop(); // Remove the top character from the stack.\r\n    } else {\r\n      stack.push(letter); // Otherwise, add the current character to the stack.\r\n    }\r\n  }\r\n\r\n  // Return the resulting string by joining the stack.\r\n  return stack.join('');\r\n}\r\n\r\n\r\n\r\nfunction isLowerCase(letter) {\r\n  return letter === letter.toLowerCase() ? true : false\r\n}\r\n\r\nfunction isUpperCase(letter) {\r\n  return letter === letter.toUpperCase() ? true : false\r\n}\r\n\r\n/**\r\n * @param {string} word\r\n * @return {string}\r\n */\r\nvar makeGood = function (word) {\r\n  const stack = [];\r\n\r\n  for (let letter of word) {\r\n    // Check if the stack is not empty and if the top of the stack matches the current letter\r\n    // in a case-insensitive way, while being opposite in case sensitivity.\r\n    if (\r\n      stack.length !== 0 &&\r\n      letter.toLowerCase() === stack[stack.length - 1].toLowerCase() && // Same character ignoring case\r\n      (isLowerCase(letter) && isUpperCase(stack[stack.length - 1]) || // One is lowercase, the other is uppercase\r\n        isUpperCase(letter) && isLowerCase(stack[stack.length - 1])\r\n      )\r\n    ) {\r\n      stack.pop(); // Remove the top character from the stack.\r\n    } else {\r\n      stack.push(letter) // Otherwise, add the current character to the stack.\r\n    }\r\n  }\r\n  return stack.join('')\r\n}", "testcase": "console.log(makeGood(\"leEeetcode\"), \"leetcode\")\r\nconsole.log(makeGood(\"abBAcC\"), \"\")\r\nconsole.log(makeGood(\"s\"), \"s\")\r\nconsole.log(makeGood(\"Mc\"), \"MC\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-28T20:25:38.676Z", "updated_at": "2024-11-28T20:25:38.700Z"}}, {"model": "python_problems.solution", "pk": 205, "fields": {"problem": 113, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def searchInsert(self, numbers: list[int], target: int) -> int:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n            middle_number = numbers[middle]\r\n\r\n            if target == middle_number:\r\n                return middle\r\n            elif target < middle_number:\r\n                right = middle - 1\r\n            else:\r\n                left = middle + 1\r\n\r\n        return left", "testcase": "print(Solution().searchInsert([1, 3, 5, 6], 0), 0)\r\nprint(Solution().searchInsert([1, 3, 5, 6], 1), 0)\r\nprint(Solution().searchInsert([1, 3, 5, 6], 2), 1)\r\nprint(Solution().searchInsert([1, 3, 5, 6], 3), 1)\r\nprint(Solution().searchInsert([1, 3, 5, 6], 4), 2)\r\nprint(Solution().searchInsert([1, 3, 5, 6], 5), 2)\r\nprint(Solution().searchInsert([1, 3, 5, 6], 6), 3)\r\nprint(Solution().searchInsert([1, 3, 5, 6], 7), 4)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-11-28T21:56:34.801Z", "updated_at": "2024-11-28T21:56:34.821Z"}}, {"model": "python_problems.solution", "pk": 206, "fields": {"problem": 113, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar searchInsert = function (numbers, target) {\r\n  let left = 0;\r\n  let right = numbers.length - 1;\r\n\r\n  while (left <= right) {\r\n    const middle = (left + right) / 2 | 0  // div 2 operation\r\n    const middleNumber = numbers[middle];\r\n\r\n    if (target === middleNumber) {\r\n      return middle\r\n    } else if (target < middleNumber) {\r\n      right = middle - 1;\r\n    } else {\r\n      left = middle + 1;\r\n    }\r\n  }\r\n  return left\r\n}", "testcase": "console.log(searchInsert([1, 3, 5, 6], 0), 0)\r\nconsole.log(searchInsert([1, 3, 5, 6], 1), 0)\r\nconsole.log(searchInsert([1, 3, 5, 6], 2), 1)\r\nconsole.log(searchInsert([1, 3, 5, 6], 3), 1)\r\nconsole.log(searchInsert([1, 3, 5, 6], 4), 2)\r\nconsole.log(searchInsert([1, 3, 5, 6], 5), 2)\r\nconsole.log(searchInsert([1, 3, 5, 6], 6), 3)\r\nconsole.log(searchInsert([1, 3, 5, 6], 7), 4)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-11-28T21:57:46.577Z", "updated_at": "2024-11-28T21:57:46.596Z"}}, {"model": "python_problems.solution", "pk": 207, "fields": {"problem": 114, "language": 1, "owner": 3, "solution": "# O(n2), O(n)\r\nclass Solution:\r\n    def generate(self, rowIndex: int) -> list[int]:\r\n        triangle = [[1]]  # first row in Pascal's Triangle\r\n\r\n        for index1 in range(rowIndex - 1):\r\n            new_row = [0] * (index1 + 2)  # new row\r\n            new_row[0] = 1  # every row starts with `1`\r\n            row = triangle[-1]  # previous row\r\n\r\n            for index2 in range(index1):\r\n                new_row[index2 + 1] = sum(row[index2: index2 + 2])\r\n            \r\n            new_row[-1] = 1  # every row ends with `1`\r\n            triangle.append(new_row)  # push row to Pascal's Triangle\r\n\r\n        return triangle", "testcase": "print(Solution().generate(5), [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]])\r\nprint(Solution().generate(1), [[1]])", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-11-29T00:03:11.817Z", "updated_at": "2025-01-07T12:00:12.155Z"}}, {"model": "python_problems.solution", "pk": 208, "fields": {"problem": 114, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number} numRows\r\n * @return {number[][]}\r\n */\r\nvar generate = function (numRows) {\r\n  const triangle = [];\r\n\r\n  for (let index = 0; index < numRows; index++) {\r\n      if (index === 0) {\r\n          triangle.push([1]);\r\n      } else {\r\n          const row = [1];\r\n\r\n          for (let number = 0; number < index - 1; number++) {\r\n              const first = triangle[triangle.length - 1][number];\r\n              const second = triangle[triangle.length - 1][number + 1];\r\n              row.push(first + second);\r\n          }\r\n\r\n          row.push(1);\r\n          triangle.push(row);\r\n      }\r\n  }\r\n  return triangle\r\n}", "testcase": "console.log(generate(5), [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]])\r\nconsole.log(generate(1), [[1]])", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-11-29T00:04:01.968Z", "updated_at": "2024-11-29T00:04:01.986Z"}}, {"model": "python_problems.solution", "pk": 209, "fields": {"problem": 115, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def moveZeroes(self, nums: list[int]) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify nums in-place instead.\r\n        \"\"\"\r\n\r\n        left = 0\r\n\r\n        for right, number in enumerate(nums):\r\n            if number:\r\n                nums[left], nums[right] = number, nums[left]\r\n                left += 1\r\n\r\n        return nums\r\n\r\n\r\n\r\nclass Solution:\r\n    def moveZeroes(self, nums: list[int]) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify nums in-place instead.\r\n        \"\"\"\r\n\r\n        zero_counter = 0\r\n        left = 0\r\n\r\n        for right, number in enumerate(nums):\r\n            if number:\r\n                nums[left] = number\r\n                left += 1\r\n            else:\r\n                zero_counter += 1\r\n\r\n        for right in range(len(nums) - zero_counter, len(nums)):\r\n            nums[right] = 0\r\n\r\n        return nums", "testcase": "print(Solution().moveZeroes([0, 1, 0, 3, 12]), [1, 3, 12, 0, 0])\r\nprint(Solution().moveZeroes([0]), [0])\r\nprint(Solution().moveZeroes([1]), [1])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-29T01:46:45.571Z", "updated_at": "2024-11-29T01:46:45.589Z"}}, {"model": "python_problems.solution", "pk": 210, "fields": {"problem": 115, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} nums\r\n * @return {void} Do not return anything, modify nums in-place instead.\r\n */\r\nvar moveZeroes = function (nums) {\r\n  let zeroCounter = 0;\r\n  let left = 0;\r\n\r\n  for (let right = 0; right < nums.length; right++) {\r\n      const number = nums[right];\r\n\r\n      if (number === 0) {\r\n          zeroCounter++;\r\n      } else {\r\n          nums[left] = number;\r\n          left++;\r\n      }\r\n  }\r\n\r\n  for (let index = nums.length - zeroCounter; index < nums.length; index++) {\r\n      nums[index] = 0;\r\n  }\r\n\r\n  return nums\r\n}\r\n\r\n\r\n/**\r\n * @param {number[]} nums\r\n * @return {void} Do not return anything, modify nums in-place instead.\r\n */\r\nvar moveZeroes = function (nums) {\r\n  let left = 0;\r\n\r\n  for (let right = 0; right < nums.length; right++) {\r\n      const number = nums[right];\r\n\r\n      if (number !== 0) {\r\n        [nums[left], nums[right]] = [number, nums[left]];\r\n        left++;\r\n      } \r\n  }\r\n  // return nums\r\n}", "testcase": "console.log(moveZeroes([0, 1, 0, 3, 12]), [1, 3, 12, 0, 0])\r\nconsole.log(moveZeroes([0]), [0])\r\nconsole.log(moveZeroes([1]), [1])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-29T01:47:19.161Z", "updated_at": "2024-11-29T01:47:19.178Z"}}, {"model": "python_problems.solution", "pk": 211, "fields": {"problem": 116, "language": 1, "owner": 3, "solution": "# O(nlogn), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def maxFrequency(self, numbers: list[int], joker: int) -> int:\r\n        numbers.sort()\r\n        left = 0\r\n        longest = 0\r\n\r\n        for right, number in enumerate(numbers):\r\n            joker -= (right - left) * (number - numbers[right - 1])  # decrease joker wirdcard by sum needed to level current window to its maximum value\r\n            \r\n            while joker < 0:  # while joker exceeded\r\n                joker += (number - numbers[left])  # return joker value from left number\r\n                left += 1  # move left pointer\r\n                \r\n            longest = max(longest, right - left + 1)  # update longest frequency\r\n\r\n        return longest\r\n\r\n\r\n# O(nlogn), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def maxFrequency(self, numbers: list[int], k: int) -> int:\r\n        numbers.sort()\r\n        left = 0\r\n        total = 0\r\n        frequency = 1\r\n\r\n        for right, number in enumerate(numbers):\r\n            total += number  # Add the current number to the total sum of the window.\r\n\r\n            # Check if the current window is valid:\r\n            # `(number * (right - left + 1))` represents the total sum needed\r\n            # to make all elements in the window equal to `number`.\r\n            # If the required total exceeds the available increment `k`, shrink the window.\r\n            while (number * (right - left + 1) - total > k):\r\n                total -= numbers[left]  # Remove the element at the left pointer from the total sum.\r\n                left += 1  # Move the left pointer to the right, shrinking the window.\r\n        \r\n            frequency = max(frequency, right - left + 1)  # Update the maximum frequency found so far.\r\n\r\n        return frequency", "testcase": "print(Solution().maxFrequency([1, 2, 4], 5), 3)\r\nprint(Solution().maxFrequency([1, 4, 8, 13], 5), 2)\r\nprint(Solution().maxFrequency([3, 9, 6], 2), 1)\r\nprint(Solution().maxFrequency([9930, 9923, 9983, 9997, 9934, 9952, 9945, 9914, 9985, 9982, 9970, 9932, 9985, 9902, 9975, 9990, 9922, 9990, 9994, 9937, 9996, 9964, 9943, 9963, 9911, 9925, 9935, 9945, 9933, 9916, 9930, 9938, 10000, 9916, 9911, 9959, 9957, 9907, 9913, 9916, 9993, 9930, 9975, 9924, 9988, 9923, 9910, 9925, 9977, 9981, 9927, 9930, 9927, 9925, 9923, 9904, 9928, 9928, 9986, 9903, 9985, 9954, 9938, 9911, 9952, 9974, 9926, 9920, 9972, 9983, 9973, 9917, 9995, 9973, 9977, 9947, 9936, 9975, 9954, 9932, 9964, 9972, 9935, 9946, 9966], 3056), 73)", "time_complexity": 5, "space_complexity": 2, "created_at": "2024-11-29T13:32:40.474Z", "updated_at": "2025-02-02T18:08:18.661Z"}}, {"model": "python_problems.solution", "pk": 212, "fields": {"problem": 116, "language": 2, "owner": 3, "solution": "/**\r\n * O(nlogn), O(1)\r\n * sliding window\r\n * @param {number[]} numbers\r\n * @param {number} k total increments\r\n * @return {number}\r\n */\r\nvar maxFrequency = function (numbers, k) {\r\n  numbers.sort((a, b) => a - b);\r\n  let left = 0;\r\n  let total = 0;\r\n  let frequency = 1;\r\n\r\n  for (let right = 0; right < numbers.length; right++) {\r\n    const number = numbers[right];\r\n    total += number;  // Add the current number to the total sum of the window.\r\n\r\n    // Check if the current window is valid:\r\n    // `(number * (right - left + 1))` represents the total sum needed\r\n    // to make all elements in the window equal to `number`.\r\n    // If the required total exceeds the available increment `k`, shrink the window.\r\n    while (number * (right - left + 1) - total > k) {\r\n      total -= numbers[left];  // Remove the element at the left pointer from the total sum.\r\n      left++;  // Move the left pointer to the right, shrinking the window.\r\n    }\r\n\r\n    frequency =  Math.max(right - left + 1, frequency);  // Update the maximum frequency found so far.\r\n }\r\n\r\n return frequency\r\n}", "testcase": "console.log(maxFrequency([1, 2, 4], 5), 3)\r\nconsole.log(maxFrequency([1, 4, 8, 13], 5), 2)\r\nconsole.log(maxFrequency([3, 9, 6], 2), 1)\r\nconsole.log(maxFrequency([9930, 9923, 9983, 9997, 9934, 9952, 9945, 9914, 9985, 9982, 9970, 9932, 9985, 9902, 9975, 9990, 9922, 9990, 9994, 9937, 9996, 9964, 9943, 9963, 9911, 9925, 9935, 9945, 9933, 9916, 9930, 9938, 10000, 9916, 9911, 9959, 9957, 9907, 9913, 9916, 9993, 9930, 9975, 9924, 9988, 9923, 9910, 9925, 9977, 9981, 9927, 9930, 9927, 9925, 9923, 9904, 9928, 9928, 9986, 9903, 9985, 9954, 9938, 9911, 9952, 9974, 9926, 9920, 9972, 9983, 9973, 9917, 9995, 9973, 9977, 9947, 9936, 9975, 9954, 9932, 9964, 9972, 9935, 9946, 9966], 3056), 73)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-11-29T14:11:17.634Z", "updated_at": "2024-11-29T14:11:17.656Z"}}, {"model": "python_problems.solution", "pk": 213, "fields": {"problem": 117, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def removeStars(self, word: str) -> str:\r\n        stack = []\r\n\r\n        for letter in word:\r\n            if stack and letter == \"*\":\r\n                stack.pop()\r\n            else:\r\n                stack.append(letter)\r\n        return \"\".join(stack)", "testcase": "print(Solution().removeStars(\"leet**cod*e\"), \"lecoe\")\r\nprint(Solution().removeStars(\"erase*****\"), \"\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-29T14:50:37.981Z", "updated_at": "2025-02-07T04:30:12.794Z"}}, {"model": "python_problems.solution", "pk": 214, "fields": {"problem": 117, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} word\r\n * @return {string}\r\n */\r\nvar removeStars = function (word) {\r\n  const stack = [];\r\n\r\n  for (const letter of word) {\r\n    if (stack.length !== 0 && letter === '*') {\r\n      stack.pop();\r\n    } else {\r\n      stack.push(letter);\r\n    }\r\n  }\r\n  return stack.join('')\r\n}", "testcase": "console.log(removeStars(\"leet**cod*e\"), \"lecoe\")\r\nconsole.log(removeStars(\"erase*****\"), \"\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-11-29T14:51:01.923Z", "updated_at": "2024-11-29T14:51:01.942Z"}}, {"model": "python_problems.solution", "pk": 215, "fields": {"problem": 118, "language": 1, "owner": 3, "solution": "# The guess API is already defined for you.\r\n# @param num, your guess\r\n# @return -1 if num is higher than the picked number\r\n#          1 if num is lower than the picked number\r\n#          otherwise return 0\r\n# def guess(num: int) -> int:\r\n\r\n# O(logn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def guess(self, number):\r\n        if number == 6:\r\n            return 0\r\n        elif number < 6:\r\n            return 1\r\n        else:\r\n            return -1\r\n\r\n    def guessNumber(self, n: int) -> int:\r\n        left = 1\r\n        right = n\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n            current_guess = self.guess(middle)\r\n        \r\n            if current_guess == 0:\r\n                return middle\r\n            elif current_guess == 1:\r\n                left = middle + 1\r\n            else:\r\n                right = middle - 1", "testcase": "print(Solution().guessNumber(10), 6)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-11-29T16:24:03.903Z", "updated_at": "2024-11-29T16:24:04.574Z"}}, {"model": "python_problems.solution", "pk": 216, "fields": {"problem": 118, "language": 2, "owner": 3, "solution": "/** \r\n * Forward declaration of guess API.\r\n * @param {number} num   your guess\r\n * @return \t     -1 if num is higher than the picked number\r\n *\t\t\t      1 if num is lower than the picked number\r\n *               otherwise return 0\r\n * var guess = function(num) {}\r\n */\r\n\r\n/**\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar guessNumber = function (n) {\r\n  let left = 1;\r\n  let right = n;\r\n\r\n  while (left <= right) {\r\n      const middle = (left + right) / 2 | 0;  // === (left + right) div 2\r\n      currentGuess = guess(middle);\r\n\r\n      if (currentGuess === 0) {\r\n          return middle\r\n      } else if (currentGuess === 1) {\r\n          left = middle + 1;\r\n      } else {\r\n          right = middle - 1;\r\n      }\r\n  }\r\n}", "testcase": "console.log(guessNumber(10), 6)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-11-29T16:24:49.864Z", "updated_at": "2024-11-29T16:24:49.884Z"}}, {"model": "python_problems.solution", "pk": 217, "fields": {"problem": 119, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def removeElement(self, numbers: list[int], value: int) -> int:\r\n        left = 0\r\n\r\n        for number in numbers:\r\n            if number != value:\r\n                numbers[left] = number\r\n                left += 1\r\n                \r\n        return left", "testcase": "print(Solution().removeElement([3, 2, 2, 3], 3), [2, 2])\r\nprint(Solution().removeElement([0, 1, 2, 2, 3, 0, 4, 2], 2), [0, 1, 3, 4, 2])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-29T21:49:41.931Z", "updated_at": "2024-11-29T21:49:41.948Z"}}, {"model": "python_problems.solution", "pk": 218, "fields": {"problem": 119, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} numbers\r\n * @param {number} val\r\n * @return {number}\r\n */\r\nvar removeElement = function(numbers, value) {\r\n  let left = 0;\r\n\r\n  for (const number of numbers) {\r\n      if (number !== value) {\r\n          numbers[left] = number;\r\n          left++;\r\n      }\r\n  }\r\n  return left\r\n}", "testcase": "console.log(removeElement([3, 2, 2, 3], 3), [2, 2])\r\nconsole.log(removeElement([0, 1, 2, 2, 3, 0, 4, 2], 2), [0, 1, 3, 4, 2])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-29T21:50:15.261Z", "updated_at": "2024-11-29T21:50:15.279Z"}}, {"model": "python_problems.solution", "pk": 219, "fields": {"problem": 120, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\r\n        anchor = node = ListNode()\r\n\r\n        while list1 and list2:\r\n            if list1.val < list2.val:\r\n                node.next = list1\r\n                list1 = list1.next\r\n            else:\r\n                node.next = list2\r\n                list2 = list2.next\r\n            \r\n            node = node.next\r\n        \r\n        node.next = list1 or list2\r\n\r\n        return anchor.next\r\n\r\nnode_a2 = ListNode(4, None)\r\nnode_a1 = ListNode(2, node_a2)\r\nnode_a0 = ListNode(1, node_a1)\r\n\r\nnode_b2 = ListNode(4, None)\r\nnode_b1 = ListNode(3, node_b2)\r\nnode_b0 = ListNode(1, node_b1)\r\n\r\nSolution().mergeTwoLists(node_a0, node_b0)", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-29T23:49:43.206Z", "updated_at": "2024-11-29T23:49:43.226Z"}}, {"model": "python_problems.solution", "pk": 220, "fields": {"problem": 120, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n*/\r\nfunction ListNode(val, next) {\r\n  this.val = (val === undefined ? 0 : val)\r\n  this.next = (next === undefined ? null : next)\r\n}\r\n/**\r\n* @param {ListNode} list1\r\n* @param {ListNode} list2\r\n* @return {ListNode}\r\n*/\r\nvar mergeTwoLists = function (list1, list2) {\r\n  const anchor = new ListNode();\r\n  let node = anchor;\r\n\r\n  while (list1 !== null && list2 !== null) {\r\n      if (list1.val < list2.val) {\r\n          node.next = list1;\r\n          list1 = list1.next;\r\n      } else {\r\n          node.next = list2;\r\n          list2 = list2.next;\r\n      }\r\n      node = node.next;\r\n  }\r\n  node.next = list1 || list2;\r\n\r\n  return anchor.next\r\n}\r\n\r\nconst nodeA2 = new ListNode(4, null);\r\nconst nodeA1 = new ListNode(2, nodeA2);\r\nconst nodeA0 = new ListNode(1, nodeA1);\r\n\r\nconst nodeB2 = new ListNode(4, null);\r\nconst nodeB1 = new ListNode(3, nodeB2);\r\nconst nodeB0 = new ListNode(1, nodeB1);\r\n\r\nconsole.log(mergeTwoLists(nodeA0, nodeB0))", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-29T23:50:24.431Z", "updated_at": "2024-11-29T23:50:24.449Z"}}, {"model": "python_problems.solution", "pk": 221, "fields": {"problem": 121, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# Floyd's tortoise and hare\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def hasCycle(self, node: ListNode) -> bool:\r\n        slow = node\r\n        fast = node\r\n\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n            if slow == fast:\r\n                return True\r\n        \r\n        return False\r\n\r\n\r\n# O(n), O(n)\r\n# set for node store\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def hasCycle(self, node: ListNode) -> bool:\r\n        seen = set()\r\n\r\n        while node:\r\n            if node in seen:\r\n                return True\r\n            else:\r\n                seen.add(node)\r\n                node = node.next\r\n        \r\n        return False", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-30T00:50:29.599Z", "updated_at": "2024-11-30T00:50:29.621Z"}}, {"model": "python_problems.solution", "pk": 222, "fields": {"problem": 121, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n\r\n// O(n), O(1)\r\n// Floyd's tortoise and hare\r\nvar hasCycle = function (head) {\r\n  let slow = head;\r\n  let fast = head;\r\n\r\n  while (\r\n    fast != null &&\r\n    fast.next != null\r\n  ) {\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n\r\n    if (slow === fast) return true\r\n  }\r\n  return false\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * set for node store\r\n * @param {ListNode} head\r\n * @return {boolean}\r\n */\r\nvar hasCycle = function (head) {\r\n  const seen = new Set();\r\n\r\n  while (head !== null) {\r\n    if (seen.has(head)) {\r\n      return true\r\n    } else {\r\n      seen.add(head);\r\n      head = head.next;\r\n    }\r\n  }\r\n  return false\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-30T00:51:23.687Z", "updated_at": "2024-11-30T00:51:23.705Z"}}, {"model": "python_problems.solution", "pk": 223, "fields": {"problem": 122, "language": 1, "owner": 3, "solution": "# Find the middle of the list draft\r\n# [1, 2, 2L, 1 NoneP]\r\n# [1, 2, 3L, 2, 1P, None]\r\n\r\n\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\n# O(n), O(1)\r\n# linked list\r\nclass Solution:\r\n    def isPalindrome(self, head: ListNode) -> bool:\r\n        if not head or not head.next:\r\n            return True  # Single node or empty list is always a palindrome\r\n        \r\n        # Step 1: Find the middle of the list\r\n        slow = head  # slow pointer\r\n        fast = head  # fast pointer\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        \r\n        # Step 2: Reverse the second half of the list\r\n        previous = None\r\n\r\n        while slow:\r\n            next_node = slow.next\r\n            slow.next = previous\r\n            previous = slow\r\n            slow = next_node\r\n\r\n        # Step 3: Compare the two halves\r\n        left = head\r\n        right = previous\r\n        \r\n        while right:\r\n            if left.val != right.val:\r\n                return False\r\n            \r\n            left = left.next\r\n            right = right.next\r\n\r\n        return True\r\n\r\n# initiate [1, 2, 2, 1] linked list\r\nnode4 = ListNode(1)\r\nnode3 = ListNode(2, node4)\r\nnode2 = ListNode(2, node3)\r\nnode1 = ListNode(1, node2)\r\n\r\nprint(Solution().isPalindrome(node1), True)\r\n\r\n\r\n# O(n), O(n)\r\n# convert to list\r\nclass Solution:\r\n    def isPalindrome(self, head: ListNode) -> bool:\r\n        numbers = []\r\n\r\n        while head:\r\n            numbers.append(head.val)\r\n            head = head.next\r\n        \r\n        return numbers == numbers[::-1]", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-30T16:17:58.720Z", "updated_at": "2024-11-30T16:18:37.847Z"}}, {"model": "python_problems.solution", "pk": 224, "fields": {"problem": 122, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {boolean}\r\n */\r\nvar isPalindrome = function (head) {\r\n  // Find the middle of the list\r\n  let slow = head;\r\n  let fast = head;\r\n\r\n  while (fast && fast.next) {\r\n      slow = slow.next;\r\n      fast = fast.next.next;\r\n  }\r\n\r\n  // Reverse the second half of the list\r\n  previous = null\r\n\r\n  while (slow) {\r\n      nextNode = slow.next;\r\n      slow.next = previous;\r\n      previous = slow;\r\n      slow = nextNode;\r\n  }\r\n\r\n  // Compare the two halves\r\n  left = head;\r\n  right = previous;\r\n\r\n  while (right) {\r\n      if (left.val != right.val) {\r\n          return false\r\n      }\r\n\r\n      left = left.next;\r\n      right = right.next;\r\n  }\r\n\r\n  return true\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-11-30T16:31:13.835Z", "updated_at": "2024-11-30T16:31:13.855Z"}}, {"model": "python_problems.solution", "pk": 225, "fields": {"problem": 123, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\r\n        anchor = node = ListNode()\r\n        node.next = head\r\n\r\n        while node:\r\n            if node.next and node.next.val == val:\r\n                node.next = node.next.next\r\n            else:\r\n                node = node.next\r\n\r\n        return anchor.next\r\n\r\n\r\n# initiate [(0), 7, 7, 7, 7, (None)]\r\nnode4 = ListNode(7)\r\nnode3 = ListNode(7, node4)\r\nnode2 = ListNode(7, node3)\r\nnode1 = ListNode(7, node2)\r\n\r\nprint(Solution().removeElements(node1, 7), None)", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-01T15:01:49.257Z", "updated_at": "2024-12-01T15:01:49.278Z"}}, {"model": "python_problems.solution", "pk": 226, "fields": {"problem": 123, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} val\r\n * @return {ListNode}\r\n */\r\nvar removeElements = function (head, val) {\r\n  let anchor = new ListNode();\r\n  let node = anchor;\r\n  node.next = head;\r\n\r\n  while (node.next) {\r\n      if (node.next.val === val) {\r\n          node.next = node.next.next\r\n      } else {\r\n          node = node.next;\r\n      }\r\n  }\r\n\r\n  return anchor.next\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-01T15:02:15.568Z", "updated_at": "2024-12-01T15:02:15.586Z"}}, {"model": "python_problems.solution", "pk": 227, "fields": {"problem": 124, "language": 1, "owner": 3, "solution": "# O(n2), O(n)\r\n# build-in functions\r\nclass Solution:\r\n    def numUniqueEmails(self, emails: list[str]) -> int:\r\n        clean_emails = set()\r\n\r\n        for emial in emails:\r\n            name, domain = emial.split(\"@\")\r\n\r\n            # remove all after \"+\" in the name\r\n            clean_name = name.split(\"+\")[0]\r\n\r\n            # remove \".\" from the name\r\n            clean_name = clean_name.replace(\".\", \"\")\r\n            \r\n            clean_emails.add(clean_name + \"@\" + domain)\r\n\r\n        return len(clean_emails)\r\n\r\n\r\n# O(n2), O(n)\r\n# regex\r\nimport re\r\n\r\nclass Solution:\r\n    def numUniqueEmails(self, emails: list[str]) -> int:\r\n        clean_emails = set()\r\n\r\n        for emial in emails:\r\n            name, domain = emial.split(\"@\")\r\n\r\n            # remove \".\" from the name\r\n            clean_name = re.sub(r\"\\.\", \"\", name)\r\n\r\n            # remove all after \"+\" in the name\r\n            clean_name = re.search(r\"(\\w+)(\\+?)\", clean_name).group(1)\r\n\r\n            clean_emails.add(clean_name + \"@\" + domain)\r\n\r\n        return len(clean_emails)", "testcase": "print(Solution().numUniqueEmails([\"test.email+alex@leetcode.com\", \"test.e.mail+bob.cathy@leetcode.com\", \"testemail+david@lee.tcode.com\"]), 2)\r\nprint(Solution().numUniqueEmails([\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\"]), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-12-01T23:37:04.146Z", "updated_at": "2024-12-01T23:37:04.168Z"}}, {"model": "python_problems.solution", "pk": 228, "fields": {"problem": 124, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(n)\r\n * regex\r\n * @param {string[]} emails\r\n * @return {number}\r\n */\r\nvar numUniqueEmails = function (emails) {\r\n  const clean_emails = new Set();\r\n\r\n  for (const email of emails) {\r\n    let [name, domain] = email.split('@');\r\n\r\n    // remove \".\" from the name\r\n    name = name.replace(/\\./g, '');\r\n\r\n    // remove all after \"+\" in the name\r\n    name = name.match(/(\\w+)(\\+?)/)[1]\r\n\r\n    clean_emails.add(name + '@' + domain);\r\n  }\r\n\r\n  return clean_emails.size\r\n}", "testcase": "console.log(numUniqueEmails(['test.email+alex@leetcode.com', 'test.e.mail+bob.cathy@leetcode.com', 'testemail+david@lee.tcode.com']), 2)\r\nconsole.log(numUniqueEmails(['a@leetcode.com', 'b@leetcode.com', 'c@leetcode.com']), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2024-12-01T23:38:30.300Z", "updated_at": "2024-12-01T23:38:30.320Z"}}, {"model": "python_problems.solution", "pk": 229, "fields": {"problem": 125, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def removeDuplicates(self, numbers: list[int]) -> int:\r\n        left = 0\r\n        \r\n        for number in numbers[1:]:\r\n            if number > numbers[left]:\r\n                left += 1\r\n                numbers[left] = number\r\n\r\n        return left + 1", "testcase": "print(Solution().removeDuplicates([1, 1, 2]), 2)\r\nprint(Solution().removeDuplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]), 5)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-02T00:10:55.556Z", "updated_at": "2024-12-22T11:35:48.784Z"}}, {"model": "python_problems.solution", "pk": 230, "fields": {"problem": 125, "language": 2, "owner": 3, "solution": "/**\r\n * # O(n), O(1)\r\n * # two pointers\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar removeDuplicates = function (numbers) {\r\n  let left = 0;\r\n\r\n  for (const number of numbers.slice(1,)) {\r\n    if (number > numbers[left]) {\r\n      left++;\r\n      numbers[left] = number;\r\n    }\r\n  }\r\n\r\n  return left + 1\r\n}", "testcase": "console.log(removeDuplicates([1, 1, 2]), 2)\r\nconsole.log(removeDuplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]), 5)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-02T00:11:58.805Z", "updated_at": "2024-12-22T11:37:20.739Z"}}, {"model": "python_problems.solution", "pk": 231, "fields": {"problem": 126, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# sliding window\r\nclass Solution:\r\n    def totalFruit(self, fruits: list[int]) -> int:\r\n        left = 0\r\n        basket = {}\r\n        max_fruits = 0\r\n\r\n        for right, fruit in enumerate(fruits):\r\n            basket[fruit] = basket.get(fruit, 0) + 1  # add a fruit to the basket\r\n\r\n            while len(basket) > 2:  # while too many fruit types\r\n                left_fruit = fruits[left]  # `left` fruit type\r\n                basket[left_fruit] -= 1  # remove one `left` fruit from basket\r\n                left += 1  # increase the left pointer\r\n\r\n                if not basket[left_fruit]:  # if no `left` fruit\r\n                    basket.pop(left_fruit)  # pop that fruit type\r\n\r\n            if right - left + 1 > max_fruits:  # update max fruit counter\r\n                max_fruits = right - left + 1\r\n\r\n        return max_fruits", "testcase": "print(Solution().totalFruit([1, 2, 1]), 3)\r\nprint(Solution().totalFruit([0, 1, 2, 2]), 3)\r\nprint(Solution().totalFruit([1, 2, 3, 2, 2]), 4)\r\nprint(Solution().totalFruit([3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]), 5)\r\nprint(Solution().totalFruit([1, 0, 1, 4, 1, 4, 1, 2, 3]), 5)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-02T13:19:44.657Z", "updated_at": "2025-02-02T19:18:19.906Z"}}, {"model": "python_problems.solution", "pk": 232, "fields": {"problem": 126, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * sliding window, map()\r\n * @param {number[]} fruits\r\n * @return {number}\r\n */\r\nvar totalFruit = function (fruits) {\r\n  let left = 0;\r\n  const basket = new Map();\r\n  let maxFruit = 0;\r\n\r\n  for (let right = 0; right < fruits.length; right++) {\r\n    const fruit = fruits[right];\r\n\r\n    basket.set(fruit, (basket.get(fruit) || 0) + 1)  // add a fruit to the basket\r\n\r\n    while (basket.size > 2) {  // while too many fruit types\r\n      const leftFruit = fruits[left];  // `left` fruit type\r\n      basket.set(leftFruit, basket.get(leftFruit) - 1);  // remove one `left` fruit from basket\r\n      left++;  // increase the left pointer\r\n\r\n      if (basket.get(leftFruit) === 0) {  // if no `left` fruit\r\n        basket.delete(leftFruit);  // pop that fruit type\r\n      }\r\n    }\r\n\r\n    if ((right - left + 1) > maxFruit) {  // update max fruit counter\r\n      maxFruit = (right - left + 1)\r\n    }\r\n  }\r\n\r\n  return maxFruit\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(1)\r\n * sliding window, object\r\n * @param {number[]} fruits\r\n * @return {number}\r\n */\r\nvar totalFruit = function (fruits) {\r\n  let left = 0;\r\n  const basket = {};\r\n  let maxFruit = 0;\r\n\r\n  for (let right = 0; right < fruits.length; right++) {\r\n    const fruit = fruits[right];\r\n\r\n    basket[fruit] = (basket[fruit] || 0) + 1 // add a fruit to the basket\r\n\r\n    while (Object.keys(basket).length > 2) {  // while too many fruit types\r\n      const leftFruit = fruits[left];  // `left` fruit type\r\n      basket[leftFruit] -= 1;  // remove one `left` fruit from basket\r\n      left++;  // increase the left pointer\r\n\r\n      if (basket[leftFruit] === 0) {  // if no `left` fruit\r\n        delete basket[leftFruit];  // pop that fruit type // delete basket.leftFruit;\r\n      }\r\n    }\r\n\r\n    if ((right - left + 1) > maxFruit) {  // update max fruit counter\r\n      maxFruit = (right - left + 1)\r\n    }\r\n  }\r\n\r\n  return maxFruit\r\n}", "testcase": "console.log(totalFruit([1, 2, 1]), 3)\r\nconsole.log(totalFruit([0, 1, 2, 2]), 3)\r\nconsole.log(totalFruit([1, 2, 3, 2, 2]), 4)\r\nconsole.log(totalFruit([3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]), 5)\r\nconsole.log(totalFruit([1, 0, 1, 4, 1, 4, 1, 2, 3]), 5)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-02T13:20:14.987Z", "updated_at": "2024-12-02T13:20:15.010Z"}}, {"model": "python_problems.solution", "pk": 233, "fields": {"problem": 127, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack, deque\r\nfrom collections import deque\r\n\r\nclass Solution:\r\n    def validateStackSequences(self, pushed: list[int], popped: list[int]) -> bool:\r\n        queue = deque(popped)\r\n        stack = []\r\n\r\n        for number in pushed:\r\n            stack.append(number)\r\n\r\n            while stack and stack[-1] == queue[0]:\r\n                stack.pop()\r\n                queue.popleft()\r\n\r\n        if stack or queue:\r\n            return False\r\n        else:\r\n            return True", "testcase": "print(Solution().validateStackSequences([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]), True)\r\nprint(Solution().validateStackSequences([1, 2, 3, 4, 5], [4, 3, 5, 1, 2]), False)\r\nprint(Solution().validateStackSequences([2, 1, 0], [1, 2, 0]), True)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-02T14:24:21.411Z", "updated_at": "2024-12-02T14:24:21.437Z"}}, {"model": "python_problems.solution", "pk": 234, "fields": {"problem": 127, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * stack\r\n * @param {number[]} pushed\r\n * @param {number[]} popped\r\n * @return {boolean}\r\n */\r\nvar validateStackSequences = function (pushed, popped) {\r\n  let stack = [];\r\n\r\n  for (const number of pushed) {\r\n    stack.push(number);\r\n\r\n    while (\r\n      stack.length !== 0 &&\r\n      stack[stack.length - 1] === popped[0]\r\n    ) {\r\n      stack.pop();\r\n      popped.shift();\r\n    }\r\n  }\r\n\r\n  if (\r\n    stack.length !== 0 ||\r\n    popped.length !== 0) {\r\n    return false\r\n  } else return true\r\n}", "testcase": "console.log(validateStackSequences([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]), true)\r\nconsole.log(validateStackSequences([1, 2, 3, 4, 5], [4, 3, 5, 1, 2]), false)\r\nconsole.log(validateStackSequences([2, 1, 0], [1, 2, 0]), true)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-02T14:25:18.597Z", "updated_at": "2024-12-02T14:25:18.614Z"}}, {"model": "python_problems.solution", "pk": 235, "fields": {"problem": 128, "language": 1, "owner": 3, "solution": "# O(logn), O(1)\r\n# arithmetic sequence\r\nclass Solution:\r\n    def arrangeCoins(self, coins: int) -> int:\r\n        left = 1  # minimum number of coins\r\n        right = coins  # max upper boundry eg. for 10 coins there will be less than 10 rows\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2  # row number\r\n            coin_stack = (1 + middle) / 2 * middle  # number of coins in coin stack\r\n\r\n            if coin_stack == coins:  # if the number of provided coins is equal to the number of coins in the stack\r\n                return middle\r\n            elif coin_stack > coins:  # to much coins in the stack or the last row is not full\r\n                right = middle - 1\r\n            else:  # too little coins in the stack\r\n                left = middle + 1\r\n\r\n        return right\r\n\r\n# O(n), O(n)\r\nclass Solution:\r\n    def arrangeCoins(self, coins: int) -> int:\r\n        total = 0\r\n        index = 0\r\n\r\n        while total < coins:\r\n            index += 1\r\n            total += index\r\n\r\n        # if totlal == coins then the last row if full of coins\r\n        return index if total == coins else index - 1", "testcase": "print(Solution().arrangeCoins(5), 2)\r\nprint(Solution().arrangeCoins(8), 3)\r\nprint(Solution().arrangeCoins(2), 1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-12-02T20:54:14.668Z", "updated_at": "2024-12-02T20:54:14.692Z"}}, {"model": "python_problems.solution", "pk": 236, "fields": {"problem": 128, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number} coins\r\n * @return {number}\r\n */\r\nvar arrangeCoins = function (coins) {\r\n  let left = 1;\r\n  let right = coins;\r\n\r\n  while (left <= right) {\r\n      const middle = (left + right) / 2 | 0;\r\n      const coinStack = (1 + middle) / 2 * middle;\r\n\r\n      if (coins === coinStack) {\r\n          return middle\r\n      } else if (coins < coinStack) {\r\n          right = middle - 1;\r\n      } else {\r\n          left = middle + 1;\r\n      }\r\n  }\r\n\r\n  return right\r\n}", "testcase": "console.log(arrangeCoins(5), 2)\r\nconsole.log(arrangeCoins(8), 3)\r\nconsole.log(arrangeCoins(2), 1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-12-02T20:55:58.463Z", "updated_at": "2024-12-02T20:55:58.481Z"}}, {"model": "python_problems.solution", "pk": 237, "fields": {"problem": 129, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        node = head\r\n\r\n        while node.next:\r\n            if node.val == node.next.val:\r\n                node.next = node.next.next\r\n            else:\r\n                node = node.next\r\n        \r\n        return head\r\n\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        node = head\r\n\r\n        while node:\r\n            while node.next and node.val == node.next.val:\r\n                node.next = node.next.next\r\n            \r\n            node = node.next\r\n        \r\n        return head", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-02T21:31:30.296Z", "updated_at": "2024-12-02T21:31:30.314Z"}}, {"model": "python_problems.solution", "pk": 238, "fields": {"problem": 129, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar deleteDuplicates = function (head) {\r\n  if (head === null || head.next === null) {\r\n    return head\r\n  }\r\n\r\n  let node = head;\r\n\r\n  while (node.next) {\r\n    if (node.val === node.next.val) {\r\n      node.next = node.next.next;\r\n    } else {\r\n      node = node.next;\r\n    }\r\n  }\r\n\r\n  return head\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-02T21:32:06.029Z", "updated_at": "2024-12-02T21:32:06.051Z"}}, {"model": "python_problems.solution", "pk": 239, "fields": {"problem": 130, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def isIsomorphic(self, word1: str, word2: str) -> bool:\r\n        iso_map = {}  # letter from word1 => letter in word2\r\n\r\n        for index, letter in enumerate(word1):\r\n            if letter in iso_map:  # if the letter appeared before\r\n                if iso_map[letter] != word2[index]:  # if no match in same indexes\r\n                    return False\r\n            else:  # if the letter is seen for the first time\r\n                if word2[index] in iso_map.values():  # if there's already another key pointing to that letter\r\n                    return False\r\n\r\n                iso_map[letter] = word2[index]  # add letter to iso dict\r\n\r\n        return True", "testcase": "print(Solution().isIsomorphic(\"egg\", \"add\"), True)\r\nprint(Solution().isIsomorphic(\"foo\", \"bar\"), False)\r\nprint(Solution().isIsomorphic(\"paper\", \"title\"), True)\r\nprint(Solution().isIsomorphic(\"badc\", \"baba\"), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-02T22:37:51.457Z", "updated_at": "2024-12-03T21:23:33.769Z"}}, {"model": "python_problems.solution", "pk": 240, "fields": {"problem": 130, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} word1\r\n * @param {string} word2\r\n * @return {boolean}\r\n */\r\nvar isIsomorphic = function (word1, word2) {\r\n  let isoMap = new Map();\r\n  let values = new Set();\r\n\r\n  for (let index = 0; index <= word1.length; index++) {\r\n    const letter = word1[index];\r\n\r\n    if (isoMap.has(letter)) {\r\n      if (isoMap.get(letter) != word2[index]) return false\r\n    } else {\r\n      if (values.has(word2[index])) return false\r\n\r\n      isoMap.set(letter, word2[index]);\r\n      values.add(word2[index]);\r\n    }\r\n  }\r\n\r\n  return true\r\n}", "testcase": "console.log(isIsomorphic(\"egg\", \"add\"), true)\r\nconsole.log(isIsomorphic(\"foo\", \"bar\"), false)\r\nconsole.log(isIsomorphic(\"paper\", \"title\"), true)\r\nconsole.log(isIsomorphic(\"badc\", \"baba\"), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-03T21:24:49.830Z", "updated_at": "2024-12-03T21:24:49.850Z"}}, {"model": "python_problems.solution", "pk": 241, "fields": {"problem": 131, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def findContentChildren(self, children: list[int], cookies: list[int]) -> int:\r\n        children.sort()\r\n        cookies.sort()\r\n        left = 0\r\n\r\n        for cookie in cookies:\r\n            if (left < len(children) and  # if in bounds of children and\r\n                    children[left] <= cookie):  # child is content\r\n                left += 1  # move to the next child\r\n\r\n        return left", "testcase": "print(Solution().findContentChildren([1, 2, 3], [1, 1]), 1)\r\nprint(Solution().findContentChildren([1, 2], [1, 2, 3]), 2)\r\nprint(Solution().findContentChildren([10, 9, 8, 7], [5, 6, 7, 8]), 2)", "time_complexity": 5, "space_complexity": 1, "created_at": "2024-12-04T16:00:48.343Z", "updated_at": "2024-12-04T16:00:48.362Z"}}, {"model": "python_problems.solution", "pk": 242, "fields": {"problem": 131, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} children\r\n * @param {number[]} cookies\r\n * @return {number}\r\n */\r\nvar findContentChildren = function (children, cookies) {\r\n  children.sort((a, b) => a - b);\r\n  cookies.sort((a, b) => a - b);\r\n  let left = 0;\r\n\r\n  for (let right = 0; right < cookies.length; right++) {\r\n    const cookie = cookies[right];\r\n\r\n    if (children[left] <= cookie) {   // if child is content\r\n      left++;  // move to the next child\r\n    }\r\n  }\r\n\r\n  return left\r\n}", "testcase": "console.log(findContentChildren([1, 2, 3], [1, 1]), 1)\r\nconsole.log(findContentChildren([1, 2], [1, 2, 3]), 2)\r\nconsole.log(findContentChildren([10, 9, 8, 7], [5, 6, 7, 8]), 2)", "time_complexity": 5, "space_complexity": 1, "created_at": "2024-12-04T16:02:00.316Z", "updated_at": "2024-12-04T16:02:00.334Z"}}, {"model": "python_problems.solution", "pk": 243, "fields": {"problem": 132, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# sliding window\r\nclass Solution:\r\n    def maxVowels(self, word: str, substring_length: int) -> int:\r\n        left = 0\r\n        vovels = \"aeoiu\"\r\n        vovel_count = 0\r\n        max_vovels = 0\r\n\r\n        for right, letter in enumerate(word):\r\n            if letter in vovels:  # if right letter is a vovel increase the counter\r\n                vovel_count += 1\r\n\r\n            if right - left + 1 == substring_length + 1:  # if substring is longer than its upper limit\r\n                if word[left] in vovels:  # if left letter is a vovel decrease the counter\r\n                    vovel_count -= 1\r\n                \r\n                left += 1  # maintain the window length\r\n            \r\n            max_vovels = max(max_vovels, vovel_count)  # update max vovels\r\n\r\n        return max_vovels", "testcase": "print(Solution().maxVowels(\"abciiidef\", 3), 3)\r\nprint(Solution().maxVowels(\"aeiou\", 2), 2)\r\nprint(Solution().maxVowels(\"leetcode\", 3), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-04T21:13:18.479Z", "updated_at": "2025-02-02T20:10:05.260Z"}}, {"model": "python_problems.solution", "pk": 244, "fields": {"problem": 132, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} word\r\n * @param {number} substringLength\r\n * @return {number}\r\n */\r\nvar maxVowels = function(word, substringLength) {\r\n  const vovels = 'aeoiu';\r\n  let left = 0;\r\n  let vovelCounter = 0;\r\n  let maxVovels = 0;\r\n\r\n  for (let right = 0; right < word.length; right++) {\r\n      const letter = word[right];\r\n\r\n      if (vovels.includes(letter)) {\r\n          vovelCounter++;\r\n      }\r\n\r\n      if (right - left + 1 === substringLength + 1) {\r\n          const leftLetter = word[left];\r\n          left++;\r\n\r\n          if (vovels.includes(leftLetter)) {\r\n              vovelCounter--;\r\n          }\r\n      }\r\n\r\n      if (vovelCounter > maxVovels) maxVovels = vovelCounter\r\n  }\r\n\r\n  return maxVovels\r\n}", "testcase": "console.log(maxVowels(\"abciiidef\", 3), 3)\r\nconsole.log(maxVowels(\"aeiou\", 2), 2)\r\nconsole.log(maxVowels(\"leetcode\", 3), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-04T21:15:11.726Z", "updated_at": "2024-12-04T21:15:11.745Z"}}, {"model": "python_problems.solution", "pk": 245, "fields": {"problem": 133, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def asteroidCollision(self, asteroids: list[int]) -> list[int]:\r\n        stack = []\r\n\r\n        for asteroid in asteroids:\r\n            add_astr = True\r\n\r\n            # pop all asteroids from the end of the stack that collide with current asteroid\r\n            while (add_astr and  # can add asteroid \r\n                   stack and  # stack is not empty\r\n                   asteroid < 0 and  # curren asteroid moves left\r\n                   stack[-1] > 0):  # asteroid from stack movet right\r\n                diff = asteroid + stack[-1]  \r\n\r\n                if not diff:  # both asteroids are the same size\r\n                    add_astr = False  # stop the loop and don't add the curren asteroid to the stack\r\n                    stack.pop()\r\n                elif diff < 0:  # current asteroid is bigger\r\n                    stack.pop()\r\n                else:  # asteroid in the stack is bigger\r\n                    add_astr = False  # stop the loop and don't add the curren asteroid to the stack\r\n\r\n            if add_astr:\r\n                stack.append(asteroid)\r\n\r\n        return stack", "testcase": "print(Solution().asteroidCollision([5, 10, -5]), [5, 10])\r\nprint(Solution().asteroidCollision([8, -8]), [])\r\nprint(Solution().asteroidCollision([10, 2, -5]), [10])\r\nprint(Solution().asteroidCollision([-2, -1, 1, 2]), [-2, -1, 1, 2])\r\nprint(Solution().asteroidCollision([1, 2, -5]), [-5])\r\nprint(Solution().asteroidCollision([-2, -2, 1, -2]), [-2, -2, -2])\r\nprint(Solution().asteroidCollision([-2, -1, 1, -2]), [-2, -1, -2])\r\nprint(Solution().asteroidCollision([-2, 2, 1, -2]), [-2])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-05T15:43:05.731Z", "updated_at": "2024-12-05T15:43:05.751Z"}}, {"model": "python_problems.solution", "pk": 246, "fields": {"problem": 133, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} asteroids\r\n * @return {number[]}\r\n */\r\nvar asteroidCollision = function (asteroids) {\r\n  const stack = [];\r\n  let asteroid;\r\n\r\n  for (asteroid of asteroids) {\r\n    while (stack.length !== 0 &&\r\n      asteroid < 0 &&\r\n      stack[stack.length - 1] > 0\r\n    ) {\r\n      const diff = stack[stack.length - 1] + asteroid;\r\n\r\n      if (diff === 0) {\r\n        stack.pop();\r\n        asteroid = 0;\r\n      } else if (diff > 0) {\r\n        asteroid = 0;\r\n      } else {\r\n        stack.pop();\r\n      }\r\n    }\r\n    \r\n    if (asteroid !== 0) stack.push(asteroid);\r\n  }\r\n\r\n  return stack\r\n}", "testcase": "console.log(asteroidCollision([5, 10, -5]), [5, 10])\r\nconsole.log(asteroidCollision([8, -8]), [])\r\nconsole.log(asteroidCollision([10, 2, -5]), [10])\r\nconsole.log(asteroidCollision([-2, -1, 1, 2]), [-2, -1, 1, 2])\r\nconsole.log(asteroidCollision([1, 2, -5]), [-5])\r\nconsole.log(asteroidCollision([-2, -2, 1, -2]), [-2, -2, -2])\r\nconsole.log(asteroidCollision([-2, -1, 1, -2]), [-2, -1, -2])\r\nconsole.log(asteroidCollision([-2, 2, 1, -2]), [-2])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-05T16:00:59.412Z", "updated_at": "2024-12-05T16:00:59.432Z"}}, {"model": "python_problems.solution", "pk": 247, "fields": {"problem": 134, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def sortedSquares(self, numbers: list[int]) -> list[int]:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n        sorted_squared = []\r\n\r\n        while left <= right:\r\n            if numbers[left] ** 2 > numbers[right] ** 2:\r\n                sorted_squared.append(numbers[left] ** 2)\r\n                left += 1\r\n            else:\r\n                sorted_squared.append(numbers[right] ** 2)\r\n                right -= 1\r\n        \r\n        sorted_squared.reverse()\r\n        \r\n        return sorted_squared", "testcase": "print(Solution().sortedSquares([-4, -1, 0, 3, 10]), [0, 1, 9, 16, 100])\r\nprint(Solution().sortedSquares([-7, -3, 2, 3, 11]), [4, 9, 9, 49, 121])\r\nprint(Solution().sortedSquares([1, 2, 3]), [1, 4, 9])\r\nprint(Solution().sortedSquares([-3, -2, -1]), [1, 4, 9])\r\nprint(Solution().sortedSquares([0]), [0])\r\nprint(Solution().sortedSquares([0, 1]), [0, 1])\r\nprint(Solution().sortedSquares([-10000, -9999, -7, -5, 0, 0, 10000]), [0, 0, 25, 49, 99980001, 100000000, 100000000])\r\nprint(Solution().sortedSquares([-1, 1]), [1, 1])\r\nprint(Solution().sortedSquares([-1, 1, 1]), [1, 1, 1])\r\nprint(Solution().sortedSquares([-3, -3, -2, 1]), [1, 4, 9, 9])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T00:42:29.516Z", "updated_at": "2024-12-06T00:42:29.534Z"}}, {"model": "python_problems.solution", "pk": 248, "fields": {"problem": 134, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar sortedSquares = function (numbers) {\r\n  let left = 0;\r\n  let right = numbers.length - 1;\r\n  const sortedSquaresList = [];\r\n\r\n  while (left <= right) {\r\n    if (numbers[left] ** 2 > numbers[right] ** 2) {\r\n      sortedSquaresList.push(numbers[left] ** 2);\r\n      left++;\r\n    } else {\r\n      sortedSquaresList.push(numbers[right] ** 2);\r\n      right--;\r\n    }\r\n  }\r\n\r\n  return sortedSquaresList.reverse()\r\n}", "testcase": "console.log(sortedSquares([-4, -1, 0, 3, 10]), [0, 1, 9, 16, 100])\r\nconsole.log(sortedSquares([-7, -3, 2, 3, 11]), [4, 9, 9, 49, 121])\r\nconsole.log(sortedSquares([1, 2, 3]), [1, 4, 9])\r\nconsole.log(sortedSquares([-3, -2, -1]), [1, 4, 9])\r\nconsole.log(sortedSquares([0]), [0])\r\nconsole.log(sortedSquares([0, 1]), [0, 1])\r\nconsole.log(sortedSquares([-10000, -9999, -7, -5, 0, 0, 10000]), [0, 0, 25, 49, 99980001, 100000000, 100000000])\r\nconsole.log(sortedSquares([-1, 1]), [1, 1])\r\nconsole.log(sortedSquares([-1, 1, 1]), [1, 1, 1])\r\nconsole.log(sortedSquares([-3, -3, -2, 1]), [1, 4, 9, 9])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T00:48:40.475Z", "updated_at": "2024-12-06T00:48:40.495Z"}}, {"model": "python_problems.solution", "pk": 249, "fields": {"problem": 135, "language": 1, "owner": 3, "solution": "# [1, 2, 3_, 4, 5_]\r\n# [1, 2, 3, 4_, 5, 6, None_]\r\n\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        node = head\r\n        slow = node\r\n        fast = node\r\n\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        \r\n        return slow", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T01:40:00.599Z", "updated_at": "2024-12-06T01:40:00.614Z"}}, {"model": "python_problems.solution", "pk": 250, "fields": {"problem": 135, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar middleNode = function (head) {\r\n  let node = head;\r\n  let slow = node;\r\n  let fast = node;\r\n\r\n  while (fast && fast.next) {\r\n      slow = slow.next;\r\n      fast = fast.next.next;\r\n  }\r\n\r\n  return slow\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T01:40:25.288Z", "updated_at": "2024-12-06T01:40:25.308Z"}}, {"model": "python_problems.solution", "pk": 251, "fields": {"problem": 136, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# Iteration\r\nclass Solution:\r\n    def canPlaceFlowers(self, flowerbed: list[int], n: int) -> bool:\r\n        if not n:\r\n            return True\r\n        \r\n        counter = 0\r\n        contiguous_zeros = 1  # count current contiguous zeros length, initialize with 1 because start with  [0, 0, 1, ...] is legit place for a flower\r\n\r\n        for place in flowerbed:\r\n            if place:  # if occupied by a flower\r\n                if contiguous_zeros >= 3:\r\n                    counter += (contiguous_zeros - 1) // 2  # 3, 4 => 1; 5, 6 => 2\r\n\r\n                    # early exit\r\n                    if counter >= n:\r\n                        return True\r\n\r\n                contiguous_zeros = 0  # reset contiguous zeros length\r\n            else:  # if free place for a flower\r\n                contiguous_zeros += 1\r\n\r\n        # if free places at the end of the flowerbed\r\n        counter += contiguous_zeros // 2\r\n\r\n        return counter >= n", "testcase": "print(Solution().canPlaceFlowers([1, 0, 0, 0, 1], 1), True)\r\nprint(Solution().canPlaceFlowers([1, 0, 0, 0, 1], 2), False)\r\nprint(Solution().canPlaceFlowers([1, 0, 0, 0], 1), True)\r\nprint(Solution().canPlaceFlowers([1, 0, 1, 0, 1, 0, 1], 0), True)\r\nprint(Solution().canPlaceFlowers([0, 0, 1, 0, 1], 1), True)\r\nprint(Solution().canPlaceFlowers([1, 0, 0, 0, 1, 0, 0], 2), True)\r\nprint(Solution().canPlaceFlowers([0, 0, 0], 2), True)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T03:19:32.785Z", "updated_at": "2024-12-06T03:19:32.803Z"}}, {"model": "python_problems.solution", "pk": 252, "fields": {"problem": 136, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} flowerbed\r\n * @param {number} n\r\n * @return {boolean}\r\n */\r\nvar canPlaceFlowers = function (flowerbed, n) {\r\n  let spaces = 1;\r\n\r\n  for (const place of flowerbed) {\r\n    if (place) {\r\n      if (spaces > 2) {\r\n        n -= (spaces - 1) / 2 | 0\r\n      }\r\n\r\n      if (n <= 0) return true\r\n\r\n      spaces = 0;\r\n    } else {\r\n      spaces++\r\n    }\r\n  }\r\n  n -= spaces / 2 | 0\r\n\r\n  return n <= 0\r\n}", "testcase": "console.log(canPlaceFlowers([1, 0, 0, 0, 1], 1), true)\r\nconsole.log(canPlaceFlowers([1, 0, 0, 0, 1], 2), false)\r\nconsole.log(canPlaceFlowers([1, 0, 0, 0], 1), true)\r\nconsole.log(canPlaceFlowers([1, 0, 1, 0, 1, 0, 1], 0), true)\r\nconsole.log(canPlaceFlowers([0, 0, 1, 0, 1], 1), true)\r\nconsole.log(canPlaceFlowers([1, 0, 0, 0, 1, 0, 0], 2), true)\r\nconsole.log(canPlaceFlowers([0, 0, 0], 2), true)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T03:49:42.793Z", "updated_at": "2024-12-06T03:49:42.811Z"}}, {"model": "python_problems.solution", "pk": 253, "fields": {"problem": 20, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * build-in function\r\n * @param {string[]} words\r\n * @return {string}\r\n */\r\nvar firstPalindrome = function (words) {\r\n  for (const word of words) {\r\n    if (word === word.split('').reverse().join('')) return word\r\n  }\r\n\r\n  return ''\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(1)\r\n * two pointers\r\n * @param {string[]} words\r\n * @return {string}\r\n */\r\nvar firstPalindrome = function (words) {\r\n  for (const word of words) {\r\n    let left = 0;\r\n    let right = word.length - 1;\r\n\r\n    while (left < right) {\r\n      if (word[left] !== word[right]) break\r\n\r\n      left++;\r\n      right--;\r\n    }\r\n\r\n    if (left >= right) return word\r\n  }\r\n\r\n  return ''\r\n}", "testcase": "console.log(firstPalindrome(['abc', 'car', 'ada', 'racecar', 'cool']), 'ada')\r\nconsole.log(firstPalindrome(['notapalindrome', 'racecar']), 'racecar')\r\nconsole.log(firstPalindrome(['def', 'ghi']), '')", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-12-06T04:51:16.742Z", "updated_at": "2024-12-06T04:53:53.025Z"}}, {"model": "python_problems.solution", "pk": 254, "fields": {"problem": 137, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def sortArrayByParity(self, numbers: list[int]) -> list[int]:\r\n        left = 0\r\n\r\n        for right, number in enumerate(numbers):\r\n            if not number % 2:\r\n                numbers[left], numbers[right] = numbers[right], numbers[left]\r\n                left += 1\r\n\r\n        return numbers\r\n\r\n\r\n# O(n), O(n)\r\n# deque\r\nfrom collections import deque\r\n\r\nclass Solution:\r\n    def sortArrayByParity(self, numbers: list[int]) -> list[int]:\r\n        queue = deque()\r\n\r\n        for number in numbers:\r\n            if number % 2:\r\n                queue.append(number)\r\n            else:\r\n                queue.appendleft(number)\r\n\r\n        return list(queue)", "testcase": "print(Solution().sortArrayByParity([3, 1, 2, 4]), [2, 4, 3, 1])\r\nprint(Solution().sortArrayByParity([1, 2, 3, 4]), [2, 4, 3, 1])\r\nprint(Solution().sortArrayByParity([0]), [0])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T21:33:02.063Z", "updated_at": "2024-12-06T21:33:02.115Z"}}, {"model": "python_problems.solution", "pk": 255, "fields": {"problem": 137, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * two pointers\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar sortArrayByParity = function (numbers) {\r\n  let left = 0;\r\n\r\n  for (let right = 0; right < numbers.length; right++) {\r\n    const number = numbers[right];\r\n\r\n    if (number % 2 === 0) {\r\n      [numbers[left], numbers[right]] = [numbers[right], numbers[left]]\r\n      left++;\r\n    }\r\n  }\r\n\r\n  return numbers\r\n}", "testcase": "console.log(sortArrayByParity([3, 1, 2, 4]), [2, 4, 3, 1])\r\nconsole.log(sortArrayByParity([1, 2, 3, 4]), [2, 4, 3, 1])\r\nconsole.log(sortArrayByParity([0]), [0])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T21:48:11.993Z", "updated_at": "2024-12-06T21:48:12.013Z"}}, {"model": "python_problems.solution", "pk": 256, "fields": {"problem": 138, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    # get the length of a linked list\r\n    def getLength(self, node):\r\n        list_length = 0\r\n        \r\n        while node:\r\n            list_length += 1\r\n            node = node.next\r\n        \r\n        return list_length\r\n\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:        \r\n        a_length = self.getLength(headA)\r\n        b_length = self.getLength(headB)\r\n        diff_length = abs(a_length - b_length)\r\n        \r\n        if a_length > b_length:\r\n            for _ in range(diff_length):\r\n                headA = headA.next\r\n        else:\r\n            for _ in range(diff_length):\r\n                headB = headB.next\r\n\r\n        while headA and headB:\r\n            if headA == headB:\r\n                return headA\r\n            else:\r\n                headA = headA.next\r\n                headB = headB.next\r\n\r\n        return None\r\n\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:        \r\n        nodeA = headA\r\n        nodeB = headB\r\n\r\n        while nodeA != nodeB:\r\n            nodeA = nodeA.next if nodeA else headB\r\n            nodeB = nodeB.next if nodeB else headA\r\n        else:\r\n            return nodeA", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T23:29:52.265Z", "updated_at": "2024-12-06T23:29:52.284Z"}}, {"model": "python_problems.solution", "pk": 257, "fields": {"problem": 138, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n  let nodeA = headA;\r\n  let nodeB = headB;\r\n\r\n  while (nodeA != nodeB) {\r\n    nodeA = nodeA === null ? headB : nodeA.next;\r\n    nodeB = nodeB === null ? headA : nodeB.next;\r\n  }\r\n\r\n  return nodeA\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-06T23:43:31.109Z", "updated_at": "2024-12-06T23:43:31.126Z"}}, {"model": "python_problems.solution", "pk": 258, "fields": {"problem": 139, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\n# O(n), O(1)\r\n# linked list (Reverse And Merge)\r\nclass Solution:\r\n    def reorderList(self, head: ListNode) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify head in-place instead.\r\n        \"\"\"\r\n        # find middle node\r\n        slow = head\r\n        fast = head.next\r\n\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        # slow.next is an end\r\n        previous = None\r\n        node = slow.next\r\n        slow.next = None  # Cut the list into two halves\r\n\r\n        # reverse second part (always even size)\r\n        while node:\r\n            next_node = node.next\r\n            node.next = previous\r\n            previous = node\r\n            node = next_node\r\n        \r\n        # reorder\r\n        left = head\r\n        right = previous\r\n\r\n        while right:\r\n            next_left = left.next\r\n            next_right = right.next\r\n            left.next = right\r\n            right.next = next_left\r\n            left = next_left\r\n            right = next_right\r\n\r\n\r\n# node4 = ListNode(5, None)\r\n# node3 = ListNode(4, node4)\r\nnode3 = ListNode(4, None)\r\nnode2 = ListNode(3, node3)\r\nnode1 = ListNode(2, node2)\r\nnode0 = ListNode(1, node1)\r\n\r\nprint(node0.next)\r\nreordered = Solution().reorderList(node0)\r\nprint(node0.next)\r\n\r\n\r\n\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\n# O(n), O(n)\r\n# linked list to list of nodes\r\nclass Solution:\r\n    def reorderList(self, head: ListNode) -> None:\r\n        \"\"\"\r\n        Do not return anything, modify head in-place instead.\r\n        \"\"\"\r\n        nodes = []\r\n        node = head\r\n\r\n        while node:\r\n            nodes.append(node)\r\n            node = node.next\r\n\r\n        # return nodes\r\n\r\n        left = 0\r\n        right = len(nodes) -1\r\n\r\n        while left < right:\r\n            nodes[left].next = nodes[right]\r\n            print(nodes[left].val)\r\n            left += 1\r\n\r\n            if left == right:\r\n                break\r\n\r\n            nodes[right].next = nodes[left]\r\n            print(nodes[right].val)\r\n            right -= 1\r\n        \r\n        nodes[left].next = None\r\n\r\n        return node\r\n\r\nnode4 = ListNode(5, None)\r\nnode3 = ListNode(4, node4)\r\n# node3 = ListNode(4, None)\r\nnode2 = ListNode(3, node3)\r\nnode1 = ListNode(2, node2)\r\nnode0 = ListNode(1, node1)\r\n\r\nprint(node1.next)\r\nreordered = Solution().reorderList(node0)\r\nprint(node1.next)", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-07T14:16:25.058Z", "updated_at": "2024-12-07T14:16:25.078Z"}}, {"model": "python_problems.solution", "pk": 259, "fields": {"problem": 139, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * O(n), O(1)\r\n * linked list (Reverse And Merge)\r\n * @param {ListNode} head\r\n * @return {void} Do not return anything, modify head in-place instead.\r\n */\r\nvar reorderList = function (head) {\r\n  let slow = head;\r\n  let fast = head.next;\r\n\r\n  while (fast && fast.next) {\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n  }\r\n\r\n  node = slow.next;\r\n  previous = null;\r\n  slow.next = null;\r\n\r\n  while (node) {\r\n    nextNode = node.next;\r\n    node.next = previous;\r\n    previous = node;\r\n    node = nextNode;\r\n  }\r\n\r\n  let left = head;\r\n  let right = previous;\r\n\r\n  while (right) {\r\n    nextLeft = left.next;\r\n    nextRight = right.next;\r\n    left.next = right;\r\n    right.next = nextLeft;\r\n    left = nextLeft;\r\n    right = nextRight;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * O(n), O(n)\r\n * linked list to list of nodes\r\n * @param {ListNode} head\r\n * @return {void} Do not return anything, modify head in-place instead.\r\n */\r\nvar reorderList = function (head) {\r\n  let node = head;\r\n  const nodes = [];\r\n\r\n  while (node !== null) {\r\n    nodes.push(node)\r\n    node = node.next\r\n  }\r\n\r\n  let left = 0;\r\n  let right = nodes.length - 1;\r\n\r\n  while (left < right) {\r\n    nodes[left].next = nodes[right];\r\n    left++;\r\n\r\n    if (left == right) break\r\n\r\n    nodes[right].next = nodes[left];\r\n    right--;\r\n  }\r\n  nodes[left].next = null;\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-07T14:29:35.679Z", "updated_at": "2024-12-07T14:29:35.700Z"}}, {"model": "python_problems.solution", "pk": 260, "fields": {"problem": 140, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\n# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\r\n        anchor = ListNode(0, head)  # add and anchor\r\n        left = anchor  # left pointer\r\n        right = anchor  # right pointer\r\n\r\n        # move the right pointer `n` nodes ahead\r\n        while n:\r\n            right = right.next\r\n            n -= 1\r\n        \r\n        # when right.next points to None, left.next points to node to remove\r\n        while right.next:\r\n            left = left.next\r\n            right = right.next\r\n        \r\n        left.next = left.next.next  # skip nth node\r\n\r\n        return anchor.next\r\n\r\n\r\n# O(n), O(n)\r\n# List\r\nclass Solution:\r\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\r\n        nodes = []\r\n        node = head\r\n\r\n        while node:\r\n            nodes.append(node)\r\n            node = node.next\r\n\r\n        if n == len(nodes):\r\n            return head.next\r\n        else:\r\n            node_index = len(nodes) - n\r\n            nodes[node_index - 1].next = nodes[node_index].next\r\n            return head", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-07T21:39:55.642Z", "updated_at": "2024-12-07T21:39:55.662Z"}}, {"model": "python_problems.solution", "pk": 261, "fields": {"problem": 140, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * O(n), O(1)\r\n * two pointers\r\n * @param {ListNode} head\r\n * @param {number} n\r\n * @return {ListNode}\r\n */\r\nvar removeNthFromEnd = function (head, n) {\r\n  let anchor = new ListNode(0, head);\r\n  let left = anchor;\r\n  let right = anchor;\r\n\r\n  while (n) {\r\n    right = right.next;\r\n    n--;\r\n  }\r\n\r\n  while (right.next) {\r\n    left = left.next;\r\n    right = right.next;\r\n  }\r\n\r\n  left.next = left.next.next;\r\n\r\n  return anchor.next\r\n}\r\n\r\n\r\n/**\r\n * # O(n), O(n)\r\n * # List\r\n * @param {ListNode} head\r\n * @param {number} n\r\n * @return {ListNode}\r\n */\r\nvar removeNthFromEnd = function (head, n) {\r\n  const nodes = [];\r\n  let node = head;\r\n\r\n  while (node) {\r\n    nodes.push(node);\r\n    node = node.next;\r\n  }\r\n\r\n  if (n === nodes.length) return head.next\r\n  else {\r\n    const index = nodes.length - n;\r\n    nodes[index - 1].next = nodes[index].next;\r\n    return head\r\n  }\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-07T21:47:11.550Z", "updated_at": "2024-12-07T21:47:11.568Z"}}, {"model": "python_problems.solution", "pk": 262, "fields": {"problem": 141, "language": 1, "owner": 3, "solution": "# Definition for a Node.\r\nclass ListNode:\r\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\r\n        self.val = int(x)\r\n        self.next = next\r\n        self.random = random\r\n\r\n# O(n), O(n):\r\n# dictionary (two pass)\r\nclass Solution:\r\n    def copyRandomList(self, head: ListNode) -> ListNode:\r\n        node_copy = {None: None}\r\n        node = head\r\n\r\n        while node:\r\n            node_copy[node] = Node(node.val)\r\n            node = node.next\r\n\r\n        node = head\r\n\r\n        while node:\r\n            node_copy[node].next = node_copy[node.next]\r\n            node_copy[node].random = node_copy[node.random]\r\n            node = node.next\r\n\r\n        return node_copy[head]", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-07T22:34:11.990Z", "updated_at": "2024-12-07T22:34:12.009Z"}}, {"model": "python_problems.solution", "pk": 263, "fields": {"problem": 141, "language": 2, "owner": 3, "solution": "/**\r\n * // Definition for a _Node.\r\n * function _Node(val, next, random) {\r\n *    this.val = val;\r\n *    this.next = next;\r\n *    this.random = random;\r\n * };\r\n */\r\n\r\n/**\r\n * O(n), O(n):\r\n * dictionary (two pass)\r\n * @param {_Node} head\r\n * @return {_Node}\r\n */\r\nvar copyRandomList = function (head) {\r\n  const nodeCopy = new Map();\r\n  nodeCopy.set(null, null)\r\n  let node = head;\r\n\r\n  while (node) {\r\n    nodeCopy.set(node, new _Node(node.val));\r\n    node = node.next;\r\n  }\r\n\r\n  node = head;\r\n\r\n  while (node) {\r\n    nodeCopy.get(node).next = nodeCopy.get(node.next);\r\n    nodeCopy.get(node).random = nodeCopy.get(node.random);\r\n    node = node.next;\r\n  }\r\n\r\n  return nodeCopy.get(head)\r\n}\r\n\r\n\r\n\r\nconst node2 = new _Node(2, null);\r\nconst node1 = new _Node(1, node2);\r\nconst node0 = new _Node(0, node1);\r\n\r\nconsole.log(node2.next)\r\nconsole.log(node2)\r\nconsole.log(node1.next)\r\n\r\nconsole.log(copyRandomList(node0))", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-07T22:35:03.951Z", "updated_at": "2024-12-07T22:35:03.973Z"}}, {"model": "python_problems.solution", "pk": 264, "fields": {"problem": 142, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\n# O(n), O(1)\r\n# Iteration\r\nclass Solution:\r\n    def addTwoNumbers(self, head1: ListNode, head2: ListNode) -> ListNode:\r\n        anchor = node = ListNode()\r\n        carry = 0\r\n\r\n        while head1 or head2:\r\n            first_value = head1.val if head1 else 0\r\n            second_value = head2.val if head2 else 0\r\n            value = first_value + second_value + carry\r\n            \r\n            carry = value // 10\r\n            value = value % 10\r\n                \r\n            node.next = ListNode(value)\r\n            node = node.next\r\n            head1 = head1.next if head1 else None\r\n            head2 = head2.next if head2 else None\r\n\r\n        # case where there'a a carry after while loop finishes\r\n        if carry:\r\n            node.next = ListNode(carry)\r\n            node = node.next\r\n        \r\n        node.next = None  # end linked list with None\r\n\r\n        return anchor.next\r\n\r\n\r\nnodeA2 = ListNode(3, None)\r\nnodeA1 = ListNode(4, nodeA2)\r\nnodeA0 = ListNode(2, nodeA1)\r\n\r\nnodeB2 = ListNode(4, None)\r\nnodeB1 = ListNode(6, nodeB2)\r\nnodeB0 = ListNode(5, nodeB1)\r\n\r\nprint(nodeA0.val)\r\nsummed = Solution().addTwoNumbers(nodeA0, nodeB0)\r\nprint(summed.next.next.val)", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-08T00:03:04.368Z", "updated_at": "2024-12-08T00:04:08.285Z"}}, {"model": "python_problems.solution", "pk": 265, "fields": {"problem": 142, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * O(n), O(1)\r\n * Iteration\r\n * @param {ListNode} l1\r\n * @param {ListNode} l2\r\n * @return {ListNode}\r\n */\r\nvar addTwoNumbers = function (head1, head2) {\r\n  let node1 = head1;\r\n  let node2 = head2;\r\n  const dummy = new ListNode();\r\n  let node = dummy;\r\n  carry = 0;\r\n\r\n  while (node1 || node2) {r\r\n    const firstValue = node1 ? node1.val : 0;\r\n    const secondValue = node2 ? node2.val : 0;\r\n    let value = firstValue + secondValue + carry;\r\n    carry = value / 10 | 0;\r\n    value = value % 10;\r\n\r\n    node.next = new ListNode(value);\r\n    node = node.next;\r\n    node1 = node1 ? node1.next : null;\r\n    node2 = node2 ? node2.next : null;\r\n  }\r\n\r\n  if (carry) {\r\n    node.next = new ListNode(carry);\r\n  }\r\n\r\n  return dummy.next\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-08T00:04:45.604Z", "updated_at": "2024-12-08T00:04:45.622Z"}}, {"model": "python_problems.solution", "pk": 266, "fields": {"problem": 143, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# dict, two pass\r\nclass Solution:\r\n    def majorityElement(self, numbers: list[int]) -> int:\r\n        counter = {}\r\n\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n\r\n        max_value = 0\r\n        max_key = 0\r\n        \r\n        for key, value in counter.items():            \r\n            if value > max_value:\r\n                max_value = max(max_value, value)\r\n                max_key = key\r\n\r\n        return max_key\r\n\r\n\r\n# O(n), O(n)\r\n# dict, one pass\r\nclass Solution:\r\n    def majorityElement(self, numbers: list[int]) -> int:\r\n        counter = {}\r\n        max_value = 0\r\n        max_key = 0\r\n\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n\r\n            if counter[number] > max_value:\r\n                max_key = number\r\n                max_value = max(max_value, counter[number])\r\n\r\n        return max_key\r\n\r\n\r\n# O(n), O(1)\r\n# Boyer-Moore\r\nclass Solution:\r\n    def majorityElement(self, numbers: list[int]) -> int:\r\n        key, value = 0\r\n        \r\n        for number in numbers:\r\n            if not value:\r\n                key = number\r\n                value += 1\r\n            else:\r\n                if key == number:\r\n                    value += 1\r\n                else:\r\n                    value -= 1\r\n\r\n        return key\r\n\r\n# O(n), O(1)\r\n# Boyer-Moore\r\nclass Solution:\r\n    def majorityElement(self, numbers: list[int]) -> int:\r\n        key, value = 0, 0\r\n        \r\n        for number in numbers:\r\n            if not value:\r\n                key = number\r\n            \r\n            value += 1 if key == number else -1\r\n\r\n        return key", "testcase": "print(Solution().majorityElement([3, 2, 3]), 3)\r\nprint(Solution().majorityElement([2, 2, 1, 1, 1, 2, 2]), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-08T03:19:35.124Z", "updated_at": "2024-12-08T03:19:35.144Z"}}, {"model": "python_problems.solution", "pk": 267, "fields": {"problem": 143, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar majorityElement = function (numbers) {\r\n  let [key, value] = [0, 0];\r\n\r\n  for (const number of numbers) {\r\n    if (value === 0) key = number;\r\n\r\n    value += key === number ? 1 : -1;\r\n  }\r\n\r\n  return key\r\n}", "testcase": "console.log(majorityElement([3, 2, 3]), 3)\r\nconsole.log(majorityElement([2, 2, 1, 1, 1, 2, 2]), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-08T03:20:01.306Z", "updated_at": "2024-12-08T03:20:01.323Z"}}, {"model": "python_problems.solution", "pk": 268, "fields": {"problem": 22, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * build-in function\r\n * @param {string} text\r\n * @return {string}\r\n */\r\nvar reverseWords = function (text) {\r\n  return text.\r\n    split('').\r\n    reverse().\r\n    join(' ').\r\n    split(' ').\r\n    reverse().\r\n    join('')\r\n}", "testcase": "console.log(reverseWords(\"Let's take LeetCode contest\"), \"s'teL ekat edoCteeL tsetnoc\")\r\nconsole.log(reverseWords(\"Mr Ding\"), \"rM gniD\")\r\nconsole.log(reverseWords(\"hehhhhhhe\"), \"ehhhhhheh\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-08T18:43:07.946Z", "updated_at": "2024-12-08T18:43:07.967Z"}}, {"model": "python_problems.solution", "pk": 269, "fields": {"problem": 144, "language": 1, "owner": 3, "solution": "# blueprint\r\n# \"111000\" numbers\r\n# \"010101\" target A\r\n# \"101010\" target B\r\n\r\n# \"111000111000\" numbers\r\n# \"010101010101\" target A\r\n# \"101010101010\" target B\r\n\r\n# O(n), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def minFlips(self, numbers: str) -> int:\r\n        left = 0\r\n        double_numbers = numbers * 2  # double the numbers length\r\n        zero = \"01\" * len(numbers)  # target string A \"0101...\"\r\n        one = \"10\" * len(numbers)  # target string B \"1010...\"\r\n        flip_a = 0  # count numbers to flip to get current tagret A in a loop\r\n        flip_b = 0  # count numbers to flip to get current tagret B in a loop\r\n        min_flip_a = len(numbers)  # minimum flips to get the best matching target A\r\n        min_flip_b = len(numbers)  # minimum flips to get the best matching target B\r\n\r\n\r\n        for right, number in enumerate(double_numbers):\r\n            # if no match increase the flip counter\r\n            if number != zero[right]:\r\n                flip_a += 1\r\n            if number != one[right]:\r\n                flip_b += 1\r\n\r\n            # if the window is the right length\r\n            if right - left + 1 == len(numbers):\r\n                min_flip_a = min(min_flip_a, flip_a)\r\n                min_flip_b = min(min_flip_b, flip_b)\r\n\r\n                # early exit when any of min flips is zero\r\n                if not min_flip_a or not min_flip_b:\r\n                    return 0\r\n\r\n                # if no match decrease the flip counter\r\n                if double_numbers[left] != zero[left]:\r\n                    flip_a -= 1\r\n                if double_numbers[left] != one[left]:\r\n                    flip_b -= 1\r\n\r\n                left += 1\r\n\r\n        return min(min_flip_a, min_flip_b)\r\n\r\n\r\n# O(n2), O(n)\r\n# brute force\r\nclass Solution:\r\n    def minFlips(self, numbers: str) -> int:\r\n        min_flip_a = len(numbers)\r\n        min_flip_b = len(numbers)\r\n        \r\n        target_a = \"\".join(str(i % 2) \r\n                           for i in range(len(numbers)))\r\n        target_b = \"\".join(str((i + 1) % 2) \r\n                           for i in range(len(numbers)))\r\n\r\n        for _ in range(len(numbers)):\r\n            numbers = numbers[1:] + numbers[0]\r\n            flip_a = 0\r\n            flip_b = 0\r\n\r\n            for index, number in enumerate(numbers):\r\n                if number != target_a[index]:\r\n                    flip_a += 1\r\n\r\n                if number != target_b[index]:\r\n                    flip_b += 1\r\n\r\n            min_flip_a = min(min_flip_a, flip_a)\r\n            min_flip_b = min(min_flip_b, flip_b)\r\n        \r\n        return min(min_flip_a, min_flip_b)", "testcase": "print(Solution().minFlips(\"111000\"), 2)\r\nprint(Solution().minFlips(\"010\"), 0)\r\nprint(Solution().minFlips(\"1110\"), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-08T23:37:15.512Z", "updated_at": "2025-02-03T00:44:24.215Z"}}, {"model": "python_problems.solution", "pk": 270, "fields": {"problem": 144, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * sliding window\r\n * @param {string} numbers\r\n * @return {number}\r\n */\r\nvar minFlips = function (numbers) {\r\n  let left = 0\r\n  const targetA = '01'.repeat(numbers.length);\r\n  const targetB = '10'.repeat(numbers.length);\r\n  const doubleNumbers = numbers.repeat(2);\r\n  let flipA = 0;\r\n  let flipB = 0;\r\n  let minFlipA = numbers.length;\r\n  let minFlipB = numbers.length;\r\n  \r\n  for (let right = 0; right < doubleNumbers.length; right++) {\r\n      const number = doubleNumbers[right];\r\n\r\n      if (number !== targetA[right]) flipA++;\r\n      if (number !== targetB[right]) flipB++;\r\n\r\n      if (right - left + 1 === numbers.length) {\r\n          minFlipA = Math.min(minFlipA, flipA);\r\n          minFlipB = Math.min(minFlipB, flipB);\r\n\r\n          if (minFlipA === 0 || minFlipB === 0) return 0\r\n\r\n          if (doubleNumbers[left] !== targetA[left]) flipA--;\r\n          if (doubleNumbers[left] !== targetB[left]) flipB--;\r\n\r\n          left++;\r\n      }\r\n  }\r\n\r\n  return Math.min(minFlipA, minFlipB)\r\n}", "testcase": "console.log(minFlips(\"111000\"), 2)\r\nconsole.log(minFlips(\"010\"), 0)\r\nconsole.log(minFlips(\"1110\"), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-09T00:42:10.831Z", "updated_at": "2024-12-09T00:42:10.851Z"}}, {"model": "python_problems.solution", "pk": 271, "fields": {"problem": 145, "language": 1, "owner": 3, "solution": "# draft\r\n# 100\r\n# 100, 80\r\n# 100, 80, 60\r\n# 100(0), 80(1), <- 70(ind = 2)\r\n# 100, 80, 70(2), 60(4)\r\n\r\n\r\n# O(n), O(n)\r\n# stack, monotonic stack\r\n# monotonically decreasing stack\r\nclass StockSpanner:\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.index = 0  # index of the current number\r\n\r\n    def next(self, price: int) -> int:\r\n        days_of_lower = 0  # consecutive days for which the stock price was less than or equal to the price of that day\r\n        index = self.index\r\n        \r\n        while self.stack and self.stack[-1][1] <= price:  # check while top stack price is lower equal to curent price\r\n            index, _ = self.stack.pop()  # get index of popped price\r\n            days_of_lower = self.index - index  # update days\r\n\r\n        self.stack.append((min(index, self.index), price))  # use current index or lower index for last popped price\r\n        self.index += 1  # update index\r\n\r\n        return days_of_lower + 1  # increase `1` to count current day\r\n\r\n\r\n# O(n), O(n)\r\n# stack\r\nclass StockSpanner:\r\n    def __init__(self):\r\n        self.prices = []  # (price, counter)\r\n\r\n    def next(self, price: int) -> int:\r\n        counter = 1  # counts the same or lower prices as the price\r\n        right = len(self.prices) - 1  # the top of the stack index\r\n\r\n        while (right >= 0 and  # while index in bounds and\r\n               price >= self.prices[-1][0]):  # price higher of equal to the price of the top of the stack\r\n            _, current_counter = self.prices.pop()  # pop that price and get counter\r\n            counter += current_counter  # increase the counter\r\n            right -= 1  # decrease index\r\n\r\n        self.prices.append((price, counter))  # add (price, counter)\r\n\r\n        return counter\r\n\r\n\r\n# O(n2), O(n)\r\n# brute force\r\nclass StockSpanner:\r\n    def __init__(self):\r\n        self.prices = []\r\n\r\n    def next(self, price: int) -> int:\r\n        self.prices.append(price)\r\n        counter = 0\r\n\r\n        for current_price in reversed(self.prices):\r\n            if price < current_price:\r\n                break\r\n\r\n            counter += 1\r\n\r\n        return counter\r\n\r\n\r\n# O(n2), O(n)\r\n# brute force\r\nclass StockSpanner:\r\n    def __init__(self):\r\n        self.prices = []\r\n\r\n    def next(self, price: int) -> int:\r\n        self.prices.append(price)\r\n        counter = 0\r\n        right = len(self.prices) - 1\r\n\r\n        while (right >= 0 and\r\n               price >= self.prices[right]):\r\n            counter += 1\r\n            right -= 1\r\n\r\n        return counter", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-09T19:55:44.723Z", "updated_at": "2025-02-07T22:38:25.418Z"}}, {"model": "python_problems.solution", "pk": 272, "fields": {"problem": 145, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(n)\r\n * stack\r\n */\r\nclass StockSpanner {\r\n  constructor() {\r\n    this.prices = [];  // [price, counter]\r\n  }\r\n\r\n  /**\r\n   * @param {number} price\r\n   * @return {number}\r\n   */\r\n  next(price) {\r\n    let right = this.prices.length - 1;\r\n    let counter = 1;\r\n\r\n    while (\r\n      right >= 0 &&\r\n      price >= this.prices[this.prices.length - 1][0]\r\n    ) {\r\n      const [_, currentCounter] = this.prices.pop()\r\n      counter += currentCounter;\r\n      right--;\r\n    }\r\n\r\n    this.prices.push([price, counter]);\r\n\r\n    return counter;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Your StockSpanner object will be instantiated and called as such:\r\n * var obj = new StockSpanner()\r\n * var param_1 = obj.next(price)\r\n */\r\n\r\nvar StockSpannerObj = new StockSpanner()\r\nconsole.log(StockSpannerObj.next(100))\r\nconsole.log(StockSpannerObj.next(80))\r\nconsole.log(StockSpannerObj.next(60))\r\nconsole.log(StockSpannerObj.next(70))\r\n\r\n\r\n\r\n/**\r\n * O(n2), O(n)\r\n * brute force\r\n */\r\nclass StockSpanner {\r\n  constructor() {\r\n    this.prices = [];\r\n  }\r\n  \r\n  /**\r\n   * @param {number} price\r\n   * @return {number}\r\n   */\r\n  next(price) {\r\n    this.prices.push(price);\r\n    let counter = 0;\r\n\r\n    for (const currentPrice of this.prices.slice().reverse()) {\r\n      if (price >= currentPrice) {\r\n        counter++;\r\n      } else break;\r\n    }\r\n\r\n    return counter;\r\n  }\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-09T19:56:16.671Z", "updated_at": "2024-12-09T19:56:16.689Z"}}, {"model": "python_problems.solution", "pk": 273, "fields": {"problem": 146, "language": 1, "owner": 3, "solution": "# O(logn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def isPerfectSquare(self, number: int) -> bool:\r\n        left = 0\r\n        right = number\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n            square = middle ** 2\r\n\r\n            if square == number:\r\n                return True\r\n            elif square > number:\r\n                right = middle - 1\r\n            else:\r\n                left = middle + 1\r\n\r\n        return False", "testcase": "print(Solution().isPerfectSquare(16), True)\r\nprint(Solution().isPerfectSquare(14), False)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-12-09T23:08:50.502Z", "updated_at": "2024-12-09T23:10:05.948Z"}}, {"model": "python_problems.solution", "pk": 274, "fields": {"problem": 146, "language": 2, "owner": 3, "solution": "/**\r\n * O(logn), O(1)\r\n * binary search\r\n * @param {number} number\r\n * @return {boolean}\r\n */\r\nvar isPerfectSquare = function (number) {\r\n  let left = 0;\r\n  let right = number;\r\n\r\n  while (left <= right) {\r\n    const middle = (left + right) / 2 | 0;\r\n\r\n    if (middle ** 2 === number) return true\r\n    else if (middle ** 2 > number) {\r\n      right = middle - 1;\r\n    } else left = middle + 1;\r\n  }\r\n\r\n  return false\r\n}", "testcase": "console.log(isPerfectSquare(16), true)\r\nconsole.log(isPerfectSquare(14), false)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-12-09T23:16:53.056Z", "updated_at": "2024-12-09T23:16:53.076Z"}}, {"model": "python_problems.solution", "pk": 275, "fields": {"problem": 147, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * O(n), O(1)\r\n * linked list\r\n * @param {ListNode} head1\r\n * @param {number} a\r\n * @param {number} b\r\n * @param {ListNode} head2\r\n * @return {ListNode}\r\n */\r\nvar mergeInBetween = function (head1, a, b, head2) {\r\n  let node = head1;\r\n  let counter = 0;\r\n  let start = node;\r\n\r\n  while (counter !== b + 1) {\r\n    if (counter === a - 1) {\r\n      start = node;\r\n    }\r\n\r\n    counter++;\r\n    node = node.next;\r\n  }\r\n\r\n  start.next = head2;\r\n  while (head2.next) head2 = head2.next;\r\n  head2.next = node;\r\n\r\n  return head1\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-10T01:34:38.554Z", "updated_at": "2024-12-10T01:34:38.571Z"}}, {"model": "python_problems.solution", "pk": 276, "fields": {"problem": 147, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# linked list\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def mergeInBetween(self, head1: ListNode, a: int, b: int, head2: ListNode) -> ListNode:\r\n        node = ListNode(0, head1)\r\n        counter = 0\r\n\r\n        while counter - 1 != b: # 0!=5,\r\n            if counter == a: # 0==3,\r\n                start = node  # node before start # start = 6\r\n\r\n            counter += 1  # 1, 2, 3, 4\r\n            node = node.next  # 10, 1, 13, 6\r\n        \r\n        end = node  # node before end  # 9\r\n\r\n        start.next = head2  # inject head2 after start\r\n\r\n        while head2.next:  # find the end of the inserted list\r\n            head2 = head2.next  # node points to the element before None # 1000002\r\n\r\n        head2.next = end.next  # switch end in list2\r\n\r\n        return head1\r\n\r\nnodeA5 = ListNode(5)\r\nnodeA4 = ListNode(9, nodeA5)\r\nnodeA3 = ListNode(6, nodeA4)\r\nnodeA2 = ListNode(13, nodeA3)\r\nnodeA1 = ListNode(1, nodeA2)\r\nnodeA0 = ListNode(10, nodeA1)\r\n\r\nnodeB2 = ListNode(1000002)\r\nnodeB1 = ListNode(1000001, nodeB2)\r\nnodeB0 = ListNode(1000000, nodeB1)\r\n\r\nprint(Solution().mergeInBetween(nodeA0, 3, 4, nodeB0))", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-10T01:36:06.655Z", "updated_at": "2024-12-10T01:36:06.672Z"}}, {"model": "python_problems.solution", "pk": 277, "fields": {"problem": 148, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# stack\r\nclass Solution:\r\n    def nextGreaterElement(self, numbers1: list[int], numbers2: list[int]) -> list[int]:\r\n        next_greater = [-1] * len(numbers1)\r\n        stack = []\r\n        numbers1_index = {number: index\r\n                          for index, number in enumerate(numbers1)}\r\n\r\n        for number in numbers2:\r\n            while stack and number > stack[-1]:\r\n                value = stack.pop()\r\n                index = numbers1_index[value]\r\n                next_greater[index] = number\r\n\r\n            if number in numbers1_index:\r\n                stack.append(number)\r\n\r\n        return next_greater\r\n\r\n\r\n# O(n2), O(1)\r\n# brute force\r\nclass Solution:\r\n    def nextGreaterElement(self, numbers1: list[int], numbers2: list[int]) -> list[int]:\r\n        next_greater = [-1] * len(numbers1)\r\n\r\n        for index, number in enumerate(numbers1):\r\n            next_right = numbers2.index(number) + 1\r\n\r\n            for index_right in range(next_right, len(numbers2)):\r\n                if numbers2[index_right] > number:\r\n                    next_greater[index] = numbers2[index_right]\r\n                    break\r\n\r\n        return next_greater", "testcase": "print(Solution().nextGreaterElement([4, 1, 2], [1, 3, 4, 2]), [-1, 3, -1])\r\nprint(Solution().nextGreaterElement([2, 4], [1, 2, 3, 4]), [3, -1])\r\nprint(Solution().nextGreaterElement([1, 3, 5, 2, 4], [6, 5, 4, 3, 2, 1, 7]), [7, 7, 7, 7, 7])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-10T21:28:12.585Z", "updated_at": "2024-12-10T21:28:12.607Z"}}, {"model": "python_problems.solution", "pk": 278, "fields": {"problem": 148, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * stack\r\n * @param {number[]} numbers1\r\n * @param {number[]} numbers2\r\n * @return {number[]}\r\n */\r\nvar nextGreaterElement = function (numbers1, numbers2) {\r\n  const numbers1Index = new Map(numbers1.map((number, index) => [number, index]));\r\n  const stack = [];\r\n  const nextGreater = new Array(numbers1.length).fill(-1);\r\n\r\n  for (const number of numbers2) {\r\n    while (number > stack[stack.length - 1]) {\r\n      const value = stack.pop();\r\n      const index = numbers1Index.get(value);\r\n      nextGreater[index] = number;\r\n    }\r\n    \r\n    if (numbers1Index.has(number)) {\r\n      stack.push(number);\r\n    }\r\n  }\r\n  return nextGreater\r\n}", "testcase": "console.log(nextGreaterElement([4, 1, 2], [1, 3, 4, 2]), [-1, 3, -1])\r\nconsole.log(nextGreaterElement([2, 4], [1, 2, 3, 4]), [3, -1])\r\nconsole.log(nextGreaterElement([1, 3, 5, 2, 4], [6, 5, 4, 3, 2, 1, 7]), [7, 7, 7, 7, 7])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-10T21:51:23.783Z", "updated_at": "2024-12-10T21:51:23.804Z"}}, {"model": "python_problems.solution", "pk": 279, "fields": {"problem": 149, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# sliding window\r\nclass Solution:\r\n    def minSubArrayLen(self, target: int, numbers: list[int]) -> int:\r\n        left = 0\r\n        window_sum = 0\r\n        window_size = len(numbers) + 1\r\n\r\n        for right, number in enumerate(numbers):\r\n            window_sum += number\r\n\r\n            while window_sum >= target:\r\n                window_size = min(window_size, right - left + 1)\r\n                window_sum -= numbers[left]\r\n                left += 1\r\n\r\n        return window_size if window_size != len(numbers) + 1 else 0", "testcase": "print(Solution().minSubArrayLen(7, [2, 3, 1, 2, 4, 3]), 2)\r\nprint(Solution().minSubArrayLen(4, [1, 4, 4]), 1)\r\nprint(Solution().minSubArrayLen(11, [1, 1, 1, 1, 1, 1, 1, 1]), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-12T16:13:05.990Z", "updated_at": "2024-12-12T16:13:06.010Z"}}, {"model": "python_problems.solution", "pk": 280, "fields": {"problem": 149, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * sliding window\r\n * @param {number} target\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar minSubArrayLen = function (target, numbers) {\r\n  let left = 0;\r\n  let windowSum = 0;\r\n  let windowLength = numbers.length + 1;\r\n\r\n  for (let right = 0; right <= numbers.length; right++) {\r\n    const number = numbers[right];\r\n    windowSum += number;\r\n\r\n    while (windowSum >= target) {\r\n      windowLength = Math.min(windowLength, right - left + 1);\r\n      windowSum -= numbers[left];\r\n      left++;\r\n    }\r\n  }\r\n\r\n  return windowLength === numbers.length + 1 ? 0 : windowLength\r\n}", "testcase": "console.log(minSubArrayLen(7, [2, 3, 1, 2, 4, 3]), 2)\r\nconsole.log(minSubArrayLen(4, [1, 4, 4]), 1)\r\nconsole.log(minSubArrayLen(11, [1, 1, 1, 1, 1, 1, 1, 1]), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-12T16:13:52.444Z", "updated_at": "2024-12-12T16:13:52.463Z"}}, {"model": "python_problems.solution", "pk": 281, "fields": {"problem": 150, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def clean_str_right(self, right, text):\r\n        joker = 0\r\n\r\n        while (right >= 0 and \r\n               (text[right] == \"#\" or joker)):\r\n            if text[right] == \"#\":\r\n                joker += 1\r\n            else:\r\n                joker -= 1\r\n            right -= 1\r\n        \r\n        return right\r\n\r\n    def backspaceCompare(self, text1: str, text2: str) -> bool:\r\n        right1 = len(text1) - 1\r\n        right2 = len(text2) - 1\r\n        \r\n        while right1 >= 0 and right2 >= 0:\r\n            right1 = self.clean_str_right(right1, text1)\r\n            right2 = self.clean_str_right(right2, text2)\r\n\r\n            if right1 == -1 and right2 == - 1:\r\n                return True\r\n\r\n            if text1[right1] != text2[right2]:\r\n                return False\r\n            \r\n            right1 -= 1\r\n            right2 -= 1\r\n\r\n        if right1 >= 0:\r\n            right1 = self.clean_str_right(right1, text1)\r\n        if right2 >= 0:\r\n            right2 = self.clean_str_right(right2, text2)\r\n        \r\n        return right1 == right2\r\n\r\n\r\n# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def clean_text(self, text):\r\n        stack = []\r\n        \r\n        for letter in text:\r\n            if letter == \"#\":\r\n                stack and stack.pop()\r\n            else:\r\n                stack.append(letter)\r\n        \r\n        return \"\".join(stack)\r\n\r\n    def backspaceCompare(self, text1: str, text2: str) -> bool:\r\n        text1_clean = self.clean_text(text1)\r\n        text2_clean = self.clean_text(text2)\r\n\r\n        return text1_clean == text2_clean", "testcase": "print(Solution().backspaceCompare(\"ab#c\", \"ad#c\"), True)\r\nprint(Solution().backspaceCompare(\"ab##\", \"c#d#\"), True)\r\nprint(Solution().backspaceCompare(\"a#c\", \"b\"), False)\r\nprint(Solution().backspaceCompare(\"xywrrmp\", \"xywrrmu#p\"), True)\r\nprint(Solution().backspaceCompare(\"nzp#o#g\", \"b#nzp#o#g\"), True)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-12T17:06:54.469Z", "updated_at": "2024-12-12T17:06:54.495Z"}}, {"model": "python_problems.solution", "pk": 282, "fields": {"problem": 150, "language": 2, "owner": 3, "solution": "function nextValidChar(index, text) {\r\n  let joker = 0;\r\n\r\n  while (index >= 0 && (text[index] == '#' || joker)) {\r\n    text[index] == '#' ? joker++ : joker--;\r\n    index--;\r\n  }\r\n\r\n  return index\r\n}\r\n\r\n/**\r\n * O(n), O(1)\r\n * two pointers\r\n * @param {string} text1\r\n * @param {string} text2\r\n * @return {boolean}\r\n */\r\nvar backspaceCompare = function (text1, text2) {\r\n  let index1 = text1.length - 1;\r\n  let index2 = text2.length - 1;\r\n\r\n  while (index1 >= 0 && index2 >= 0) {\r\n    index1 = nextValidChar(index1, text1);\r\n    index2 = nextValidChar(index2, text2);\r\n\r\n    if (text1[index1] !== text2[index2]) return false\r\n\r\n    if (index1 === 0 && index2 === 0) return true\r\n\r\n    index1--;\r\n    index2--;\r\n  }\r\n  return nextValidChar(index1, text1) === nextValidChar(index2, text2)\r\n}", "testcase": "console.log(backspaceCompare(\"ab#c\", \"ad#c\"), true)\r\nconsole.log(backspaceCompare(\"ab##\", \"c#d#\"), true)\r\nconsole.log(backspaceCompare(\"a#c\", \"b\"), false)\r\nconsole.log(backspaceCompare(\"xywrrmp\", \"xywrrmu#p\"), true)\r\nconsole.log(backspaceCompare(\"nzp#o#g\", \"b#nzp#o#g\"), true)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-12T22:09:31.909Z", "updated_at": "2024-12-12T22:09:31.930Z"}}, {"model": "python_problems.solution", "pk": 283, "fields": {"problem": 151, "language": 1, "owner": 3, "solution": "# lRUCache = LRUCache(2)\r\n# lRUCache.put(1, 1)  # cache is {1=1}\r\n# lRUCache.put(2, 2)  # cache is {1=1, 2=2}\r\n# lRUCache.get(1)    # return 1\r\n# lRUCache.put(3, 3)  # LRU key was 2, evicts key 2, cache is {1=1, 3=3}\r\n# lRUCache.get(2)    # returns -1 (not found)\r\n# lRUCache.put(4, 4)  # LRU key was 1, evicts key 1, cache is {4=4, 3=3}\r\n# lRUCache.get(1)    # return -1 (not found)\r\n# lRUCache.get(3)    # return 3\r\n# lRUCache.get(4)    # return 4\r\n\r\n# lRUCache = LRUCache(2)\r\n# lRUCache.get(2)  # -1\r\n# lRUCache.put(2, 6)\r\n# lRUCache.get(1)  # -1\r\n# lRUCache.put(1, 5)\r\n# lRUCache.put(1, 2)\r\n# lRUCache.get(1)  # 2\r\n# lRUCache.get(2)  # 6\r\n\r\nlRUCache = LRUCache(2)\r\nlRUCache.put(2, 1)\r\nlRUCache.put(1, 1)\r\nlRUCache.put(2, 3)\r\nlRUCache.put(4, 1)\r\nlRUCache.get(1)  # -1\r\nlRUCache.get(2)  # 3\r\n\r\n\r\n# O(1), O(n)\r\n# Built-In Data Structure\r\nfrom collections import OrderedDict\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.cache = OrderedDict()\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            # Move the accessed key to the end to mark it as recently used\r\n            self.cache.move_to_end(key)\r\n            \r\n            return self.cache[key]\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            # Update the value and mark as recently used\r\n            self.cache.move_to_end(key)\r\n        elif self.capacity:\r\n            # reduce capacity\r\n            self.capacity -= 1\r\n        else:\r\n            # Pop the least recently used item (first item)\r\n            self.cache.popitem(last=False)\r\n\r\n        # Insert or update the key-value pair\r\n        self.cache[key] = value\r\n\r\n\r\n# O(1), O(n)\r\n# Double Linked List\r\nclass Node:\r\n    def __init__(self, key=0, value=0, next=None, prev=None) -> None:\r\n        self.key = key\r\n        self.value = value\r\n        self.next = next\r\n        self.prev = prev\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int) -> None:\r\n        self.capacity = capacity\r\n        self.cache = {}\r\n        self.first = Node()\r\n        self.last = Node()\r\n        self.first.next = self.last\r\n        self.last.prev = self.first\r\n\r\n\r\n    def push_node(self, node: Node) -> None:\r\n        prev = self.last.prev\r\n        next = self.last\r\n        prev.next = node\r\n        next.prev = node\r\n        node.prev = prev\r\n        node.next = next\r\n\r\n\r\n    def pop_node(self, node: Node) -> None:\r\n        node.prev.next, node.next.prev = node.next, node.prev\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            node = self.cache[key]\r\n            self.pop_node(node)\r\n            self.push_node(node)\r\n\r\n            return node.value\r\n        else:\r\n            return -1\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            self.pop_node(self.cache[key])\r\n        elif self.capacity:\r\n            self.capacity -= 1\r\n        else:\r\n            lru = self.first.next\r\n            self.pop_node(lru)\r\n            self.cache.pop(lru.key)\r\n\r\n        node = Node(key, value)\r\n        self.cache[key] = node\r\n        self.push_node(node)\r\n\r\n\r\n# O(1), O(n)\r\n# three dicts (cache, {key: index}, {index: key})\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.cache = {}  # {key: value}\r\n        self.index = 0  # in which iteration key has been modified/added\r\n        self.key_index = {}  # {key: index}\r\n        self.index_key = {}  # {index: key}\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.cache:\r\n            self.index_key.pop(self.key_index[key])  # pop least recent index_key element\r\n            self.key_index[key] = self.index  # update key_index with a new index\r\n            self.index_key[self.index] = key  # update new index_key with a key\r\n            self.index += 1  # increase index\r\n            return self.cache[key]\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:  # if key in cache\r\n            self.cache[key] = value  # add new key, value pair to cache\r\n            \r\n            # when updating the key with max index no need to update index\r\n            if self.key_index[key] != self.index:\r\n                self.index_key.pop(self.key_index[key])  # pop least recent index_key element\r\n                self.key_index[key] = self.index  # update key_index with a new index\r\n                self.index_key[self.index] = key  # update new index_key with a key\r\n                self.index += 1  # increase index\r\n        elif self.capacity:  # there it capacity for another key\r\n            self.capacity -= 1  # decrease capacity\r\n            self.cache[key] = value  # add new key, value pair to cache\r\n            self.key_index[key] = self.index  # update key_index with a new index\r\n            self.index_key[self.index] = key  # update new index_key with a key\r\n            self.index += 1  # increase index\r\n        else:  # no capacity for new key\r\n            min_index = next(iter(self.index_key))  # indexes are in ascending order but are not contiguous\r\n            min_key = self.index_key[min_index]  # key to the lowest index\r\n            self.cache.pop(min_key)  # pop key with the lowest index\r\n            self.key_index.pop(min_key)  # pop key with the lowest index\r\n            self.index_key.pop(min_index)  # pop lowest index from index_key\r\n\r\n            self.cache[key] = value  # add new key, value pair to cache\r\n            self.key_index[key] = self.index  # update key_index with a new index\r\n            self.index_key[self.index] = key  # update new index_key with a key\r\n            self.index += 1  # increase index", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-12-13T00:03:13.494Z", "updated_at": "2024-12-13T00:03:13.513Z"}}, {"model": "python_problems.solution", "pk": 284, "fields": {"problem": 151, "language": 2, "owner": 3, "solution": "class Node {\r\n  constructor(key = 0, value = 0, prev = null, next = null) {\r\n    this.key = key;\r\n    this.value = value;\r\n    this.prev = prev;\r\n    this.next = next;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n  this.capacity = capacity;\r\n  this.cache = new Map();\r\n  this.first = new Node();\r\n  this.last = new Node();\r\n  this.first.next = this.last;\r\n  this.last.prev = this.first;\r\n\r\n  this.remove = (node) => {\r\n    const prev = node.prev;\r\n    const next = node.next;\r\n    prev.next = next;\r\n    next.prev = prev;\r\n  }\r\n\r\n  this.insert = function (node) {\r\n    const prev = this.last.prev;\r\n    const next = this.last;\r\n    prev.next = node;\r\n    next.prev = node;\r\n    node.prev = prev;\r\n    node.next = next;\r\n  }\r\n}\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n  if (this.cache.has(key)) {\r\n    this.remove(this.cache.get(key));\r\n    this.insert(this.cache.get(key));\r\n    return this.cache.get(key).value\r\n  } else return -1\r\n}\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n  if (this.cache.has(key)) {\r\n    this.remove(this.cache.get(key));\r\n  } else if (this.capacity) {\r\n    this.capacity--;\r\n  } else {\r\n    const lru = this.first.next;\r\n    this.remove(lru);\r\n    this.cache.delete(lru.key);\r\n  }\r\n\r\n  const node = new Node(key, value);\r\n  this.cache.set(key, node);\r\n  this.insert(node);\r\n}\r\n\r\n/** \r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\nconst lRUCache = new LRUCache(2)\r\nlRUCache.put(2, 1)\r\nlRUCache.put(1, 1)\r\nlRUCache.put(2, 3)\r\nlRUCache.put(4, 1)\r\nconsole.log(lRUCache.get(1))  // -1\r\nconsole.log(lRUCache.get(2))  // 3", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-12-13T00:04:01.863Z", "updated_at": "2024-12-13T00:04:01.883Z"}}, {"model": "python_problems.solution", "pk": 285, "fields": {"problem": 152, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# prefix sum\r\nclass Solution:\r\n    def pivotIndex(self, numbers: list[int]) -> int:\r\n        right_sum = sum(numbers)\r\n        left_sum = 0\r\n\r\n        for index, number in enumerate(numbers):\r\n            right_sum -= number\r\n            left_sum += numbers[index - 1] if index else 0\r\n\r\n            if left_sum == right_sum:\r\n                return index\r\n\r\n        return -1", "testcase": "print(Solution().pivotIndex([1, 7, 3, 6, 5, 6]), 3)\r\nprint(Solution().pivotIndex([1, 2, 3]), -1)\r\nprint(Solution().pivotIndex([2, 1, -1]), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-13T01:31:01.623Z", "updated_at": "2024-12-13T01:31:01.643Z"}}, {"model": "python_problems.solution", "pk": 286, "fields": {"problem": 152, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * prefix sum\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar pivotIndex = function (numbers) {\r\n  let rightSum = numbers.reduce((total, current) => total + current);\r\n  let leftSum = 0;\r\n\r\n  for (let index = 0; index <= numbers.length; index++) {\r\n    const number = numbers[index];\r\n    rightSum -= number;\r\n    leftSum += index === 0 ? 0 : numbers[index - 1];\r\n\r\n    if (leftSum === rightSum) return index\r\n\r\n  }\r\n  return -1\r\n}", "testcase": "console.log(pivotIndex([1, 7, 3, 6, 5, 6]), 3)\r\nconsole.log(pivotIndex([1, 2, 3]), -1)\r\nconsole.log(pivotIndex([2, 1, -1]), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-13T01:31:45.889Z", "updated_at": "2024-12-13T01:31:45.910Z"}}, {"model": "python_problems.solution", "pk": 287, "fields": {"problem": 153, "language": 1, "owner": 3, "solution": "# O(1), O(n)\r\n# prefix sum\r\nclass NumArray:\r\n    def __init__(self, numbers: list[int]):\r\n        prefix = 0\r\n        self.numbers = []\r\n\r\n        for number in numbers:\r\n            prefix += number\r\n            self.prefixes.append(prefix)\r\n\r\n    def sumRange(self, left: int, right: int) -> int:\r\n        if not left:\r\n            return self.prefixes[right]\r\n        else:\r\n            return self.prefixes[right] - self.prefixes[left - 1]\r\n\r\n\r\n# O(n), O(1)\r\nclass NumArray:\r\n    def __init__(self, numbers: list[int]):\r\n        self.numbers = numbers\r\n\r\n    def sumRange(self, left: int, right: int) -> int:\r\n        return sum(self.numbers[left: right + 1])\r\n\r\n# Your NumArray object will be instantiated and called as such:\r\n# obj = NumArray(numbers)\r\n# param_1 = obj.sumRange(left,right)", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-12-16T01:09:21.542Z", "updated_at": "2024-12-16T01:09:21.564Z"}}, {"model": "python_problems.solution", "pk": 288, "fields": {"problem": 153, "language": 2, "owner": 3, "solution": "/**\r\n   * # O(1), O(n)\r\n   * prefix sum\r\n   */\r\nclass NumArray {\r\n  /**\r\n   * @param {number[]} numbers\r\n   */\r\n  constructor(numbers) {\r\n    this.prefixes = [];\r\n    let prefix = 0;\r\n\r\n    for (const number of numbers) {\r\n      prefix += number;\r\n      this.prefixes.push(prefix);\r\n    }\r\n  }\r\n  /**\r\n   * @param {number} left\r\n   * @param {number} right\r\n   * @return {number}\r\n   */\r\n  sumRange(left, right) {\r\n    if (left) return this.prefixes[right] - this.prefixes[left - 1];\r\n    else return this.prefixes[right];\r\n  }\r\n}\r\n\r\n\r\n/** \r\n * Your NumArray object will be instantiated and called as such:\r\n * var obj = new NumArray(nums)\r\n * var param_1 = obj.sumRange(left,right)\r\n */\r\n\r\n\r\n/**\r\n * O(n), O(1)\r\n */\r\n/**\r\n * @param {number[]} numbers\r\n */\r\nvar NumArray = function (numbers) {\r\n  this.numbers = numbers;\r\n}\r\n\r\n/** \r\n * @param {number} left \r\n * @param {number} right\r\n * @return {number}\r\n */\r\nNumArray.prototype.sumRange = function (left, right) {\r\n  return (\r\n    this.numbers.\r\n      slice(left, right + 1).\r\n      reduce((total, current) => total + current)\r\n  )\r\n}", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-12-16T01:09:48.538Z", "updated_at": "2024-12-16T01:09:48.558Z"}}, {"model": "python_problems.solution", "pk": 289, "fields": {"problem": 154, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# build-in function\r\nclass Solution:\r\n    def arrayStringsAreEqual(self, words1: list[str], words2: list[str]) -> bool:\r\n        return \"\".join(words1) == \"\".join(words2)\r\n\r\n\r\n# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def arrayStringsAreEqual(self, words1: list[str], words2: list[str]) -> bool:\r\n        index_word1 = 0  # index for a word\r\n        index_word2 = 0\r\n        index_letter1 = 0  # index for a letter in the word\r\n        index_letter2 = 0\r\n\r\n        while (index_word1 < len(words1) and \r\n               index_word2 < len(words2)):\r\n            if words1[index_word1][index_letter1] != words2[index_word2][index_letter2]:\r\n                return False\r\n\r\n            index_letter1 += 1  # get next letter index\r\n            index_letter2 += 1\r\n\r\n            # if end of the word reached\r\n            if index_letter1 == len(words1[index_word1]):\r\n                index_letter1 = 0  # zero the letter index\r\n                index_word1 += 1  # get next word index\r\n\r\n            if index_letter2 == len(words2[index_word2]):\r\n                index_letter2 = 0\r\n                index_word2 += 1\r\n\r\n        # both index_word have to get out of bounds to strings to be equal\r\n        return (index_word1 == len(words1) and\r\n                index_word2 == len(words2))", "testcase": "print(Solution().arrayStringsAreEqual([\"ab\", \"c\"], [\"a\", \"bc\"]), True)\r\nprint(Solution().arrayStringsAreEqual([\"a\", \"cb\"], [\"ab\", \"c\"]), False)\r\nprint(Solution().arrayStringsAreEqual([\"abc\", \"d\", \"defg\"], [\"abcddefg\"]), True)\r\nprint(Solution().arrayStringsAreEqual([\"abc\", \"d\", \"defg\"], [\"abcddef\"]), False)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-16T23:21:48.819Z", "updated_at": "2024-12-16T23:21:48.839Z"}}, {"model": "python_problems.solution", "pk": 290, "fields": {"problem": 154, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * buind-in function\r\n * @param {string[]} words1\r\n * @param {string[]} words2\r\n * @return {boolean}\r\n */\r\nvar arrayStringsAreEqual = function (words1, words2) {\r\n  return words1.join('') == words2.join('')\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(1)\r\n * two pointers\r\n * @param {string[]} words1\r\n * @param {string[]} words2\r\n * @return {boolean}\r\n */\r\nvar arrayStringsAreEqual = function (words1, words2) {\r\n  let indexWord1 = 0;\r\n  let indexWord2 = 0;\r\n  let indexLetter1 = 0;\r\n  let indexLetter2 = 0;\r\n\r\n  while (\r\n    indexWord1 < words1.length &&\r\n    indexWord2 < words2.length\r\n  ) {\r\n    if (words1[indexWord1][indexLetter1] != words2[indexWord2][indexLetter2]) return false\r\n\r\n    indexLetter1++;\r\n    indexLetter2++;\r\n\r\n    if (indexLetter1 == words1[indexWord1].length) {\r\n      indexLetter1 = 0;\r\n      indexWord1++;\r\n    }\r\n    if (indexLetter2 == words2[indexWord2].length) {\r\n      indexLetter2 = 0;\r\n      indexWord2++;\r\n    }\r\n  }\r\n\r\n  return (\r\n    indexWord1 == words1.length &&\r\n    indexWord2 == words2.length\r\n  )\r\n}", "testcase": "console.log(arrayStringsAreEqual(['ab', 'c'], ['a', 'bc']), true)\r\nconsole.log(arrayStringsAreEqual(['a', 'cb'], ['ab', 'c']), false)\r\nconsole.log(arrayStringsAreEqual(['abc', 'd', 'defg'], ['abcddefg']), true)\r\nconsole.log(arrayStringsAreEqual(['abc', 'd', 'defg'], ['abcddef']), false)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-16T23:36:53.854Z", "updated_at": "2024-12-16T23:36:53.873Z"}}, {"model": "python_problems.solution", "pk": 291, "fields": {"problem": 155, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# sliding window\r\nclass Solution:\r\n    def minOperations(self, numbers: list[int], x: int) -> int:\r\n        left = 0\r\n        window_sum = 0\r\n        window_max_length = len(numbers) + 1  # minimum operations to reduce\r\n        target = sum(numbers) - x\r\n\r\n        for right, number in enumerate(numbers):\r\n            window_sum += number\r\n\r\n            while (left <= right and  # left in bounds and\r\n                   window_sum > target):  # window sum is too large\r\n                window_sum -= numbers[left]\r\n                left += 1\r\n\r\n            if window_sum == target:\r\n                window_max_length = min(window_max_length, \r\n                                        len(numbers) - (right - left + 1))\r\n\r\n        return (window_max_length \r\n                if window_max_length != len(numbers) + 1\r\n                else -1)", "testcase": "print(Solution().minOperations([1, 1, 4, 2, 3], 5), 2)\r\nprint(Solution().minOperations([5, 6, 7, 8, 9], 4), -1)\r\nprint(Solution().minOperations([3, 2, 20, 1, 1, 3], 10), 5)\r\nprint(Solution().minOperations([5, 2, 3, 1, 1], 5), 1)\r\nprint(Solution().minOperations([8828, 9581, 49, 9818, 9974, 9869, 9991, 10000, 10000, 10000, 9999, 9993, 9904, 8819, 1231, 6309], 134365), 16)\r\nprint(Solution().minOperations([1, 1], 3), -1)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-17T20:14:46.174Z", "updated_at": "2025-02-03T23:34:48.998Z"}}, {"model": "python_problems.solution", "pk": 292, "fields": {"problem": 155, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * sliding window\r\n * @param {number[]} numbers\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nvar minOperations = function (numbers, x) {\r\n  let windowLength = numbers.length + 1;\r\n  let windowSum = 0;\r\n  let left = 0;\r\n  const target = numbers.reduce((total, current) => total + current) - x\r\n\r\n  for (let right = 0; right < numbers.length; right++) {\r\n    const number = numbers[right];\r\n    windowSum += number;\r\n\r\n    while (left <= right && windowSum > target) {\r\n      windowSum -= numbers[left];\r\n      left += 1;\r\n    }\r\n\r\n    if (windowSum == target) {\r\n      windowLength = Math.min(windowLength, numbers.length - (right - left + 1));\r\n    }\r\n  }\r\n\r\n  return windowLength == numbers.length + 1 ? -1 : windowLength\r\n}", "testcase": "console.log(minOperations([1, 1, 4, 2, 3], 5), 2)\r\nconsole.log(minOperations([5, 6, 7, 8, 9], 4), -1)\r\nconsole.log(minOperations([3, 2, 20, 1, 1, 3], 10), 5)\r\nconsole.log(minOperations([5, 2, 3, 1, 1], 5), 1)\r\nconsole.log(minOperations([8828, 9581, 49, 9818, 9974, 9869, 9991, 10000, 10000, 10000, 9999, 9993, 9904, 8819, 1231, 6309], 134365), 16)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-17T20:15:39.301Z", "updated_at": "2024-12-17T20:15:39.320Z"}}, {"model": "python_problems.solution", "pk": 293, "fields": {"problem": 156, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def simplifyPath(self, path: str) -> str:\r\n        stack = []\r\n        cache = \"\"\r\n\r\n        for char in (path + \"/\"):\r\n            if char == \"/\":\r\n                if cache == \"..\":\r\n                    if stack:\r\n                        stack.pop()\r\n                elif cache and cache != \".\":\r\n                    stack.append(cache)\r\n                    \r\n                cache = \"\"\r\n            else:\r\n                cache += char\r\n            \r\n        return \"/\" + \"/\".join(stack)\r\n\r\n            \r\n# O(n), O(n)\r\n# built-in function\r\nclass Solution:\r\n    def simplifyPath(self, path: str) -> str:\r\n        clean_dirs = []\r\n        \r\n        for dir in path.split(\"/\"):\r\n            if not dir or dir == \".\":\r\n                continue\r\n            elif dir == \"..\":\r\n                if clean_dirs:\r\n                    clean_dirs.pop()\r\n            else:\r\n                clean_dirs.append(dir)\r\n        \r\n        return \"/\" + \"/\".join(clean_dirs)", "testcase": "print(Solution().simplifyPath(\"/home/\"), \"/home\")\r\nprint(Solution().simplifyPath(\"/home//foo/\"), \"/home/foo\")\r\nprint(Solution().simplifyPath(\"/home/user/Documents/../Pictures\"), \"/home/user/Pictures\")\r\nprint(Solution().simplifyPath(\"/../\"), \"/\")\r\nprint(Solution().simplifyPath(\"/.../a/../b/c/../d/./\"), \"/.../b/d\")\r\nprint(Solution().simplifyPath(\"/a/../../b/../c//.//\"), \"/c\")\r\nprint(Solution().simplifyPath(\"/.\"), \"/\")\r\nprint(Solution().simplifyPath(\"/..hidden\"), \"/..hidden\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-18T00:38:48.125Z", "updated_at": "2025-02-08T04:15:30.846Z"}}, {"model": "python_problems.solution", "pk": 294, "fields": {"problem": 156, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} path\r\n * @return {string}\r\n */\r\nvar simplifyPath = function (path) {\r\n  const stack = [];\r\n  path += '/';\r\n  let cache = '';\r\n\r\n  for (const char of path) {\r\n    if (char === '/') {\r\n      if (cache == '..') stack.pop()\r\n      else if (cache && cache != '.') stack.push(cache)\r\n      cache = '';\r\n    }\r\n    else cache += char;\r\n  }\r\n\r\n  return '/' + stack.join('/')\r\n}", "testcase": "console.log(simplifyPath(\"/home/\"), \"/home\")\r\nconsole.log(simplifyPath(\"/home//foo/\"), \"/home/foo\")\r\nconsole.log(simplifyPath(\"/home/user/Documents/../Pictures\"), \"/home/user/Pictures\")\r\nconsole.log(simplifyPath(\"/../\"), \"/\")\r\nconsole.log(simplifyPath(\"/.../a/../b/c/../d/./\"), \"/.../b/d\")\r\nconsole.log(simplifyPath(\"/a/../../b/../c//.//\"), \"/c\")\r\nconsole.log(simplifyPath(\"/.\"), \"/\")\r\nconsole.log(simplifyPath(\"/..hidden\"), \"/..hidden\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-18T00:44:44.504Z", "updated_at": "2024-12-18T00:44:44.525Z"}}, {"model": "python_problems.solution", "pk": 295, "fields": {"problem": 157, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def mySqrt(self, x: int) -> int:\r\n        left = 1\r\n        right = x\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n\r\n            if middle ** 2 == x:\r\n                return middle\r\n            elif middle ** 2 > x:\r\n                right = middle - 1\r\n            else:\r\n                left = middle + 1\r\n\r\n        return right", "testcase": "print(Solution().mySqrt(4), 2)\r\nprint(Solution().mySqrt(8), 2)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-12-18T01:34:30.258Z", "updated_at": "2024-12-18T01:34:30.274Z"}}, {"model": "python_problems.solution", "pk": 296, "fields": {"problem": 157, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number} x\r\n * @return {number}\r\n */\r\nvar mySqrt = function (x) {\r\n  let left = 1;\r\n  let right = x;\r\n\r\n  while (left <= right) {\r\n    const middle = (left + right) / 2 | 0;\r\n\r\n    if (middle ** 2 === x) return middle\r\n    else if (middle ** 2 > x) right = middle - 1;\r\n    else left = middle + 1;\r\n  }\r\n\r\n  return right\r\n}", "testcase": "console.log(mySqrt(4), 2)\r\nconsole.log(mySqrt(8), 2)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-12-18T01:38:16.194Z", "updated_at": "2024-12-18T01:38:16.213Z"}}, {"model": "python_problems.solution", "pk": 297, "fields": {"problem": 158, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# dict\r\nclass Solution:\r\n    def findDisappearedNumbers(self, numbers: list[int]) -> list[int]:\r\n        number_set = set(range(1, len(numbers) + 1))\r\n\r\n        for num in set(numbers):\r\n            if num in number_set:\r\n                number_set.discard(num)\r\n\r\n        return list(number_set)\r\n\r\n\r\n# O(n), O(1) # You may assume the returned list does not count as extra space.\r\n# mutate input array\r\nclass Solution:\r\n    def findDisappearedNumbers(self, numbers: list[int]) -> list[int]:\r\n        for number in numbers:\r\n            numbers[abs(number) - 1] = -abs(numbers[abs(number) - 1])\r\n\r\n        return [index for\r\n                index, number in enumerate(numbers, 1)\r\n                if number > 0]", "testcase": "print(Solution().findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]), [5, 6])\r\nprint(Solution().findDisappearedNumbers([1, 1]), [2])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-18T20:31:19.408Z", "updated_at": "2024-12-18T20:31:19.432Z"}}, {"model": "python_problems.solution", "pk": 298, "fields": {"problem": 158, "language": 2, "owner": 3, "solution": "/**\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar findDisappearedNumbers = function (numbers) {\r\n  const disappeared = [];\r\n\r\n  for (let index = 0; index < numbers.length; index++) {\r\n    const number = numbers[index];\r\n    numbers[Math.abs(number) - 1] = -Math.abs(numbers[Math.abs(number) - 1]);\r\n  }\r\n\r\n  for (let index = 0; index < numbers.length; index++) {\r\n    const number = numbers[index];\r\n\r\n    if (number > 0) disappeared.push(index + 1);\r\n  }\r\n\r\n  return disappeared\r\n}", "testcase": "console.log(findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]), [5, 6])\r\nconsole.log(findDisappearedNumbers([1, 1]), [2])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-18T20:42:38.137Z", "updated_at": "2024-12-18T20:42:38.156Z"}}, {"model": "python_problems.solution", "pk": 299, "fields": {"problem": 159, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# O(n), O(n)\r\n# dfs, recursive\r\nclass Solution:\r\n    def inorderTraversal(self, root: TreeNode | None) -> list[int]:\r\n        node_list = []\r\n\r\n        def dfs(node):\r\n            if not node:\r\n                return\r\n\r\n            dfs(node.left)\r\n            node_list.append(node.val)\r\n            dfs(node.right)\r\n            \r\n        dfs(root)\r\n\r\n        return node_list\r\n    \r\n\r\n# O(n), O(n)\r\n# dfs, iterative\r\nclass Solution:\r\n    def inorderTraversal(self, root: TreeNode | None) -> list[int]:\r\n        node_list = []\r\n        stack = []\r\n        node = root\r\n\r\n        while node or stack:\r\n            while node:\r\n                stack.append(node)\r\n                node = node.left\r\n            \r\n            node = stack.pop()\r\n            node_list.append(node.val)\r\n            node = node.right\r\n\r\n        return node_list", "testcase": "print(Solution().inorderTraversal(build_tree_from_list([1,None,2,3], Node)), [1, 3, 2])\r\nprint(Solution().inorderTraversal(build_tree_from_list([1,2,3,4,5,None,8,None,None,6,7,9])), [4,2,6,5,7,1,3,9,8])\r\nprint(Solution().inorderTraversal(build_tree_from_list([], Node)), [])\r\nprint(Solution().inorderTraversal(build_tree_from_list([1], Node)), [1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-19T01:59:38.945Z", "updated_at": "2024-12-19T01:59:38.964Z"}}, {"model": "python_problems.solution", "pk": 300, "fields": {"problem": 159, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * O(n), O(n)\r\n * dfs, recursive\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar inorderTraversal = function (root) {\r\n  const nodeList = [];\r\n\r\n  var dfs = function (node) {\r\n    if (node === null) return\r\n\r\n    dfs(node.left);\r\n    nodeList.push(node.val);\r\n    dfs(node.right);\r\n  }\r\n\r\n  dfs(root)\r\n\r\n  return nodeList\r\n}\r\n\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * O(n), O(n)\r\n * dfs, iterative\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar inorderTraversal = function (root) {\r\n  const nodeList = [];\r\n  const stack = [];\r\n  let node = root;\r\n\r\n  while (node || stack.length > 0) {\r\n    while (node) {\r\n      stack.push(node);\r\n      node = node.left;\r\n    }\r\n\r\n    node = stack.pop();\r\n    nodeList.push(node.val);\r\n    node = node.right;\r\n  }\r\n\r\n  return nodeList\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-19T02:33:45.709Z", "updated_at": "2024-12-19T02:58:49.911Z"}}, {"model": "python_problems.solution", "pk": 301, "fields": {"problem": 160, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def maxNumberOfBalloons(self, text: str) -> int:\r\n        balloon = {\"b\": 1, \"a\": 1, \"l\": 2, \"o\": 2, \"n\": 1}\r\n        text_map = {}\r\n        max_balloons = len(text)\r\n\r\n        for letter in text:\r\n            text_map[letter] = text_map.get(letter, 0) + 1\r\n        \r\n        for letter in balloon:\r\n            if letter not in text_map:\r\n                return 0\r\n\r\n            max_balloons = min(max_balloons, text_map[letter] // balloon[letter])\r\n\r\n        return max_balloons", "testcase": "print(Solution().maxNumberOfBalloons(\"nlaebolko\"), 1)\r\nprint(Solution().maxNumberOfBalloons(\"loonbalxballpoon\"), 2)\r\nprint(Solution().maxNumberOfBalloons(\"leetcode\"), 0)\r\nprint(Solution().maxNumberOfBalloons(\"balon\"), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-19T04:05:01.089Z", "updated_at": "2024-12-19T04:05:01.111Z"}}, {"model": "python_problems.solution", "pk": 302, "fields": {"problem": 160, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} text\r\n * @return {number}\r\n */\r\nvar maxNumberOfBalloons = function (text) {\r\n  const balloon = { 'b': 1, 'a': 1, 'l': 2, 'o': 2, 'n': 1 }\r\n  const textMap = new Map();\r\n  let maxBalloons = text.length;\r\n\r\n  for (const letter of text) {\r\n    textMap.set(letter, (textMap.get(letter) || 0) + 1);\r\n  }\r\n\r\n  for (const letter in balloon) {\r\n    if (textMap.has(letter)) {\r\n      maxBalloons = Math.min(\r\n        maxBalloons,\r\n        textMap.get(letter) / balloon[letter] | 0)\r\n    }\r\n    else return 0\r\n  }\r\n\r\n  return maxBalloons\r\n}", "testcase": "console.log(maxNumberOfBalloons(\"nlaebolko\"), 1)\r\nconsole.log(maxNumberOfBalloons(\"loonbalxballpoon\"), 2)\r\nconsole.log(maxNumberOfBalloons(\"leetcode\"), 0)\r\nconsole.log(maxNumberOfBalloons(\"balon\"), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-19T04:05:26.795Z", "updated_at": "2024-12-19T04:05:26.817Z"}}, {"model": "python_problems.solution", "pk": 303, "fields": {"problem": 161, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# \r\n# O(n), O(n)\r\n# dfs, recursion\r\nclass Solution:\r\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\r\n        node_list = []  # initialize the preorder traversal value list\r\n\r\n        def dfs(node):\r\n            if not node:\r\n                return\r\n\r\n            node_list.append(node.val)  # add its value to node list\r\n            dfs(node.left)  # traverse left\r\n            dfs(node.right)  # traverse right\r\n\r\n        dfs(root)\r\n\r\n        return node_list\r\n    \r\n\r\n# O(n), O(n)\r\n# dfs, iteration, stack\r\nclass Solution:\r\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\r\n        if not root:\r\n            return []\r\n\r\n        node_list = []  # initialize the preorder traversal value list\r\n        stack = [root]  # Initialize the stack with the root node\r\n\r\n        while stack:\r\n            for _ in stack:\r\n                node = stack.pop()  # Pop the current node\r\n                node_list.append(node.val)  # add its value to node list\r\n\r\n                if node.right:  # Add left child to the queue if it exists\r\n                    stack.append(node.right)\r\n                if node.left:  # Add right child to the queue if it exists\r\n                    stack.append(node.left)\r\n\r\n        return node_list\r\n\r\n\r\n# O(n), O(n)\r\n# dfs, iteration, stack\r\nclass Solution:\r\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\r\n        node_list = []  # initialize the preorder traversal value list\r\n        stack = []  # Initialize the stack\r\n        node = root\r\n\r\n        while stack or node:\r\n            if node:\r\n                node_list.append(node.val)  # add its value to node list\r\n                stack.append(node.right)  # Add right child to the stack\r\n                node = node.left  # traverse left\r\n            else:\r\n                node = stack.pop()  # Pop the current node\r\n\r\n        return node_list", "testcase": "print(Solution().preorderTraversal(build_tree_from_list([1, 2, 3, 4, 5, None, 8, None, None, 6, 7, 9], TreeNode)), [1, 2, 4, 5, 6, 7, 3, 8, 9])\r\nprint(Solution().preorderTraversal(build_tree_from_list([1, None, 2, 3], TreeNode)), [1, 2, 3])\r\nprint(Solution().preorderTraversal(build_tree_from_list([], TreeNode)), [])\r\nprint(Solution().preorderTraversal(build_tree_from_list([1], TreeNode)), [1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-22T06:14:16.697Z", "updated_at": "2024-12-22T06:14:16.714Z"}}, {"model": "python_problems.solution", "pk": 304, "fields": {"problem": 161, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * O(n), O(n)\r\n * dfs, recursion\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar preorderTraversal = function (root) {\r\n  const nodeList = [];  // initialize the preorder traversal value list\r\n\r\n  function dfs(node) {\r\n    if (node === null) return  // if node is null return\r\n\r\n    nodeList.push(node.val);  // add its value to node list\r\n    dfs(node.left)  // traverse left\r\n    dfs(node.right)  // traverse right\r\n  }\r\n\r\n  dfs(root)\r\n\r\n  return nodeList\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * dfs, iteration, stack\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar preorderTraversal = function (root) {\r\n  if (root === null) return []  // if node is null return\r\n  const nodeList = [];  // initialize the preorder traversal value list\r\n  const stack = [root];  // Initialize the stack with the root node\r\n\r\n  while (stack.length !== 0) {\r\n    const stackLength = stack.length;\r\n\r\n    for (let index = 0; index < stackLength; index++) {\r\n      node = stack.pop();  // Pop the current node\r\n      nodeList.push(node.val);  // add its value to node list\r\n\r\n      if (node.right) stack.push(node.right);  // Add right child to the stack if it exists\r\n      if (node.left) stack.push(node.left);  // Add left child to the stack if it exists\r\n    }\r\n  }\r\n\r\n  return nodeList\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * dfs, iteration, stack\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar preorderTraversal = function (root) {\r\n  const nodeList = [];  // initialize the preorder traversal value list\r\n  const stack = [];  // Initialize an empty stack\r\n  let node = root;  // Start traversal from the root node\r\n\r\n  while (stack.length !== 0 || node) {\r\n    if (node) {\r\n      nodeList.push(node.val);  // Add current node's value to the result\r\n      stack.push(node.right);  // Add right child to the stack even if it's null\r\n      node = node.left;  // traverse left the left child\r\n    }\r\n    else node = stack.pop();  // Backtrack to the last right child\r\n  }\r\n\r\n  return nodeList\r\n}", "testcase": "console.log(preorderTraversal(buildTreeFromList([1, 2, 3, 4, 5, null, 8, null, null, 6, 7, 9], TreeNode)), [1, 2, 4, 5, 6, 7, 3, 8, 9])\r\nconsole.log(preorderTraversal(buildTreeFromList([1, null, 2, 3], TreeNode)), [1, 2, 3])\r\nconsole.log(preorderTraversal(buildTreeFromList([], TreeNode)), [])\r\nconsole.log(preorderTraversal(buildTreeFromList([1], TreeNode)), [1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-22T07:11:50.420Z", "updated_at": "2024-12-22T07:11:50.440Z"}}, {"model": "python_problems.solution", "pk": 305, "fields": {"problem": 162, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# O(n), O(n)\r\n# dfs, recursion\r\nclass Solution:\r\n    def postorderTraversal(self, root: TreeNode) -> list[int]:\r\n        node_list = []  # initialize the preorder traversal value list\r\n\r\n        def dfs(node):\r\n            if not node:  # if node is None return\r\n                return\r\n\r\n            dfs(node.left)  # traverse left\r\n            dfs(node.right)  # traverse right\r\n            node_list.append(node.val)  # add its value to node list\r\n\r\n        dfs(root)\r\n\r\n        return node_list", "testcase": "print(Solution().postorderTraversal(build_tree_from_list([1, 2, 3, 4, 5, None, 8, None, None, 6, 7, 9], TreeNode)), [4, 6, 7, 5, 2, 9, 8, 3, 1])\r\nprint(Solution().postorderTraversal(build_tree_from_list([1, None, 2, 3], TreeNode)), [3, 2, 1])\r\nprint(Solution().postorderTraversal(build_tree_from_list([], TreeNode)), [])\r\nprint(Solution().postorderTraversal(build_tree_from_list([1], TreeNode)), [1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-22T08:40:24.147Z", "updated_at": "2024-12-22T08:40:24.165Z"}}, {"model": "python_problems.solution", "pk": 306, "fields": {"problem": 162, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * O(n), O(n)\r\n * dfs, recursion\r\n * @param {TreeNode} root\r\n * @return {number[]}\r\n */\r\nvar postorderTraversal = function (root) {\r\n  const nodeList = [];  // initialize the preorder traversal value list\r\n\r\n  function dfs(node) {\r\n    if (node === null) return  // if node is None return\r\n\r\n    dfs(node.left)  // traverse left\r\n    dfs(node.right)  // traverse right\r\n    nodeList.push(node.val);  // add its value to node list\r\n  }\r\n\r\n  dfs(root)\r\n\r\n  return nodeList\r\n}", "testcase": "console.log(postorderTraversal(buildTreeFromList([1, 2, 3, 4, 5, null, 8, null, null, 6, 7, 9], TreeNode)), [4, 6, 7, 5, 2, 9, 8, 3, 1])\r\nconsole.log(postorderTraversal(buildTreeFromList([1, null, 2, 3], TreeNode)), [3, 2, 1])\r\nconsole.log(postorderTraversal(buildTreeFromList([], TreeNode)), [])\r\nconsole.log(postorderTraversal(buildTreeFromList([1], TreeNode)), [1])", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-22T08:52:01.424Z", "updated_at": "2024-12-22T08:52:01.445Z"}}, {"model": "python_problems.solution", "pk": 307, "fields": {"problem": 163, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# dictionary\r\nclass Solution:\r\n    def wordPattern(self, pattern: str, text: str) -> bool:\r\n        text_list = text.split()  # split text into words\r\n        text_set = set()  # unique word set\r\n        pattern_text = {}  # letter to word map\r\n        \r\n        if len(pattern) != len(text_list):  # if text list length and pattern length are not the same\r\n            return False\r\n\r\n        for index, letter in enumerate(pattern):\r\n            if letter in pattern_text:\r\n                if pattern_text[letter] != text_list[index]:  # if letter is already mapped to another word\r\n                    return False\r\n            else:\r\n                word = text_list[index]  # current word\r\n                \r\n                if word in text_set:  # if another letter is mapped to current word\r\n                    return False\r\n                \r\n                pattern_text[letter] = word  # add a word to `letter to word` map\r\n                text_set.add(word)  # add word to unique set\r\n        \r\n        return True", "testcase": "print(Solution().wordPattern(\"abba\", \"dog cat cat dog\"), True)\r\nprint(Solution().wordPattern(\"abba\", \"dog cat cat fish\"), False)\r\nprint(Solution().wordPattern(\"aaaa\", \"dog cat cat dog\"), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-22T09:36:43.841Z", "updated_at": "2024-12-22T09:36:43.859Z"}}, {"model": "python_problems.solution", "pk": 308, "fields": {"problem": 163, "language": 2, "owner": 3, "solution": "/**\r\n * @param {string} pattern\r\n * @param {string} text\r\n * @return {boolean}\r\n */\r\nvar wordPattern = function (pattern, text) {\r\n  const textList = text.split(' ');  // split text into words\r\n  const letterToWord = new Map();  // letter to word map\r\n  const wordToLetter = new Map();  // word to letter map\r\n\r\n  if (pattern.length != textList.length) return false  // if text list length and pattern length are not the same\r\n\r\n  for (let index = 0; index < pattern.length; index++) {\r\n    const letter = pattern[index];  // current letter\r\n    const word = textList[index];  // current word\r\n\r\n    if (\r\n      letterToWord.has(letter) &&  // if letter is already mapped to another word\r\n      letterToWord.get(letter) != word\r\n    )\r\n      return false\r\n    if (\r\n      wordToLetter.has(word) &&  // if word is already mapped to another letter\r\n      wordToLetter.get(word) != letter\r\n    )\r\n      return false\r\n\r\n    letterToWord.set(letter, word);  // update map\r\n    wordToLetter.set(word, letter);  // update map\r\n  }\r\n\r\n  return true\r\n}", "testcase": "console.log(wordPattern('abba', 'dog cat cat dog'), true)\r\nconsole.log(wordPattern('abba', 'dog cat cat fish'), false)\r\nconsole.log(wordPattern('aaaa', 'dog cat cat dog'), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-22T10:04:24.812Z", "updated_at": "2024-12-22T10:04:24.830Z"}}, {"model": "python_problems.solution", "pk": 309, "fields": {"problem": 164, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def removeDuplicates(self, numbers: list[int]) -> int:\r\n        left = 0\r\n\r\n        for right, number in enumerate(numbers):\r\n            if (right < 2 or  # the first two numbers or\r\n                    number > numbers[left - 2]):  # number is greater than the first of the two last values\r\n                numbers[left] = number  # move the number to the left pointer position\r\n                left += 1\r\n\r\n        return left\r\n\r\n\r\n# O(n), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def removeDuplicates(self, numbers: list[int]) -> int:\r\n        left = 0\r\n        twice = False\r\n\r\n        for number in numbers[1:]:\r\n            if number == numbers[left] and not twice:\r\n                left += 1\r\n                numbers[left] = number\r\n                twice = True\r\n            elif number > numbers[left]:\r\n                left += 1\r\n                numbers[left] = number\r\n                twice = False\r\n\r\n        return left + 1", "testcase": "print(Solution().removeDuplicates([1, 1, 1, 2, 2, 3]), 5)\r\nprint(Solution().removeDuplicates([0, 0, 1, 1, 1, 1, 2, 3, 3]), 7)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-22T12:48:48.268Z", "updated_at": "2024-12-22T12:48:48.293Z"}}, {"model": "python_problems.solution", "pk": 310, "fields": {"problem": 164, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * two pointers\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar removeDuplicates = function (numbers) {\r\n  let left = 0;\r\n\r\n  for (let right = 0; right < numbers.length; right++) {\r\n    if (right < 2 || numbers[right] > numbers[left - 2]) {\r\n      numbers[left] = numbers[right]\r\n      left++;\r\n    }\r\n  }\r\n\r\n  return left\r\n}", "testcase": "console.log(removeDuplicates([1, 1, 1, 2, 2, 3]), 5)\r\nconsole.log(removeDuplicates([0, 0, 1, 1, 1, 1, 2, 3, 3]), 7)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-22T12:49:13.514Z", "updated_at": "2024-12-22T12:49:13.532Z"}}, {"model": "python_problems.solution", "pk": 311, "fields": {"problem": 165, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# sliding window\r\nclass Solution:\r\n    def equalSubstring(self, text1: str, text2: str, max_cost: int) -> int:\r\n        left = 0\r\n        window_length = 0\r\n\r\n        for right, (letter1, letter2) in enumerate(zip(text1, text2)):\r\n            max_cost -= abs(ord(letter1) - ord(letter2))\r\n\r\n            while max_cost < 0:\r\n                max_cost += abs(ord(text1[left]) - ord(text2[left]))\r\n                left += 1\r\n\r\n            window_length = max(window_length, right - left + 1)\r\n\r\n        return window_length", "testcase": "print(Solution().equalSubstring(\"abcd\", \"bcdf\", 3), 3)\r\nprint(Solution().equalSubstring(\"abcd\", \"cdef\", 3), 1)\r\nprint(Solution().equalSubstring(\"abcd\", \"acde\", 0), 1)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-22T20:30:47.598Z", "updated_at": "2024-12-22T20:30:47.617Z"}}, {"model": "python_problems.solution", "pk": 312, "fields": {"problem": 165, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * sliding window\r\n * @param {string} text1\r\n * @param {string} text2\r\n * @param {number} maxCost\r\n * @return {number}\r\n */\r\nvar equalSubstring = function (text1, text2, maxCost) {\r\n  let left = 0;\r\n  let windowLength = 0;\r\n\r\n  for (let right = 0; right < text1.length; right++) {\r\n    maxCost -= Math.abs(text1[right].charCodeAt(0) - text2[right].charCodeAt(0));\r\n\r\n    while (maxCost < 0) {\r\n      maxCost += Math.abs(text1[left].charCodeAt(0) - text2[left].charCodeAt(0));\r\n      left++;\r\n    }\r\n\r\n    windowLength = Math.max(windowLength, right - left + 1);\r\n  }\r\n\r\n  return windowLength\r\n}", "testcase": "console.log(equalSubstring(\"abcd\", \"bcdf\", 3), 3)\r\nconsole.log(equalSubstring(\"abcd\", \"cdef\", 3), 1)\r\nconsole.log(equalSubstring(\"abcd\", \"acde\", 0), 1)", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-22T20:31:31.579Z", "updated_at": "2024-12-22T20:31:31.599Z"}}, {"model": "python_problems.solution", "pk": 313, "fields": {"problem": 166, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# recursion\r\nclass Solution:\r\n    def decodeString(self, text: str) -> str:\r\n        self.index = 0\r\n        \r\n        def recursion():\r\n            number = 0\r\n            word = \"\"\r\n            \r\n            while self.index < len(text):\r\n                char = text[self.index]\r\n\r\n                if char.isdigit():\r\n                    number += 10 * number + int(char)\r\n                    self.index += 1\r\n                elif char == \"[\":\r\n                    self.index += 1\r\n                    word += number * recursion()\r\n                    number = 0\r\n                elif char == \"]\":\r\n                    self.index += 1\r\n                    return word\r\n                else:\r\n                    word += char\r\n                    self.index += 1\r\n\r\n            return word\r\n            \r\n        return recursion()\r\n\r\n\r\n# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def decodeString(self, text: str) -> str:\r\n        stack = []\r\n\r\n        for char in text:\r\n            if char != \"]\":\r\n                stack.append(char)\r\n            else:\r\n                word = \"\"\r\n                while stack[-1] != \"[\":\r\n                    word = stack.pop() + word \r\n                stack.pop()\r\n                \r\n                number = \"\"\r\n                while stack and stack[-1].isdigit():\r\n                    number = stack.pop() + number\r\n                \r\n                stack.append(int(number) * word)\r\n        \r\n        return \"\".join(stack)", "testcase": "print(Solution().decodeString(\"3[a]2[bc]\"), \"aaabcbc\")\r\nprint(Solution().decodeString(\"3[a2[c]]\"), \"accaccacc\")\r\nprint(Solution().decodeString(\"2[abc]3[cd]ef\"), \"abcabccdcdcdef\")\r\nprint(Solution().decodeString(\"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\"), \"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\")\r\nprint(Solution().decodeString(\"10[leetcode]\"), \"leetcodeleetcodeleetcodeleetcodeleetcodeleetcodeleetcodeleetcodeleetcodeleetcode\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-23T08:07:55.777Z", "updated_at": "2025-02-09T13:46:02.354Z"}}, {"model": "python_problems.solution", "pk": 314, "fields": {"problem": 166, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * stack\r\n * @param {string} text\r\n * @return {string}\r\n */\r\nvar decodeString = function (text) {\r\n  const stack = [];\r\n\r\n  for (let index = 0; index < text.length; index++) {\r\n    const char = text[index];\r\n\r\n    if (char != ']') stack.push(char)\r\n    else {\r\n      let word = '';\r\n\r\n      while (stack[stack.length - 1] != '[') {\r\n        word = stack.pop() + word;\r\n      }\r\n\r\n      stack.pop();\r\n      let number = '';\r\n\r\n      while (\r\n        stack[stack.length - 1] >= '0' &&\r\n        stack[stack.length - 1] <= '9'\r\n      ) {\r\n        number = stack.pop() + number;\r\n      }\r\n\r\n      stack.push(word.repeat(number));\r\n    }\r\n  }\r\n\r\n  return stack.join('')\r\n}", "testcase": "console.log(decodeString(\"3[a]2[bc]\"), \"aaabcbc\")\r\nconsole.log(decodeString(\"3[a2[c]]\"), \"accaccacc\")\r\nconsole.log(decodeString(\"2[abc]3[cd]ef\"), \"abcabccdcdcdef\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-23T08:30:28.208Z", "updated_at": "2024-12-23T08:30:28.226Z"}}, {"model": "python_problems.solution", "pk": 315, "fields": {"problem": 167, "language": 1, "owner": 3, "solution": "# draft\r\n# [1, 1, 2]\r\n# [1, 2, 2]\r\n# [1, 1, 2, 2, 3]\r\n# [1, 2, 2, 3, 3]\r\n\r\n\r\n# O(logn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def singleNonDuplicate(self, numbers: list[int]) -> int:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n\r\n        while left <= right:\r\n            middle = left + (right - left) // 2\r\n            middle_number = numbers[middle]\r\n\r\n            if (middle - 1 >= 0 and  # if index in bounds\r\n                    numbers[middle - 1] == middle_number):  # middle number same as previous one\r\n                if (middle - 1) % 2:  # if the previous index is odd\r\n                    right = middle - 1  # check the left part\r\n                else:\r\n                    left = middle + 1  # check the right part                \r\n            elif (middle + 1 < len(numbers) and  # if index in bounds\r\n                    numbers[middle + 1] == middle_number):  # middle number same as next one\r\n                if (middle + 1) % 2:  # if the next index is odd\r\n                    left = middle + 1  # check the right part\r\n                else:\r\n                    right = middle - 1  # check the left part\r\n            else:\r\n                return middle_number", "testcase": "print(Solution().singleNonDuplicate([1, 1, 2, 3, 3, 4, 4, 8, 8]), 2)\r\nprint(Solution().singleNonDuplicate([3, 3, 7, 7, 10, 11, 11]), 10)\r\nprint(Solution().singleNonDuplicate([1, 2, 2]), 1)\r\nprint(Solution().singleNonDuplicate([1]), 1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-12-24T10:46:59.830Z", "updated_at": "2024-12-24T10:46:59.851Z"}}, {"model": "python_problems.solution", "pk": 316, "fields": {"problem": 167, "language": 2, "owner": 3, "solution": "/**\r\n * O(logn), O(1)\r\n * binary search\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar singleNonDuplicate = function (numbers) {\r\n  let left = 0;\r\n  let right = numbers.length - 1;\r\n\r\n  while (left <= right) {\r\n    const middle = left + (right - left) / 2 | 0;\r\n    const middleNumber = numbers[middle];\r\n\r\n    if (middleNumber === numbers[middle - 1]) {  // middle number same as previous one\r\n      if ((middle - 1) % 2) right = middle - 1  // if the previous index is odd  check the left part\r\n      else left = middle + 1  // if even check the right part\r\n    } else if (middleNumber === numbers[middle + 1]) {  // middle number same as next one\r\n      if ((middle + 1) % 2) left = middle + 1  // if the next index is odd check the right part\r\n      else right = middle - 1  // if even check the left part\r\n    } else return middleNumber\r\n  }\r\n}", "testcase": "console.log(singleNonDuplicate([1, 1, 2, 3, 3, 4, 4, 8, 8]), 2)\r\nconsole.log(singleNonDuplicate([3, 3, 7, 7, 10, 11, 11]), 10)\r\nconsole.log(singleNonDuplicate([1, 2, 2]), 1)\r\nconsole.log(singleNonDuplicate([1]), 1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2024-12-24T10:47:53.474Z", "updated_at": "2024-12-24T10:47:53.496Z"}}, {"model": "python_problems.solution", "pk": 317, "fields": {"problem": 168, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def removeNodes(self, head: ListNode | None) -> ListNode | None:\r\n        \"\"\"\r\n        Reverse Linked List and return it's new head.\r\n        \"\"\"\r\n        def reverse_linkedlist(node: ListNode | None) -> ListNode | None:\r\n            previous = None\r\n\r\n            while node:\r\n                next_node = node.next\r\n                node.next = previous\r\n                previous = node\r\n                node = next_node\r\n            \r\n            return previous\r\n\r\n        anchor = node = reverse_linkedlist(head)  # reversed link list head\r\n        max_value = node.val  # init maximum value with the last node value\r\n\r\n        while node.next:  # while in bounds\r\n            if node.next.val < max_value:  # it's value is less than current max value\r\n                node.next = node.next.next  # pop the next node\r\n            else:\r\n                max_value = max(max_value, node.val)  # update max value\r\n                node = node.next  # point to the next node\r\n\r\n        return reverse_linkedlist(anchor)\r\n\r\n\r\nnode_list = [5, 2, 13, 3, 8]\r\n\r\ndef list_to_linkedlist(node_list):\r\n    anchor = node = ListNode()\r\n\r\n    for static_node in node_list:\r\n        node.next = ListNode(static_node)\r\n        node = node.next\r\n    \r\n    node.next = None\r\n    \r\n    return anchor.next\r\n\r\nlinkedlist_1 = list_to_linkedlist(node_list)\r\nprint(linkedlist_1.val)\r\n\r\ndef linkedlist_to_list(node):\r\n    node_list = []\r\n\r\n    while node:\r\n        node_list.append(node.val)\r\n        node = node.next\r\n\r\n    return node_list\r\n\r\nprint(linkedlist_to_list(linkedlist_1))\r\n\r\nprint(linkedlist_to_list(Solution().removeNodes((list_to_linkedlist([5, 2, 13, 3, 8])))), [13, 8])\r\nprint(linkedlist_to_list(Solution().removeNodes((list_to_linkedlist([1, 1, 1, 1])))), [1,1,1,1])\r\n\r\nprint(\r\n    linkedlist_to_list(\r\n        Solution().removeNodes((\r\n            list_to_linkedlist([5, 2, 13, 3, 8])))), [13, 8])", "testcase": "print(linkedlist_to_list(Solution().removeNodes((list_to_linkedlist([5, 2, 13, 3, 8])))), [13, 8])\r\nprint(linkedlist_to_list(Solution().removeNodes((list_to_linkedlist([1, 1, 1, 1])))), [1,1,1,1])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-25T08:40:19.923Z", "updated_at": "2024-12-25T08:40:19.945Z"}}, {"model": "python_problems.solution", "pk": 318, "fields": {"problem": 168, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n*/\r\nfunction ListNode(val, next) {\r\n  this.val = (val === undefined ? 0 : val)\r\n  this.next = (next === undefined ? null : next)\r\n}\r\n/**\r\n * O(n), O(1)\r\n * linked list\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar removeNodes = function (head) {\r\n  function reverseLinkedList(node) {\r\n    let previous = null;\r\n\r\n    while (node) {\r\n      const nextNode = node.next;\r\n      node.next = previous;\r\n      previous = node;\r\n      node = nextNode;\r\n    }\r\n\r\n    return previous\r\n  }\r\n\r\n  const reversedHead = reverseLinkedList(head);\r\n  let node = reversedHead;\r\n  let maxValue = node.val;\r\n\r\n  while (node.next) {\r\n    if (node.next.val < maxValue) {\r\n      node.next = node.next.next;\r\n    } else {\r\n      maxValue = Math.max(maxValue, node.next.val);\r\n      node = node.next;\r\n    }\r\n  }\r\n\r\n  return reverseLinkedList(reversedHead)\r\n}\r\n\r\nconst nodeList = [5, 2, 13, 3, 8]\r\n\r\nfunction listToLinkedlist(nodeList) {\r\n  const anchor = new ListNode()\r\n  let node = anchor\r\n\r\n  for (let static_node of nodeList) {\r\n    node.next = new ListNode(static_node)\r\n    node = node.next\r\n  }\r\n\r\n  node.next = null\r\n\r\n  return anchor.next\r\n}\r\n\r\nconst linkedlist_1 = listToLinkedlist(nodeList)\r\nconsole.log(linkedlist_1.val)\r\n\r\nfunction linkedlistToList(node) {\r\n  const nodeList = []\r\n\r\n  while (node) {\r\n    nodeList.push(node.val)\r\n    node = node.next\r\n  }\r\n\r\n  return nodeList\r\n}\r\n\r\nconsole.log(linkedlistToList(linkedlist_1))\r\n\r\nconsole.log(linkedlistToList(removeNodes((listToLinkedlist([5, 2, 13, 3, 8])))), [13, 8])\r\nconsole.log(linkedlistToList(removeNodes((listToLinkedlist([1, 1, 1, 1])))), [1,1,1,1])\r\n\r\nconsole.log(\r\n    linkedlistToList(\r\n        removeNodes((\r\n            listToLinkedlist([5, 2, 13, 3, 8])))), [13, 8])", "testcase": "console.log(linkedlistToList(removeNodes((listToLinkedlist([5, 2, 13, 3, 8])))), [13, 8])\r\nconsole.log(linkedlistToList(removeNodes((listToLinkedlist([1, 1, 1, 1])))), [1,1,1,1])", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-25T09:08:04.276Z", "updated_at": "2024-12-25T09:08:04.301Z"}}, {"model": "python_problems.solution", "pk": 319, "fields": {"problem": 169, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\nfrom binarytree import Node\r\n\r\n# O(n), O(1)\r\n# binary treee\r\nclass Solution:\r\n    def sortedArrayToBST(self, numbers: list[int]) -> Node | None:\r\n        if not numbers:  # if the list of child nodes is empty\r\n            return None\r\n\r\n        left = 0  # left pointer\r\n        right = len(numbers) - 1  # right pointer \r\n        middle = left + (right - left) // 2  # middle pointer\r\n        middle_value = numbers[middle]  # middle value\r\n        left_node = self.sortedArrayToBST(numbers[:middle])\r\n        right_node = self.sortedArrayToBST(numbers[middle + 1:])\r\n        node = Node(middle_value, left_node, right_node)  # create a node\r\n\r\n        return node", "testcase": "print(Solution().sortedArrayToBST([-10, -3, 0, 5, 9]))", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-25T12:42:29.733Z", "updated_at": "2024-12-25T12:42:29.750Z"}}, {"model": "python_problems.solution", "pk": 320, "fields": {"problem": 169, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * O(n), O(1)\r\n * binary treee\r\n * @param {number[]} numbers\r\n * @return {TreeNode}\r\n */\r\nvar sortedArrayToBST = function (numbers) {\r\n  if (numbers.length === 0) return null\r\n\r\n  const left = 0;\r\n  const right = numbers.length - 1;\r\n  const middle = left + ((right - left) / 2) | 0;\r\n  const middleNumber = numbers[middle];\r\n  const node = new TreeNode(middleNumber);\r\n  node.left = sortedArrayToBST(numbers.slice(0, middle));\r\n  node.right = sortedArrayToBST(numbers.slice(middle + 1,))\r\n\r\n  return node\r\n}", "testcase": "console.log(sortedArrayToBST([-10, -3, 0, 5, 9]))", "time_complexity": 2, "space_complexity": 1, "created_at": "2024-12-25T12:43:11.067Z", "updated_at": "2024-12-25T12:43:11.085Z"}}, {"model": "python_problems.solution", "pk": 321, "fields": {"problem": 170, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# binary search\r\nclass Solution:\r\n    def mergeTrees(self, root1: TreeNode | None, root2: TreeNode | None) -> TreeNode | None:\r\n        if not root1 and not root2:\r\n            return None\r\n        \r\n        if not root1:\r\n            root1 = TreeNode()\r\n        if not root2:\r\n            root2 = TreeNode()\r\n        \r\n        root = TreeNode(root1.val + root2.val)\r\n        root.left = self.mergeTrees(root1.left, root2.left)\r\n        root.right = self.mergeTrees(root1.right, root2.right)\r\n        \r\n        return root\r\n\r\n\r\n# O(n), O(n)\r\n# binary search\r\nclass Solution:\r\n    def mergeTrees(self, root1: TreeNode | None, root2: TreeNode | None) -> TreeNode | None:\r\n        if not root1:\r\n            return root2\r\n        if not root2:\r\n            return root1\r\n        \r\n        root = TreeNode(root1.val + root2.val)\r\n        root.left = self.mergeTrees(root1.left, root2.left)\r\n        root.right = self.mergeTrees(root1.right, root2.right)\r\n        \r\n        return root\r\n\r\nprint(level_order_traversal(\r\n    Solution().mergeTrees(\r\n        build_tree_from_list([1, 3, 2, 5]), \r\n        build_tree_from_list([2, 1, 3, None, 4, None, 7]))))", "testcase": "print(level_order_traversal(Solution().mergeTrees(build_tree_from_list([1, 3, 2, 5]), build_tree_from_list([2, 1, 3, None, 4, None, 7]))))", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-26T09:56:26.132Z", "updated_at": "2024-12-26T09:56:26.152Z"}}, {"model": "python_problems.solution", "pk": 322, "fields": {"problem": 170, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * # O(n), O(n)\r\n * # binary search\r\n * @param {TreeNode} root1\r\n * @param {TreeNode} root2\r\n * @return {TreeNode}\r\n */\r\nvar mergeTrees = function (root1, root2) {\r\n  if (!root1 && !root2) return null\r\n  if (!root1) root1 = new TreeNode();\r\n  if (!root2) root2 = new TreeNode();\r\n\r\n  let root = new TreeNode(root1.val + root2.val);\r\n  root.left = mergeTrees(root1.left, root2.left);\r\n  root.right = mergeTrees(root1.right, root2.right);\r\n\r\n  return root\r\n}", "testcase": "print(levelOrderTraversal(Solution().mergeTrees(buildTreeFromList([1, 3, 2, 5]), buildTreeFromList([2, 1, 3, None, 4, None, 7]))))", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-26T09:57:15.036Z", "updated_at": "2024-12-26T09:57:15.055Z"}}, {"model": "python_problems.solution", "pk": 323, "fields": {"problem": 171, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# list\r\nclass MyHashSet:\r\n    def __init__(self):\r\n        self.hash_set = []\r\n\r\n    def add(self, key: int) -> None:\r\n        if key not in self.hash_set:\r\n            self.hash_set.append(key)\r\n\r\n    def remove(self, key: int) -> None:\r\n        if key in self.hash_set:\r\n            self.hash_set.remove(key)\r\n\r\n    def contains(self, key: int) -> bool:\r\n        return key in self.hash_set\r\n\r\n\r\n# O(1), O(10**6)\r\n# Memory is O(10**6) since the table size is constant\r\n# boolean list\r\nclass MyHashSet:\r\n    def __init__(self):\r\n        self.hash_set = [False] * (10 ** 6 + 1)  # first: 0, last: 10 **6\r\n\r\n    def add(self, key: int) -> None:\r\n        self.hash_set[key] = True\r\n\r\n    def remove(self, key: int) -> None:\r\n        self.hash_set[key] = False\r\n\r\n    def contains(self, key: int) -> bool:\r\n        return self.hash_set[key]\r\n\r\n\r\nclass ListNode:\r\n    def __init__(self, val: int = 0):\r\n        self.val = val\r\n        self.next = None\r\n\r\n\r\n# O(1), O(n)\r\n# linked list\r\nclass MyHashSet:\r\n    def __init__(self):\r\n        self.set = [ListNode() for _ in range(10**4)]\r\n\r\n\r\n    def add(self, key: int) -> None:\r\n        node = self.set[key % len(self.set)]\r\n\r\n        while node.next:\r\n            if node.next.val == key:\r\n                return\r\n            node = node.next\r\n        \r\n        node.next = ListNode(key)\r\n\r\n\r\n    def remove(self, key: int) -> None:\r\n        node = self.set[key % len(self.set)]\r\n\r\n        while node.next:\r\n            if node.next.val == key:\r\n                node.next = node.next.next\r\n                return\r\n            node = node.next\r\n\r\n\r\n    def contains(self, key: int) -> bool:\r\n        node = self.set[key % len(self.set)]\r\n\r\n        while node.next:\r\n            if node.next.val == key:\r\n                return True\r\n            node = node.next\r\n        \r\n        return False\r\n\r\n\r\n# Your MyHashSet object will be instantiated and called as such:\r\n# obj = MyHashSet()\r\n# obj.add(key)\r\n# obj.remove(key)\r\n# param_3 = obj.contains(key)", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-12-26T13:50:28.155Z", "updated_at": "2024-12-26T13:50:28.175Z"}}, {"model": "python_problems.solution", "pk": 324, "fields": {"problem": 171, "language": 2, "owner": 3, "solution": "class LinkNode {\r\n  constructor(val = 0) {\r\n    this.val = val;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nvar MyHashSet = function () {\r\n  this.set = Array.from({ length: 10 ** 4 }, () => new LinkNode())\r\n}\r\n\r\n/** \r\n * @param {number} key\r\n * @return {void}\r\n */\r\nMyHashSet.prototype.add = function (key) {\r\n  let node = this.set[key % this.set.length];\r\n\r\n  while (node.next) {\r\n    if (node.next.val === key) return\r\n    node = node.next;\r\n  }\r\n  node.next = new LinkNode(key);\r\n}\r\n\r\n/** \r\n * @param {number} key\r\n * @return {void}\r\n */\r\nMyHashSet.prototype.remove = function (key) {\r\n  let node = this.set[key % this.set.length];\r\n\r\n  while (node.next) {\r\n    if (node.next.val === key) {\r\n      node.next = node.next.next;\r\n      return\r\n    }\r\n    node = node.next;\r\n  }\r\n}\r\n\r\n/** \r\n * @param {number} key\r\n * @return {boolean}\r\n */\r\nMyHashSet.prototype.contains = function (key) {\r\n  let node = this.set[key % this.set.length];\r\n\r\n  while (node.next) {\r\n    if (node.next.val === key) return true\r\n    node = node.next;\r\n  }\r\n  return false\r\n}\r\n\r\n/** \r\n * Your MyHashSet object will be instantiated and called as such:\r\n * var obj = new MyHashSet()\r\n * obj.add(key)\r\n * obj.remove(key)\r\n * var param_3 = obj.contains(key)\r\n */", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-12-26T14:21:27.827Z", "updated_at": "2024-12-26T14:21:27.846Z"}}, {"model": "python_problems.solution", "pk": 325, "fields": {"problem": 172, "language": 1, "owner": 3, "solution": "# [-2, -1, 0, 0, 1, 2]\r\n\r\n# O(n3), O(1)\r\n# two pointers\r\nclass Solution:\r\n    def fourSum(self, numbers: list[int], target: int) -> list[list[int]]:\r\n        numbers.sort()  # sort list to be able to ignore duplicate numbers\r\n        quarduplets = []\r\n\r\n        for index1, number1 in enumerate(numbers[:-3]):\r\n            # Skip same number values\r\n            if (index1 and number1 == numbers[index1 - 1]):\r\n                continue\r\n\r\n            # for index2, number2 in enumerate(numbers[index1 + 1 :-2], index1 + 1):\r\n            for index2 in range(index1 + 1, len(numbers) - 2):\r\n                number2 = numbers[index2]\r\n                \r\n                # Skip same number values\r\n                if (index2 > index1 + 1 and number2 == numbers[index2 - 1]):\r\n                    continue\r\n\r\n                left = index2 + 1  # left pointer\r\n                right = len(numbers) - 1  # right pointer\r\n\r\n                while left < right:  # two pointers\r\n                    quarduplet = (number1 +\r\n                                  number2 +\r\n                                  numbers[left] +\r\n                                  numbers[right])\r\n\r\n                    if quarduplet == target:  # if sum is equal to the target\r\n                        quarduplets.append([number1,\r\n                                            number2,\r\n                                            numbers[left],\r\n                                            numbers[right]])\r\n                        left += 1\r\n                        right -= 1\r\n                        # skip same left pointer values\r\n                        while (left < right and\r\n                               numbers[left] == numbers[left - 1]):\r\n                            left += 1\r\n\r\n                    elif quarduplet < target:  # if sum is less than the target\r\n                        left += 1\r\n                    else:  # if sum is greater than the target\r\n                        right -= 1\r\n\r\n        return quarduplets", "testcase": "print(Solution().fourSum([1, 0, -1, 0, -2, 2], 0), [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]])\r\nprint(Solution().fourSum([2, 2, 2, 2, 2], 8), [[2, 2, 2, 2]])\r\nprint(Solution().fourSum([0, 0, 0, 0], 0), [[0, 0, 0, 0]])", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-12-27T06:45:47.331Z", "updated_at": "2024-12-27T06:45:47.351Z"}}, {"model": "python_problems.solution", "pk": 326, "fields": {"problem": 172, "language": 2, "owner": 3, "solution": "/**\r\n * O(n3), O(1)\r\n * two pointers\r\n * @param {number[]} numbers\r\n * @param {number} target\r\n * @return {number[][]}\r\n */\r\nvar fourSum = function (numbers, target) {\r\n  numbers.sort((a, b) => a - b);\r\n  const quarduplets = [];\r\n\r\n  for (let index1 = 0; index1 < numbers.length - 3; index1++) {\r\n    const number1 = numbers[index1];\r\n    if (number1 === numbers[index1 - 1]) continue\r\n\r\n    for (let index2 = index1 + 1; index2 < numbers.length - 2; index2++) {\r\n      const number2 = numbers[index2];\r\n      if (index2 > index1 + 1 && number2 === numbers[index2 - 1]) continue\r\n\r\n      let left = index2 + 1;\r\n      let right = numbers.length - 1;\r\n\r\n      while (left < right) {\r\n        const quarduplet = number1 + number2 + numbers[left] + numbers[right];\r\n\r\n        if (quarduplet < target) left++;\r\n        else if (quarduplet > target) right--;\r\n        else {\r\n          quarduplets.push([number1, number2, numbers[left], numbers[right]])\r\n          left++;\r\n          right--;\r\n          while (numbers[left] === numbers[left - 1]) left++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return quarduplets\r\n}", "testcase": "console.log(fourSum([1, 0, -1, 0, -2, 2], 0), [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]])\r\nconsole.log(fourSum([2, 2, 2, 2, 2], 8), [[2, 2, 2, 2]])\r\nconsole.log(fourSum([0, 0, 0, 0], 0), [[0, 0, 0, 0]])", "time_complexity": 3, "space_complexity": 1, "created_at": "2024-12-27T07:35:38.883Z", "updated_at": "2024-12-27T07:35:38.900Z"}}, {"model": "python_problems.solution", "pk": 327, "fields": {"problem": 173, "language": 1, "owner": 3, "solution": "class TrieNode:\r\n    def __init__(self):\r\n        self.children = {}\r\n        self.last_letter = False\r\n\r\n\r\n# O(n), O(n)\r\n# dict\r\nclass Trie:\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n\r\n\r\n    def insert(self, word: str) -> None:\r\n        node = self.root\r\n\r\n        for letter in word:\r\n            if letter not in node.children:\r\n                node.children[letter] = TrieNode()\r\n            \r\n            node = node.children[letter]\r\n        \r\n        node.last_letter = True\r\n\r\n\r\n    def search(self, word: str) -> bool:\r\n        node = self.root\r\n\r\n        for letter in word:\r\n            if letter not in node.children:\r\n                return False\r\n            \r\n            node = node.children[letter]\r\n\r\n        return node.last_letter\r\n        \r\n\r\n    def startsWith(self, prefix: str) -> bool:\r\n        node = self.root\r\n\r\n        for letter in prefix:\r\n            if letter not in node.children:\r\n                return False\r\n            \r\n            node = node.children[letter]\r\n\r\n        return True\r\n\r\n\r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.children = [False] * 26\r\n        self.last_letter = False\r\n\r\n\r\n# O(n), O(n)\r\n# list\r\nclass Trie:\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n\r\n\r\n    def insert(self, word: str) -> None:\r\n        node = self.root\r\n\r\n        for letter in word:\r\n            index = ord(letter) - ord(\"a\")\r\n            \r\n            if not node.children[index]:\r\n                node.children[index] = TrieNode()\r\n            \r\n            node = node.children[index]\r\n\r\n        node.last_letter = True\r\n\r\n\r\n    def search(self, word: str) -> bool:\r\n        node = self.root\r\n\r\n        for letter in word:\r\n            index = ord(letter) - ord(\"a\")\r\n            \r\n            if not node.children[index]:\r\n                return False\r\n            \r\n            node = node.children[index]\r\n\r\n        return node.last_letter\r\n        \r\n\r\n    def startsWith(self, prefix: str) -> bool:\r\n        node = self.root\r\n\r\n        for letter in prefix:\r\n            index = ord(letter) - ord(\"a\")\r\n            \r\n            if not node.children[index]:\r\n                return False\r\n            \r\n            node = node.children[index]\r\n\r\n        return True\r\n\r\n# Your Trie object will be instantiated and called as such:\r\n# obj = Trie()\r\n# obj.insert(word)\r\n# param_2 = obj.search(word)\r\n# param_3 = obj.startsWith(prefix)\r\n\r\n\r\ntrie = Trie()\r\ntrie.insert(\"apple\")\r\ntrie.search(\"apple\")   # return True\r\ntrie.search(\"app\")     # return False\r\ntrie.startsWith(\"app\") # return True\r\ntrie.insert(\"app\")\r\ntrie.search(\"app\")     # return True", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-27T13:14:15.193Z", "updated_at": "2024-12-27T13:14:15.213Z"}}, {"model": "python_problems.solution", "pk": 328, "fields": {"problem": 173, "language": 2, "owner": 3, "solution": "class TrieNode {\r\n  constructor() {\r\n    this.children = new Map();\r\n    this.lastWord = false;\r\n  }\r\n}\r\n\r\n/**\r\n * O(n), O(n)\r\n * map\r\n */\r\nclass Trie {\r\n  constructor() {\r\n    this.root = new TrieNode();\r\n  }\r\n  /**\r\n   * @param {string} word\r\n   * @return {void}\r\n   */\r\n  insert(word) {\r\n    let node = this.root;\r\n\r\n    for (const letter of word) {\r\n      if (!node.children.has(letter)) node.children.set(letter, new TrieNode());\r\n      node = node.children.get(letter);\r\n    }\r\n    node.lastWord = true;\r\n  }\r\n  /**\r\n   * @param {string} word\r\n   * @return {boolean}\r\n   */\r\n  search(word) {\r\n    let node = this.root;\r\n\r\n    for (const letter of word) {\r\n      if (!node.children.has(letter)) return false;\r\n      node = node.children.get(letter);\r\n    }\r\n    return node.lastWord;\r\n  }\r\n  /**\r\n   * @param {string} prefix\r\n   * @return {boolean}\r\n   */\r\n  startsWith(prefix) {\r\n    let node = this.root;\r\n\r\n    for (const letter of prefix) {\r\n      if (!node.children.has(letter)) return false;\r\n      node = node.children.get(letter);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n * Your Trie object will be instantiated and called as such:\r\n * var obj = new Trie()\r\n * obj.insert(word)\r\n * var param_2 = obj.search(word)\r\n * var param_3 = obj.startsWith(prefix)\r\n */\r\n\r\nconst trie = new Trie();\r\ntrie.insert(\"apple\");\r\ntrie.search(\"apple\");   // return True\r\ntrie.search(\"app\");     // return False\r\ntrie.startsWith(\"app\"); // return True\r\ntrie.insert(\"app\");\r\ntrie.search(\"app\");     // return True", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2024-12-27T13:38:53.188Z", "updated_at": "2024-12-27T13:38:53.209Z"}}, {"model": "python_problems.solution", "pk": 329, "fields": {"problem": 174, "language": 1, "owner": 3, "solution": "lclass ListNode:\r\n    def __init__(self, key=0, val=0):\r\n        self.key = key\r\n        self.val = val\r\n        self.next = None\r\n\r\n\r\n# O(1), O(n)\r\n# linked list\r\nclass MyHashMap:\r\n    def __init__(self):\r\n        self.map = [0] * 10**4\r\n\r\n    def put(self, key: int, val: int) -> None:\r\n        index = key % len(self.map)\r\n        \r\n        if not self.map[index]:\r\n            self.map[index] = ListNode()\r\n\r\n        node = self.map[index]\r\n\r\n        while node.next:\r\n            if node.next.key == key:\r\n                node.next.val = val\r\n                return\r\n            node = node.next\r\n\r\n        node.next = ListNode(key, val)\r\n        \r\n\r\n    def get(self, key: int) -> int:\r\n        index = key % len(self.map)\r\n\r\n        if not self.map[index]:\r\n            return -1\r\n        \r\n        node = self.map[index]\r\n\r\n        while node.next:\r\n            if node.next.key == key:\r\n                return node.next.val\r\n            node = node.next\r\n        \r\n        return -1\r\n        \r\n\r\n    def remove(self, key: int) -> None:\r\n        index = key % len(self.map)\r\n\r\n        if not self.map[index]:\r\n            return\r\n        \r\n        node = self.map[index]\r\n\r\n        while node.next:\r\n            if node.next.key == key:\r\n                node.next = node.next.next\r\n                return\r\n            node = node.next\r\n\r\n\r\n# Your MyHashMap object will be instantiated and called as such:\r\n# obj = MyHashMap()\r\n# obj.put(key,value)\r\n# param_2 = obj.get(key)\r\n# obj.remove(key)\r\n\r\nmyHashMap = MyHashMap()\r\nmyHashMap.put(1, 1) #  The map is now [[1,1]]\r\nmyHashMap.put(2, 2) #  The map is now [[1,1], [2,2]]\r\nmyHashMap.get(1)    #  return 1, The map is now [[1,1], [2,2]]\r\nmyHashMap.get(3)    #  return -1 (i.e., not found), The map is now [[1,1], [2,2]]\r\nmyHashMap.put(2, 1) #  The map is now [[1,1], [2,1]] (i.e., update the existing value)\r\nmyHashMap.get(2)    #  return 1, The map is now [[1,1], [2,1]]\r\nmyHashMap.remove(2) #  remove the mapping for 2, The map is now [[1,1]]\r\nmyHashMap.get(2)    #  return -1 (i.e., not found), The map is now [[1,1]]", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-12-30T09:40:47.299Z", "updated_at": "2024-12-30T09:40:47.321Z"}}, {"model": "python_problems.solution", "pk": 330, "fields": {"problem": 174, "language": 2, "owner": 3, "solution": "class ListNode {\r\n  constructor(key, val) {\r\n    this.key = key;\r\n    this.val = val;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nvar MyHashMap = function () {\r\n this.hashMap = new Array(10**4);\r\n};\r\n\r\n/** \r\n * O(1), O(n)\r\n * linked list\r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nMyHashMap.prototype.put = function (key, val) {\r\n  const index = key % this.hashMap.length;\r\n  if (!this.hashMap[index]) this.hashMap[index] = new ListNode();\r\n  let node = this.hashMap[index];\r\n\r\n  while (node.next) {\r\n    if (node.next.key === key) {\r\n      node.next.val = val;\r\n      return\r\n    }\r\n    node = node.next;\r\n  }\r\n  node.next = new ListNode(key, val)\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nMyHashMap.prototype.get = function (key) {\r\n  const index = key % this.hashMap.length;\r\n  if (!this.hashMap[index]) return -1\r\n  let node = this.hashMap[index];\r\n\r\n  while (node.next) {\r\n    if (node.next.key === key) {\r\n      return node.next.val\r\n    }\r\n    node = node.next;\r\n  }\r\n  return -1\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {void}\r\n */\r\nMyHashMap.prototype.remove = function (key) {\r\n  const index = key % this.hashMap.length;\r\n  if (!this.hashMap[index]) return\r\n  let node = this.hashMap[index];\r\n\r\n  while (node.next) {\r\n    if (node.next.key === key) {\r\n      node.next = node.next.next;\r\n      return\r\n    }\r\n    node = node.next;\r\n  }\r\n};\r\n\r\n/** \r\n * Your MyHashMap object will be instantiated and called as such:\r\n * var obj = new MyHashMap()\r\n * obj.put(key,value)\r\n * var param_2 = obj.get(key)\r\n * obj.remove(key)\r\n */", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2024-12-30T12:02:12.198Z", "updated_at": "2024-12-30T12:02:12.220Z"}}, {"model": "python_problems.solution", "pk": 331, "fields": {"problem": 175, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# reverse\r\nclass Solution:\r\n    def reverse_str(self, left, right):\r\n        while left < right:\r\n            self.nums[left], self.nums[right] = self.nums[right], self.nums[left]\r\n            left += 1\r\n            right -= 1\r\n\r\n\r\n    def rotate(self, nums: list[int], k: int) -> None:\r\n        k = k % len(nums)\r\n        self.nums = nums\r\n        self.reverse_str(0, len(nums) - 1)\r\n        self.reverse_str(0, k - 1)\r\n        self.reverse_str(k, len(nums) - 1)\r\n        return self.nums\r\n\r\n\r\n# O(n), O(n)\r\n# slice\r\nclass Solution:\r\n    def rotate(self, nums: list[int], k: int) -> None:\r\n        right = len(nums) - k % len(nums)\r\n        return nums[right:] + nums[:right]\r\n\r\n\r\n# O(n), O(n)\r\n# iteraton\r\nclass Solution:\r\n    def rotate(self, nums: list[int], k: int) -> None:\r\n        nums_copy = [0] * len(nums)\r\n        \r\n        for index in range(len(nums)):\r\n            nums_copy[(index + k) % len(nums)] = nums[index]\r\n\r\n        nums[:] = nums_copy\r\n        \r\n        return nums", "testcase": "print(Solution().rotate([1, 2, 3, 4, 5, 6, 7], 3), [5, 6, 7, 1, 2, 3, 4])\r\nprint(Solution().rotate([-1, -100, 3, 99], 2), [3, 99, -1, -100])\r\nprint(Solution().rotate([-1], 2), [-1])\r\nprint(Solution().rotate([1, 2], 3), [2, 1])", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-01T09:08:20.890Z", "updated_at": "2025-01-01T09:08:20.907Z"}}, {"model": "python_problems.solution", "pk": 332, "fields": {"problem": 175, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * reverse\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {void} Do not return anything, modify nums in-place instead.\r\n */\r\nvar rotate = function (nums, k) {\r\n  function reverseString(nums, left, right) {\r\n    while (left < right) {\r\n      [nums[left], nums[right]] = [nums[right], nums[left]];\r\n      left++;\r\n      right--;\r\n    }\r\n  }\r\n\r\n  k = k % nums.length;\r\n  reverseString(nums, 0, nums.length - 1);\r\n  reverseString(nums, 0, k - 1);\r\n  reverseString(nums, k, nums.length - 1);\r\n\r\n  return nums\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * slice\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {void} Do not return anything, modify nums in-place instead.\r\n */\r\nvar rotate = function (nums, k) {\r\n  const index = nums.length - k;\r\n\r\n  return [...nums.slice(index,), ...nums.slice(0, index + 1)]\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * iteration\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {void} Do not return anything, modify nums in-place instead.\r\n */\r\nvar rotate = function (nums, k) {\r\n  const numsCopy = Array(nums.length);\r\n  \r\n  for (let index = 0; index < nums.length; index++) {\r\n    numsCopy[(index + k) % nums.length] = nums[index]\r\n  }\r\n  nums = numsCopy;\r\n\r\n  return nums\r\n}", "testcase": "console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3), [5, 6, 7, 1, 2, 3, 4])\r\nconsole.log(rotate([-1, -100, 3, 99], 2), [3, 99, -1, -100])\r\nconsole.log(rotate([-1], 2), [-1])\r\nconsole.log(rotate([1, 2], 3), [2, 1])", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-01T09:09:19.964Z", "updated_at": "2025-01-01T09:09:19.985Z"}}, {"model": "python_problems.solution", "pk": 333, "fields": {"problem": 176, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# brute force\r\nclass Solution:\r\n    def numSubarraysWithSum(self, numbers: list[int], goal: int) -> int:\r\n        left = 0\r\n        window_sum = 0\r\n        window_count = 0\r\n\r\n        for right, number in enumerate(numbers):  # 1, 0, 1, 0, 1\r\n            window_sum += number\r\n            \r\n            while window_sum > goal: # 0, 1, 0, 1\r\n                window_sum -= numbers[left]\r\n                left += 1 # 1\r\n            \r\n            while numbers[left] == 0 :\r\n                window_count += 1  # [1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1]\r\n                window_sum -= numbers[left]\r\n                left += 1\r\n            \r\n            if window_sum == goal:\r\n                window_count += 1  # [1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1]\r\n\r\n\r\n        return window_count", "testcase": "print(Solution().numSubarraysWithSum([1, 0, 1, 0, 1], 2), 4)\r\nprint(Solution().numSubarraysWithSum([0, 0, 0, 0, 0], 0), 15)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-01T11:05:06.719Z", "updated_at": "2025-01-01T11:05:06.739Z"}}, {"model": "python_problems.solution", "pk": 334, "fields": {"problem": 176, "language": 2, "owner": 3, "solution": "/**\r\n * O(n3), O(n)\r\n * brute force\r\n * @param {number[]} nums\r\n * @param {number} goal\r\n * @return {number}\r\n */\r\nvar numSubarraysWithSum = function (nums, goal) {\r\n  let counter = 0;\r\n\r\n  for (let i = 0; i < nums.length; i++) {\r\n    for (let j = i; j < nums.length; j++) {\r\n      const subarraySum = nums\r\n        .slice(i, j + 1)\r\n        .reduce((total, current) => total + current);\r\n\r\n      if (subarraySum === goal) counter++;\r\n      else if (subarraySum > goal) break\r\n    }\r\n  }\r\n  return counter\r\n}", "testcase": "console.log(numSubarraysWithSum([1, 0, 1, 0, 1], 2), 4)\r\nconsole.log(numSubarraysWithSum([0, 0, 0, 0, 0], 0), 15)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-01T11:14:00.910Z", "updated_at": "2025-01-01T11:14:00.928Z"}}, {"model": "python_problems.solution", "pk": 335, "fields": {"problem": 177, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack, monotonic stack\r\n# monotonically increasing stack\r\nclass Solution:\r\n    def removeKdigits(self, numbers: str, k: int) -> str:\r\n        stack = []\r\n        \r\n        for number in numbers:\r\n            while (stack and \r\n                   k and\r\n                   number < stack[-1]):\r\n                stack.pop()\r\n                k -= 1\r\n                \r\n            stack.append(number)\r\n        \r\n        # calculate `start` where leading zeros (if present) stops\r\n        start = 0\r\n        while (start < len(stack) and \r\n               stack[start] == \"0\"):\r\n            start += 1\r\n        \r\n        # `start` to remove leading zeros and \r\n        # `len(stack) - k` to remove exceeded characters if `k` is not zero\r\n        clean_stack = stack[start: len(stack) - k]\r\n\r\n        return (\"\".join(clean_stack) \r\n                if clean_stack\r\n                else \"0\")", "testcase": "print(Solution().removeKdigits(\"1432219\", 3), \"1219\")\r\nprint(Solution().removeKdigits(\"10200\", 1), \"200\")\r\nprint(Solution().removeKdigits(\"10\", 2), \"0\")\r\nprint(Solution().removeKdigits(\"9\", 1), \"0\")\r\nprint(Solution().removeKdigits(\"112\", 1), \"11\")\r\nprint(Solution().removeKdigits(\"1173\", 2), \"11\")\r\nprint(Solution().removeKdigits(\"10\", 1), \"0\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-01T18:33:09.582Z", "updated_at": "2025-02-09T20:39:52.390Z"}}, {"model": "python_problems.solution", "pk": 336, "fields": {"problem": 177, "language": 2, "owner": 3, "solution": "/**\r\n * # O(n), O(n)\r\n * stack\r\n * @param {string} numbers\r\n * @param {number} k\r\n * @return {string}\r\n */\r\nvar removeKdigits = function (numbers, k) {\r\n  if (numbers.length == k) return \"0\"\r\n\r\n  let stack = [];\r\n\r\n  for (const number of numbers.split('')) {\r\n    while (k &&\r\n      stack[stack.length - 1] > number\r\n    ) {\r\n      stack.pop();\r\n      k--;\r\n    }\r\n\r\n    stack.push(number);\r\n  }\r\n\r\n  stack = stack.slice(0, stack.length - k)\r\n\r\n  stack.reverse();\r\n  while (stack.length > 1 &&\r\n    stack[stack.length - 1] === \"0\"\r\n  ) stack.pop()\r\n  stack.reverse();\r\n\r\n  return stack.join('')\r\n}", "testcase": "console.log(removeKdigits(\"1432219\", 3), \"1219\")\r\nconsole.log(removeKdigits(\"10200\", 1), \"200\")\r\nconsole.log(removeKdigits(\"10\", 2), \"0\")\r\nconsole.log(removeKdigits(\"9\", 1), \"0\")\r\nconsole.log(removeKdigits(\"112\", 1), \"11\")\r\nconsole.log(removeKdigits(\"1173\", 2), \"11\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-01T18:33:39.759Z", "updated_at": "2025-01-01T18:33:39.777Z"}}, {"model": "python_problems.solution", "pk": 337, "fields": {"problem": 178, "language": 1, "owner": 3, "solution": "# O(logn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def findPeakElement(self, numbers: list[int]) -> int:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n\r\n        while left <= right:\r\n            if right - left + 1 == 1:  # if word length is 1\r\n                return left\r\n\r\n            middle = left + (right - left) // 2\r\n            middle_number = numbers[middle]\r\n            previous = middle_number - 1 if middle == 0 else numbers[middle - 1]  # if left index out of bounds\r\n            next = middle_number - 1 if middle == len(numbers) - 1 else numbers[middle + 1]  # if right indext out of bounds\r\n\r\n            if (previous < middle_number and\r\n                    middle_number > next):\r\n                return middle\r\n            elif next > previous:\r\n                left = middle + 1\r\n            else:\r\n                right = middle - 1", "testcase": "print(Solution().findPeakElement([1, 2, 3, 1]), 2)\r\nprint(Solution().findPeakElement([1, 2, 1, 3, 5, 6, 4]), 5)\r\nprint(Solution().findPeakElement([1]), 0)\r\nprint(Solution().findPeakElement([1, 2]), 1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2025-01-02T16:57:43.593Z", "updated_at": "2025-01-02T16:57:43.614Z"}}, {"model": "python_problems.solution", "pk": 338, "fields": {"problem": 178, "language": 2, "owner": 3, "solution": "/**\r\n * O(logn), O(1)\r\n * binary search\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar findPeakElement = function (numbers) {\r\n  let left = 0;\r\n  let right = numbers.length - 1;\r\n\r\n  while (left <= right) {\r\n    const middle = left + (right - left) / 2 | 0;\r\n    const middleNumber = numbers[middle];\r\n    const previous = middle === 0 ? middleNumber - 1 : numbers[middle - 1];\r\n    const next = middle === numbers.length - 1 ? middleNumber - 1 : numbers[middle + 1];\r\n\r\n    if (\r\n      previous < middleNumber &&\r\n      middleNumber > next\r\n    ) return middle\r\n    else if (next > previous) left = middle + 1;\r\n    else right = middle - 1;\r\n  }\r\n}", "testcase": "console.log(findPeakElement([1, 2, 3, 1]), 2)\r\nconsole.log(findPeakElement([1, 2, 1, 3, 5, 6, 4]), 5)\r\nconsole.log(findPeakElement([1]), 0)\r\nconsole.log(findPeakElement([1, 2]), 1)", "time_complexity": 4, "space_complexity": 1, "created_at": "2025-01-02T17:04:08.637Z", "updated_at": "2025-01-02T17:04:08.660Z"}}, {"model": "python_problems.solution", "pk": 339, "fields": {"problem": 179, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\n# O(n), O(1)\r\n# linked list, two pass\r\nclass Solution:\r\n    def pairSum(self, head: ListNode | None) -> int:\r\n        twin_sum = 0\r\n\r\n        # find the last node of the left portion\r\n        slow, fast = head, head\r\n        previous = None\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            nextSlow = slow.next\r\n            # reverse the left portion\r\n            slow.next = previous\r\n            previous = slow\r\n            slow = nextSlow\r\n\r\n        # traverse through the list to find the twin sum\r\n        while previous:\r\n            twin_sum = max(twin_sum, previous.val + slow.val)\r\n            previous = previous.next\r\n            slow = slow.next\r\n\r\n        return twin_sum\r\n\r\n\r\n# O(n), O(1)\r\n# linked list, three pass\r\nclass Solution:\r\n    def pairSum(self, head: ListNode | None) -> int:\r\n        node = head\r\n        index = 1\r\n        twin_sum = 0\r\n\r\n        # find the length of the linked list\r\n        while node and node.next:\r\n            node = node.next\r\n            index += 1\r\n        \r\n        node = head\r\n        middle = index // 2\r\n        # fast forward to the right portion\r\n        for _ in range(middle):\r\n            node = node.next\r\n\r\n        # reverse the right portion\r\n        previous = None\r\n        while node:\r\n            next_node = node.next\r\n            node.next = previous\r\n            previous = node\r\n            node = next_node\r\n        \r\n        # traverse through the list to find the twin sum\r\n        right_head = previous\r\n        while right_head:\r\n            twin_sum = max(twin_sum, head.val + right_head.val)\r\n            head = head.next\r\n            right_head = right_head.next\r\n\r\n        return twin_sum", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-03T00:02:55.295Z", "updated_at": "2025-01-03T00:02:55.315Z"}}, {"model": "python_problems.solution", "pk": 340, "fields": {"problem": 179, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * O(n), O(1)\r\n * linked list, three pass\r\n * @param {ListNode} head\r\n * @return {number}\r\n */\r\nvar pairSum = function (head) {\r\n  let twinSum = 0;\r\n  let node = head;\r\n  let index = 1;\r\n\r\n  // find the length of the linked list\r\n  while (node.next) {\r\n    node = node.next;\r\n    index++;\r\n  }\r\n\r\n  middle = index / 2;\r\n  node = head;\r\n  // fast forward to the right portion\r\n  for (let index = 0; index < middle; index++) {\r\n    node = node.next;\r\n  }\r\n\r\n  // reverse the right portion\r\n  let previous = null;\r\n  while (node) {\r\n    const nextNode = node.next;\r\n    node.next = previous;\r\n    previous = node;\r\n    node = nextNode;\r\n  }\r\n\r\n  // traverse through the list to find the twin sum\r\n  while (previous) {\r\n    twinSum = Math.max(twinSum, head.val + previous.val)\r\n    head = head.next;\r\n    previous = previous.next;\r\n  }\r\n\r\n  return twinSum\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-03T00:03:18.938Z", "updated_at": "2025-01-03T00:03:18.955Z"}}, {"model": "python_problems.solution", "pk": 341, "fields": {"problem": 180, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\nclass Solution:\r\n    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:\r\n        def dfs(node, targetSum):\r\n            if not node:\r\n                return False\r\n            elif not node.left and not node.right:\r\n                return targetSum - node.val == 0\r\n\r\n            return (dfs(node.left, targetSum - node.val) or\r\n                    dfs(node.right, targetSum - node.val))\r\n\r\n        return dfs(root, targetSum)", "testcase": "print(Solution().hasPathSum(build_tree_from_list([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, 1]), 22), True)\r\nprint(Solution().hasPathSum(build_tree_from_list([1, 2, 3]), 5), False)\r\nprint(Solution().hasPathSum(build_tree_from_list([]), 0), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-03T07:50:28.348Z", "updated_at": "2025-01-03T07:50:28.368Z"}}, {"model": "python_problems.solution", "pk": 342, "fields": {"problem": 180, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @param {number} targetSum\r\n * @return {boolean}\r\n */\r\nvar hasPathSum = function (root, targetSum) {\r\n  function dfs(node, targetSum) {\r\n    if (!node) return false\r\n    else if (\r\n      !node.left &&\r\n      !node.right &&\r\n      targetSum - node.val === 0\r\n    ) return true\r\n\r\n    return (dfs(node.left, targetSum - node.val) ||\r\n      dfs(node.right, targetSum - node.val))\r\n  }\r\n\r\n  return dfs(root, targetSum)\r\n}", "testcase": "console.log(hasPathSum(buildTreeFromList([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, 1]), 22), True)\r\nconsole.log(hasPathSum(buildTreeFromList([1, 2, 3]), 5), False)\r\nconsole.log(hasPathSum(buildTreeFromList([]), 0), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-03T07:51:29.997Z", "updated_at": "2025-01-03T07:51:30.016Z"}}, {"model": "python_problems.solution", "pk": 343, "fields": {"problem": 181, "language": 1, "owner": 3, "solution": "# O(n2^n), O(n)\r\n# backtracking\r\n# subset sum as a list\r\nclass Solution:\r\n    def subsetXORSum(self, numbers: list[int]) -> int:\r\n        subset = []\r\n        subset_list = []\r\n\r\n        def dfs(index):\r\n            if index == len(numbers):\r\n                current = 0\r\n\r\n                for digit in subset:\r\n                    current ^= digit\r\n\r\n                subset_list.append(current)\r\n                return\r\n\r\n            subset.append(numbers[index])\r\n            dfs(index + 1)\r\n            subset.pop()\r\n            dfs(index + 1)\r\n\r\n        dfs(0)\r\n        return sum(subset_list)\r\n\r\n\r\n# O(n2^n), O(n)\r\n# backtracking\r\n# subset sum as class (immutable) value\r\nclass Solution:\r\n    def __init__(self):\r\n        self.subset_sum = 0\r\n        \r\n    def subsetXORSum(self, numbers: list[int]) -> int:\r\n        subset = []\r\n\r\n        def dfs(index):\r\n            if index == len(numbers):\r\n                current = 0\r\n\r\n                for digit in subset:\r\n                    current ^= digit\r\n\r\n                self.subset_sum += current\r\n                return\r\n\r\n            subset.append(numbers[index])\r\n            dfs(index + 1)\r\n            subset.pop()\r\n            dfs(index + 1)\r\n\r\n        dfs(0)\r\n\r\n        return self.subset_sum\r\n\r\n\r\n# O(n2^n), O(2^n)\r\n# backtracking\r\n# subset sum passed as a funcion parameter\r\nclass Solution:\r\n    def subsetXORSum(self, numbers: list[int]) -> int:\r\n        def dfs(index, subset_sum):\r\n            if index == len(numbers):\r\n                return subset_sum\r\n\r\n            return (dfs(index + 1, subset_sum ^ numbers[index]) + \r\n                    dfs(index + 1, subset_sum))\r\n\r\n        return dfs(0, 0)\r\n\r\n\r\n# O(n2^n), O(2^n)\r\n# backtracking\r\n# subset sum as an (immutable) integer\r\nclass Solution:\r\n    def subsetXORSum(self, numbers: list[int]) -> int:\r\n        subset = []\r\n\r\n        def dfs(index, subset_sum):\r\n            if index == len(numbers):\r\n                current = 0\r\n\r\n                for digit in subset:\r\n                    current ^= digit\r\n\r\n                subset_sum += current\r\n                return subset_sum\r\n\r\n            subset.append(numbers[index])\r\n            sum_with = dfs(index + 1, subset_sum)\r\n            subset.pop()\r\n            sum_without = dfs(index + 1, subset_sum)\r\n\r\n            return sum_with + sum_without\r\n\r\n        return dfs(0, 0)", "testcase": "print(Solution().subsetXORSum([1, 3]), 6)\r\nprint(Solution().subsetXORSum([5, 1, 6]), 28)\r\nprint(Solution().subsetXORSum([3, 4, 5, 6, 7, 8]), 480)", "time_complexity": 7, "space_complexity": 2, "created_at": "2025-01-03T12:33:00.607Z", "updated_at": "2025-01-03T12:33:00.628Z"}}, {"model": "python_problems.solution", "pk": 344, "fields": {"problem": 181, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2^n), O(n)\r\n * backtracking\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar subsetXORSum = function (numbers) {\r\n  const subset = [];\r\n  const subsetSum = [];\r\n\r\n  function dfs(index) {\r\n    if (index === numbers.length) {\r\n      let current = 0;\r\n      for (const digit of subset) current ^= digit;\r\n      subsetSum.push(current);\r\n      return\r\n    }\r\n\r\n    subset.push(numbers[index]);\r\n    dfs(index + 1)\r\n    subset.pop();\r\n    dfs(index + 1)\r\n  }\r\n\r\n  dfs(0)\r\n  return subsetSum.reduce((total, current) => total + current)\r\n}", "testcase": "console.log(subsetXORSum([1, 3]), 6)\r\nconsole.log(subsetXORSum([5, 1, 6]), 28)\r\nconsole.log(subsetXORSum([3, 4, 5, 6, 7, 8]), 480)", "time_complexity": 7, "space_complexity": 2, "created_at": "2025-01-03T12:34:12.862Z", "updated_at": "2025-01-03T12:34:12.885Z"}}, {"model": "python_problems.solution", "pk": 345, "fields": {"problem": 182, "language": 1, "owner": 3, "solution": "# O(n^k), O(n)\r\n# backtracking\r\nclass Solution:\r\n    def combine(self, n: int, k: int) -> list[list[int]]:\r\n        combination = []\r\n        combination_list = []\r\n\r\n        def dfs(index):\r\n            if index == n:\r\n                if len(combination) == k:\r\n                    combination_list.append(combination.copy())\r\n                return\r\n\r\n            combination.append(index + 1)\r\n            dfs(index + 1)\r\n            combination.pop()\r\n            dfs(index + 1)\r\n\r\n        dfs(0)\r\n        return combination_list\r\n\r\n\r\n# O(n^k), O(n)\r\n# backtracking\r\nclass Solution:\r\n    def combine(self, n: int, k: int) -> list[list[int]]:\r\n        combination_list = []\r\n\r\n        def dfs(index, combination):\r\n            if index == n:\r\n                if len(combination) == k:\r\n                    combination_list.append(combination.copy())\r\n                return\r\n\r\n            combination.append(index + 1)\r\n            dfs(index + 1, combination)\r\n            combination.pop()\r\n            dfs(index + 1, combination)\r\n\r\n        dfs(0, [])\r\n        return combination_list", "testcase": "print(Solution().combine(4, 2), [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]])\r\nprint(Solution().combine(1, 1), [[1]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2025-01-03T14:31:57.066Z", "updated_at": "2025-01-03T14:51:38.232Z"}}, {"model": "python_problems.solution", "pk": 346, "fields": {"problem": 182, "language": 2, "owner": 3, "solution": "/**\r\n * O(n^k), O(n)\r\n * backtracking\r\n * @param {number} n\r\n * @param {number} k\r\n * @return {number[][]}\r\n */\r\nvar combine = function (n, k) {\r\n  const combinatioin = [];\r\n  const combinatioinList = [];\r\n\r\n  function dfs(index) {\r\n    if (index === n) {\r\n      if (combinatioin.length === k) {\r\n        combinatioinList.push(combinatioin.slice())\r\n      }\r\n      return\r\n    }\r\n\r\n    combinatioin.push(index + 1);\r\n    dfs(index + 1)\r\n    combinatioin.pop();\r\n    dfs(index + 1)\r\n  }\r\n\r\n  dfs(0)\r\n  return combinatioinList\r\n}", "testcase": "console.log(combine(4, 2), [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]])\r\nconsole.log(combine(1, 1), [[1]])", "time_complexity": 7, "space_complexity": 2, "created_at": "2025-01-03T14:51:26.903Z", "updated_at": "2025-01-03T14:51:26.924Z"}}, {"model": "python_problems.solution", "pk": 347, "fields": {"problem": 183, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\nclass Solution:\r\n    def isMonotonic(self, numbers: list[int]) -> bool:\r\n        increasing = True\r\n        decreasing = True\r\n\r\n        for index in range(1, len(numbers)):\r\n            # chieck if the stack is monoconicly increasing\r\n            if numbers[index - 1] > numbers[index]:\r\n                increasing = False\r\n            # chieck if the stack is monoconicly decreasing\r\n            if numbers[index - 1] < numbers[index]:\r\n                decreasing = False\r\n            # early exit\r\n            if (not increasing and\r\n                not decreasing):\r\n                return False\r\n            \r\n        return (increasing or \r\n                decreasing)", "testcase": "print(Solution().isMonotonic(1, 2, 2, 3), True)\r\nprint(Solution().isMonotonic(6, 5, 4, 4), True)\r\nprint(Solution().isMonotonic(1, 3, 2), False)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-04T14:53:00.690Z", "updated_at": "2025-01-04T14:53:00.711Z"}}, {"model": "python_problems.solution", "pk": 348, "fields": {"problem": 183, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * @param {number[]} numbers\r\n * @return {boolean}\r\n */\r\nvar isMonotonic = function (numbers) {\r\n  let increasing = true;\r\n  let decreasing = true;\r\n\r\n  for (let index = 1; index < numbers.length; index++) {\r\n    if (numbers[index - 1] < numbers[index]) increasing = false;\r\n    if (numbers[index - 1] > numbers[index]) decreasing = false;\r\n    if (!increasing && !decreasing) return false\r\n  }\r\n  return (increasing || decreasing)\r\n}", "testcase": "console.log(isMonotonic(1, 2, 2, 3), true)\r\nconsole.log(isMonotonic(6, 5, 4, 4), true)\r\nconsole.log(isMonotonic(1, 3, 2), false)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-04T14:54:29.506Z", "updated_at": "2025-01-04T14:59:24.656Z"}}, {"model": "python_problems.solution", "pk": 349, "fields": {"problem": 184, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\nclass Solution:\r\n    def numIdenticalPairs(self, numbers: list[int]) -> int:\r\n        counter = {}  # {number: frequency}\r\n        pair_counter = 0\r\n\r\n        # count numbers\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n        \r\n        # count identical pairs\r\n        for frequency in counter.values():\r\n            pair_counter += frequency * (frequency - 1) // 2\r\n        \r\n        return pair_counter", "testcase": "print(Solution().numIdenticalPairs([1, 2, 3, 1, 1, 3]), 4)\r\nprint(Solution().numIdenticalPairs([1, 1, 1, 1]), 6)\r\nprint(Solution().numIdenticalPairs([1, 2, 3]), 0)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-04T17:59:36.358Z", "updated_at": "2025-01-04T17:59:36.377Z"}}, {"model": "python_problems.solution", "pk": 350, "fields": {"problem": 184, "language": 2, "owner": 3, "solution": "/**\r\n * # O(n), O(n)\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar numIdenticalPairs = function (numbers) {\r\n  const counter = new Map();\r\n  let pairCounter = 0;\r\n\r\n  for (const number of numbers) {\r\n    counter.set(number, (counter.get(number) ?? 0) + 1);\r\n  }\r\n\r\n  for (const frequency of counter.values()) {\r\n    pairCounter += frequency * (frequency - 1) / 2\r\n  }\r\n\r\n  return pairCounter\r\n}", "testcase": "console.log(numIdenticalPairs([1, 2, 3, 1, 1, 3]), 4)\r\nconsole.log(numIdenticalPairs([1, 1, 1, 1]), 6)\r\nconsole.log(numIdenticalPairs([1, 2, 3]), 0)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-04T18:00:04.742Z", "updated_at": "2025-01-04T18:00:04.765Z"}}, {"model": "python_problems.solution", "pk": 351, "fields": {"problem": 185, "language": 1, "owner": 3, "solution": "# O(nlogn), O(n)\r\n# two pointers\r\nclass Solution:\r\n    def numSubseq(self, numbers: list[int], target: int) -> int:\r\n        numbers.sort()\r\n        right = len(numbers) - 1\r\n        counter = 0\r\n\r\n        for left in range(len(numbers)):\r\n            while (left <= right and \r\n                   numbers[left] + numbers[right] > target):\r\n                right -= 1\r\n\r\n            if left <= right:\r\n                counter += 2 ** (right - left)\r\n                counter %= 10**9 + 7\r\n            \r\n            if left == right:\r\n                break\r\n\r\n        return counter\r\n\r\n\r\n# O(n2^n), O(n)\r\n# backtracking\r\n# slow\r\nclass Solution:\r\n    def __init__(self):\r\n        self.counter = 0\r\n\r\n    def numSubseq(self, numbers: list[int], target: int) -> int:\r\n        numbers.sort()\r\n        subsequence = []\r\n\r\n        def dfs(index):\r\n            if index == len(numbers):\r\n                if (subsequence and \r\n                        subsequence[0] + subsequence[-1] <= target):\r\n                    self.counter += 1\r\n                return\r\n            \r\n            subsequence.append(numbers[index])\r\n            dfs(index + 1)\r\n            subsequence.pop()\r\n            dfs(index + 1)\r\n\r\n        dfs(0)\r\n        return self.counter % (10 ** 9 + 7)\r\n\r\n\r\n# O(n2^n), O(n)\r\n# backtracking\r\n# slow\r\nclass Solution:\r\n    def numSubseq(self, numbers: list[int], target: int) -> int:\r\n        numbers.sort()\r\n        subsequence = []\r\n\r\n        def dfs(index, counter):\r\n            if index == len(numbers):\r\n                if (subsequence and \r\n                        subsequence[0] + subsequence[-1] <= target):\r\n                    return 1\r\n                else:\r\n                    return 0\r\n            \r\n            subsequence.append(numbers[index])\r\n            left = dfs(index + 1, counter)\r\n            subsequence.pop()\r\n            right = dfs(index + 1, counter)\r\n            return (left + right) % (10 ** 9 + 7)\r\n\r\n        return dfs(0, 0)", "testcase": "print(Solution().numSubseq([3, 5, 6, 7], 9), 4)\r\nprint(Solution().numSubseq([3, 3, 6, 8], 10), 6)\r\nprint(Solution().numSubseq([2, 3, 3, 4, 6, 7], 12), 61)\r\nprint(Solution().numSubseq([7, 10, 7, 3, 7, 5, 4], 12), 56)\r\nprint(Solution().numSubseq([14,4,6,6,20,8,5,6,8,12,6,10,14,9,17,16,9,7,14,11,14,15,13,11,10,18,13,17,17,14,17,7,9,5,10,13,8,5,18,20,7,5,5,15,19,14], 22), 272187084)\r\nprint(Solution().numSubseq([9,25,9,28,24,12,17,8,28,7,21,25,10,2,16,19,12,13,15,28,14,12,24,9,6,7,2,15,19,13,30,30,23,19,11,3,17,2,14,20,22,30,12,1,11,2,2,20,20,27,15,9,10,4,12,30,13,5,2,11,29,5,3,13,22,5,16,19,7,19,11,16,11,25,29,21,29,3,2,9,20,15,9], 32), 91931447)", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-05T08:43:10.746Z", "updated_at": "2025-01-05T08:43:10.768Z"}}, {"model": "python_problems.solution", "pk": 352, "fields": {"problem": 185, "language": 2, "owner": 3, "solution": "/**\r\n * O(nlogn), O(n)\r\n * two pointers\r\n * @param {number[]} numbers\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar numSubseq = function (numbers, target) {\r\n  numbers.sort((a, b) => a - b);\r\n  let counter = 0;\r\n  let right = numbers.length - 1;\r\n  const mod = 10 ** 9 + 7;\r\n  const powerOfTwo = [1];\r\n  \r\n  for (let index = 1; index < numbers.length; index++) {\r\n    powerOfTwo[index] = powerOfTwo[index - 1] * 2 % mod\r\n  }\r\n\r\n  for (let left = 0; left < numbers.length; left++) {\r\n    while (\r\n      left <= right &&\r\n      numbers[left] + numbers[right] > target\r\n    ) right--;\r\n\r\n    if (left <= right) {\r\n      counter += powerOfTwo[right - left];\r\n      counter %= mod;\r\n    }\r\n  }\r\n\r\n  return Number(counter)\r\n}", "testcase": "console.log(numSubseq([3, 5, 6, 7], 9), 4)\r\nconsole.log(numSubseq([3, 3, 6, 8], 10), 6)\r\nconsole.log(numSubseq([2, 3, 3, 4, 6, 7], 12), 61)\r\nconsole.log(numSubseq([7, 10, 7, 3, 7, 5, 4], 12), 56)\r\nconsole.log(numSubseq([14, 4, 6, 6, 20, 8, 5, 6, 8, 12, 6, 10, 14, 9, 17, 16, 9, 7, 14, 11, 14, 15, 13, 11, 10, 18, 13, 17, 17, 14, 17, 7, 9, 5, 10, 13, 8, 5, 18, 20, 7, 5, 5, 15, 19, 14], 22), 272187084)\r\nconsole.log(numSubseq([9,25,9,28,24,12,17,8,28,7,21,25,10,2,16,19,12,13,15,28,14,12,24,9,6,7,2,15,19,13,30,30,23,19,11,3,17,2,14,20,22,30,12,1,11,2,2,20,20,27,15,9,10,4,12,30,13,5,2,11,29,5,3,13,22,5,16,19,7,19,11,16,11,25,29,21,29,3,2,9,20,15,9], 32), 91931447)", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-05T08:43:46.977Z", "updated_at": "2025-01-05T08:43:46.997Z"}}, {"model": "python_problems.solution", "pk": 353, "fields": {"problem": 186, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# sliding window\r\nclass Solution:\r\n    def numSubarrayProductLessThanK(self, numbers: list[int], k: int) -> int:\r\n        left = 0\r\n        window = 1\r\n        counter = 0\r\n        \r\n        for right in range(len(numbers)):\r\n            window *= numbers[right]  # add a number to the window\r\n\r\n            while (left <= right and  # while in bounds and\r\n                   window >= k):  # product is too large\r\n                window //= numbers[left]  # subtract a number from the window\r\n                left += 1\r\n\r\n            counter += right - left + 1  # add the number of contiguous subarrays\r\n            # every new `number` adds new number to all previous arrays\r\n            # [5, 2] + [6], [2] + [6], [6]\r\n            # eg. add 3 for [5, 2, 6], where in previous loop added 2 for [5, 2]\r\n            \r\n        return counter", "testcase": "print(Solution().numSubarrayProductLessThanK([10, 5, 2, 6], 100), 8)\r\nprint(Solution().numSubarrayProductLessThanK([1, 2, 3], 0), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-05T11:44:41.089Z", "updated_at": "2025-02-04T02:35:23.160Z"}}, {"model": "python_problems.solution", "pk": 354, "fields": {"problem": 186, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * sliding window\r\n * @param {number[]} numbers\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar numSubarrayProductLessThanK = function (numbers, k) {\r\n  let left = 0;\r\n  let window = 1;\r\n  let counter = 0;\r\n\r\n  for (let right = 0; right < numbers.length; right++) {\r\n    window *= numbers[right];\r\n\r\n    while (\r\n      left <= right &&\r\n      window >= k\r\n    ) {\r\n      window /= numbers[left];\r\n      left++;\r\n    }\r\n\r\n    counter += right - left + 1;\r\n  }\r\n\r\n  return counter\r\n}", "testcase": "console.log(numSubarrayProductLessThanK([10, 5, 2, 6], 100), 8)\r\nconsole.log(numSubarrayProductLessThanK([1, 2, 3], 0), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-05T11:45:08.546Z", "updated_at": "2025-01-05T11:45:08.564Z"}}, {"model": "python_problems.solution", "pk": 355, "fields": {"problem": 187, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def removeDuplicates(self, letters: str, k: int) -> str:\r\n        stack = []  # [[letter, frequency]]\r\n\r\n        for letter in letters:\r\n            if (stack and \r\n                    stack[-1][0] == letter):\r\n                stack[-1][1] += 1\r\n                \r\n                if (stack[-1][1] == k):\r\n                    stack.pop()\r\n\r\n            else:\r\n                stack.append([letter, 1])\r\n\r\n        return \"\".join(letter * frequency \r\n                       for letter, frequency in stack)\r\n\r\n\r\n# O(n), O(n)\r\n# stack\r\nclass Solution:\r\n    def removeDuplicates(self, letters: str, k: int) -> str:\r\n        stack = []  # [(letter, frequency)]\r\n\r\n        for letter in letters:\r\n            if (stack and \r\n                stack[-1][0] == letter and\r\n                    stack[-1][1] == k - 1):\r\n                for _ in range(k - 1):\r\n                    stack.pop()\r\n            elif (stack and \r\n                    stack[-1][0] == letter):\r\n                stack.append((letter, stack[-1][1] + 1))\r\n            else:\r\n                stack.append((letter, 1))\r\n\r\n        return \"\".join(letter for letter, _ in stack)\r\n\r\n\r\n# O(n2), O(n)\r\nclass Solution:\r\n    def removeDuplicates(self, letters: str, k: int) -> str:\r\n        stack = []\r\n\r\n        for letter in letters:\r\n            is_substring = False\r\n\r\n            if (stack and \r\n                    len(stack) >= k - 1):\r\n                is_substring = True\r\n                \r\n                for index in range(1, k):\r\n                    if stack[-index] != letter:\r\n                        is_substring = False\r\n                        break\r\n                \r\n                if is_substring:\r\n                    for _ in range(k - 1):\r\n                        stack.pop()\r\n            \r\n            if not is_substring:\r\n                stack.append(letter)\r\n        \r\n        return \"\".join(stack)", "testcase": "print(Solution().removeDuplicates(\"abcd\", 2), \"abcd\")\r\nprint(Solution().removeDuplicates(\"deeedbbcccbdaa\", 3), \"aa\")\r\nprint(Solution().removeDuplicates(\"pbbcggttciiippooaais\", 2), \"ps\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-05T13:29:12.682Z", "updated_at": "2025-01-05T13:29:12.700Z"}}, {"model": "python_problems.solution", "pk": 356, "fields": {"problem": 187, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * stack\r\n * @param {string} letters\r\n * @param {number} k\r\n * @return {string}\r\n */\r\nvar removeDuplicates = function (letters, k) {\r\n  const stack = [];  // [[letter, frequency]]\r\n\r\n  for (const letter of letters) {\r\n    if (\r\n      stack.length > 0 &&\r\n      stack[stack.length - 1][0] === letter\r\n    ) {\r\n      stack[stack.length - 1][1] += 1;\r\n\r\n      if (stack[stack.length - 1][1] === k)\r\n        stack.pop();\r\n    }\r\n    else { stack.push([letter, 1]); }\r\n\r\n  }\r\n\r\n  return (stack\r\n    .map(([letter, frequency]) => letter.repeat(frequency))\r\n    .join(''))\r\n}", "testcase": "console.log(removeDuplicates('abcd', 2), 'abcd')\r\nconsole.log(removeDuplicates('deeedbbcccbdaa', 3), 'aa')\r\nconsole.log(removeDuplicates('pbbcggttciiippooaais', 2), 'ps')", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-05T13:29:59.230Z", "updated_at": "2025-01-05T13:29:59.246Z"}}, {"model": "python_problems.solution", "pk": 357, "fields": {"problem": 188, "language": 1, "owner": 3, "solution": "# blueprint\r\n# [lm5,r10,15,20,25]\r\n# [1, 2, 3, l4, r5]\r\n# [3, 6, lr9, 12, 15]\r\n\r\n\r\n# O(nlogn), O(n)\r\n# binary search\r\nclass Solution:\r\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\r\n        potions.sort()\r\n        success_list = [0] * len(spells)\r\n\r\n        for index, spell in enumerate(spells):\r\n            left = 0\r\n            right = len(potions) - 1\r\n\r\n            while left < right:\r\n                middle = left + (right - left) // 2\r\n                middle_potion = potions[middle]\r\n\r\n                if middle_potion * spell < success:\r\n                    left = middle + 1\r\n                else:\r\n                    right = middle\r\n\r\n            if potions[right] * spell >= success:\r\n                success_list[index] = len(potions) - right\r\n        \r\n        return success_list", "testcase": "print(Solution().successfulPairs([5, 1, 3], [1, 2, 3, 4, 5], 7), [4, 0, 3])\r\nprint(Solution().successfulPairs([3, 1, 2], [8, 5, 8], 16), [2, 0, 2])\r\nprint(Solution().successfulPairs([39, 34, 6, 35, 18, 24, 40], [27, 37, 33, 34, 14, 7, 23, 12, 22, 37], 43), [10, 10, 9, 10, 10, 10, 10])", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-05T15:43:19.593Z", "updated_at": "2025-01-05T15:49:53.908Z"}}, {"model": "python_problems.solution", "pk": 358, "fields": {"problem": 188, "language": 2, "owner": 3, "solution": "/**\r\n * O(nlogn), O(n)\r\n * binary search\r\n * @param {number[]} spells\r\n * @param {number[]} potions\r\n * @param {number} success\r\n * @return {number[]}\r\n */\r\nvar successfulPairs = function (spells, potions, success) {\r\n  potions.sort((a, b) => a - b);\r\n  const successList = Array(spells.length).fill(0);\r\n\r\n  for (let index = 0; index < spells.length; index++) {\r\n    const spell = spells[index];\r\n    let left = 0;\r\n    let right = potions.length - 1;\r\n\r\n    while (left < right) {\r\n      const middle = left + (right - left) / 2 | 0;\r\n\r\n      if (potions[middle] * spell < success) \r\n        left = middle + 1;\r\n      else\r\n        right = middle;\r\n    }\r\n\r\n    if (potions[right] * spell >= success)\r\n      successList[index] = potions.length - right;\r\n  }\r\n  \r\n  return successList\r\n}", "testcase": "console.log(successfulPairs([5, 1, 3], [1, 2, 3, 4, 5], 7), [4, 0, 3])\r\nconsole.log(successfulPairs([3, 1, 2], [8, 5, 8], 16), [2, 0, 2])\r\nconsole.log(successfulPairs([39, 34, 6, 35, 18, 24, 40], [27, 37, 33, 34, 14, 7, 23, 12, 22, 37], 43), [10, 10, 9, 10, 10, 10, 10])", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-05T15:49:19.149Z", "updated_at": "2025-01-05T15:49:19.168Z"}}, {"model": "python_problems.solution", "pk": 359, "fields": {"problem": 189, "language": 1, "owner": 3, "solution": "# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n\r\n# O(n), O(1)\r\n# linked list\r\n# one pass\r\nclass Solution:\r\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\r\n        left = head\r\n        right = head\r\n        node = head\r\n\r\n        for _ in range(k - 1):  # move both pointers\r\n            left = left.next\r\n            node = node.next\r\n    \r\n        # when node reaches the last node, right reaches its destination\r\n        while node.next:\r\n            node = node.next\r\n            right = right.next\r\n        \r\n        # swap the node values\r\n        left.val, right.val = right.val, left.val\r\n\r\n        return head\r\n\r\n\r\n# O(n), O(1)\r\n# linked list\r\n# two pass\r\nclass Solution:\r\n    \"\"\"\r\n    right node index: list_lenght - k + 1 \r\n    nodes distance: list_lenght - 2k + 1 # 5 - 4 + 1 = 2, 10 - 10 + 1 \r\n    \"\"\"\r\n    def swapNodes(self, head: ListNode, k: int) -> ListNode:\r\n        # get list length\r\n        list_length = 0\r\n        node = head\r\n\r\n        while node:\r\n            list_length += 1\r\n            node = node.next\r\n        \r\n        k = min(k, list_length - k + 1)  # k cannot exceed half of the linked list\r\n\r\n        # move pointers to the right positions\r\n        left = head\r\n        right = head\r\n\r\n        for _ in range(list_length - 2*k + 1):  # move the right pointer by the distance between those two\r\n            right = right.next\r\n        \r\n        for _ in range(k - 1):  # move both pointers\r\n            left = left.next\r\n            right = right.next\r\n        \r\n        # swap the node values\r\n        left.val, right.val = right.val, left.val\r\n\r\n        return head", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-06T13:38:34.847Z", "updated_at": "2025-01-06T13:38:34.870Z"}}, {"model": "python_problems.solution", "pk": 360, "fields": {"problem": 189, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * O(n), O(1)\r\n * linked list, one pass\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar swapNodes = function (head, k) {\r\n  let node = head;\r\n  let left = head;\r\n  let right = head;\r\n\r\n  for (let index = 0; index < k - 1; index++) {\r\n    left = left.next;\r\n    node = node.next;\r\n  }\r\n\r\n  while (node.next) {\r\n    node = node.next;\r\n    right = right.next;\r\n  }\r\n\r\n  [left.val, right.val] = [right.val, left.val];\r\n\r\n  return head\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-06T13:43:25.179Z", "updated_at": "2025-01-06T13:43:25.199Z"}}, {"model": "python_problems.solution", "pk": 361, "fields": {"problem": 190, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n# O(n), O(n)\r\n# binary tree\r\nclass Solution:\r\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\r\n        def dfs(node):\r\n            if not node:\r\n                return 0\r\n            \r\n            return (\r\n                (node.val if node.val >= low and node.val <= high else 0) +\r\n                (dfs(node.left) if  node.val > low else 0) + \r\n                (dfs(node.right) if  node.val < high else 0))\r\n\r\n        return dfs(root)\r\n\r\n\r\n# O(n), O(n)\r\n# binary tree\r\nclass Solution:\r\n    def __init__(self):\r\n        self.total = 0\r\n\r\n    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\r\n        def dfs(node):\r\n            if not node:\r\n                return\r\n            \r\n            if (node.val >= low and \r\n                    node.val <= high):\r\n                self.total += node.val\r\n            \r\n            if node.val > low:\r\n                dfs(node.left)\r\n            if node.val < high:\r\n                dfs(node.right)\r\n        \r\n        dfs(root)\r\n        return self.total", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-06T15:06:51.876Z", "updated_at": "2025-01-06T15:06:51.895Z"}}, {"model": "python_problems.solution", "pk": 362, "fields": {"problem": 190, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * O(n), O(n)\r\n * binary tree\r\n * @param {TreeNode} root\r\n * @param {number} low\r\n * @param {number} high\r\n * @return {number}\r\n */\r\nvar rangeSumBST = function (root, low, high) {\r\n  let total = 0;\r\n\r\n  function dfs(node) {\r\n    if (!node) return\r\n\r\n    total += (node.val >= low && node.val <= high) ? node.val : 0;\r\n\r\n    if (node.val > low) dfs(node.left);\r\n    if (node.val < high) dfs(node.right);\r\n  }\r\n\r\n  dfs(root)\r\n  return total\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * binary tree\r\n * @param {TreeNode} root\r\n * @param {number} low\r\n * @param {number} high\r\n * @return {number}\r\n */\r\nvar rangeSumBST = function (root, low, high) {\r\n  function dfs(node) {\r\n    if (!node) return 0\r\n\r\n    return (\r\n        ((node.val >= low && node.val <= high) ? node.val : 0) +\r\n        (node.val > low ? dfs(node.left) : 0) +\r\n        (node.val < high ? dfs(node.right) : 0)\r\n    )\r\n  }\r\n\r\n  return dfs(root)\r\n}", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-06T15:07:11.545Z", "updated_at": "2025-01-06T15:07:11.575Z"}}, {"model": "python_problems.solution", "pk": 363, "fields": {"problem": 191, "language": 1, "owner": 3, "solution": "# O(n!), O(n!)\r\n# backtracking, set\r\nclass Solution:\r\n    def permuteUnique(self, numbers: list[int]) -> list[list[int]]:\r\n        permutation = []\r\n        permutation_set = set()\r\n\r\n        def dfs(numbers):\r\n            if not numbers:\r\n                permutation_set.add(tuple(permutation))\r\n                return\r\n\r\n            for index, number in enumerate(numbers):\r\n                permutation.append(number)\r\n                dfs(numbers[:index] + numbers[index + 1:])\r\n                permutation.pop()\r\n\r\n        dfs(numbers)\r\n        return list(permutation_set)\r\n\r\n\r\n# O(n!), O(n!)\r\n# backtracking, set\r\nclass Solution:\r\n    def permuteUnique(self, numbers: list[int]) -> list[list[int]]:\r\n        permutation_set = set()\r\n\r\n        def dfs(left):\r\n            if left == len(numbers):\r\n                permutation_set.add(tuple(numbers))\r\n                return\r\n\r\n            for right in range(left, len(numbers)):\r\n                numbers[left], numbers[right] = numbers[right], numbers[left]\r\n                dfs(left + 1)\r\n                numbers[left], numbers[right] = numbers[right], numbers[left]\r\n\r\n        dfs(0)\r\n        return list(permutation_set)\r\n\r\n\r\n# O(n!), O(n!)\r\n# backtracking, hash map\r\nclass Solution:\r\n    def permuteUnique(self, numbers: list[int]) -> list[list[int]]:\r\n        permutation = []\r\n        permutation_list = []\r\n        counter = {}\r\n\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n\r\n        def dfs():\r\n            if len(permutation) == len(numbers):\r\n                permutation_list.append(permutation[:])\r\n                return\r\n\r\n            for number in counter:\r\n                if counter[number] > 0:\r\n                    permutation.append(number)\r\n                    counter[number] -= 1\r\n                    dfs()\r\n                    permutation.pop()\r\n                    counter[number] += 1\r\n\r\n        dfs()\r\n        return permutation_list", "testcase": "print(Solution().permuteUnique([1, 1, 2]), [[1, 2, 1], [2, 1, 1], [1, 1, 2]])\r\nprint(Solution().permuteUnique([1, 2, 3]), [[1, 3, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [2, 3, 1]])\r\nprint(Solution().permuteUnique([1]), [[1]])", "time_complexity": 8, "space_complexity": 8, "created_at": "2025-01-06T19:14:46.312Z", "updated_at": "2025-01-06T19:14:46.335Z"}}, {"model": "python_problems.solution", "pk": 364, "fields": {"problem": 191, "language": 2, "owner": 3, "solution": "/**\r\n * O(n!), O(n!)\r\n * backtracking, hash set\r\n * @param {number[]} numbers\r\n * @return {number[][]}\r\n */\r\nvar permuteUnique = function (numbers) {\r\n  const permutationSet = new Set();\r\n\r\n  const dfs = (left) => {\r\n    if (left === numbers.length) {\r\n      permutationSet.add(JSON.stringify(numbers));\r\n      return\r\n    }\r\n\r\n    for (let right = left; right < numbers.length; right++) {\r\n      [numbers[left], numbers[right]] = [numbers[right], numbers[left]];\r\n      dfs(left + 1);\r\n      [numbers[left], numbers[right]] = [numbers[right], numbers[left]];\r\n    }\r\n  }\r\n\r\n  dfs(0);\r\n  return Array.from(permutationSet).map((permutation) => JSON.parse(permutation))\r\n}", "testcase": "console.log(permuteUnique([1, 1, 2]), [[1, 2, 1], [2, 1, 1], [1, 1, 2]])\r\nconsole.log(permuteUnique([1, 2, 3]), [[1, 3, 2], [1, 2, 3], [2, 1, 3], [3, 2, 1], [3, 1, 2], [2, 3, 1]])\r\nconsole.log(permuteUnique([1]), [[1]])", "time_complexity": 8, "space_complexity": 8, "created_at": "2025-01-06T19:15:19.681Z", "updated_at": "2025-01-06T19:15:19.701Z"}}, {"model": "python_problems.solution", "pk": 365, "fields": {"problem": 192, "language": 1, "owner": 3, "solution": "# O(n2), O(n)\r\nclass Solution:\r\n    def getRow(self, rowIndex: int) -> list[int]:\r\n        row = [1]\r\n\r\n        for index1 in range(rowIndex):\r\n            new_row = [1] * (index1 + 2)\r\n\r\n            for index2 in range(index1):\r\n                new_row[index2 + 1] = row[index2] + row[index2 + 1]\r\n            \r\n            row = new_row\r\n\r\n        return row", "testcase": "print(Solution().getRow(3), [1, 3, 3, 1])\r\nprint(Solution().getRow(0), [1])\r\nprint(Solution().getRow(1), [1, 1])\r\nprint(Solution().getRow(2), [1, 2, 1])", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-01-07T12:36:35.030Z", "updated_at": "2025-01-07T12:36:35.050Z"}}, {"model": "python_problems.solution", "pk": 366, "fields": {"problem": 192, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(n)\r\n * @param {number} rowIndex\r\n * @return {number[]}\r\n */\r\nvar getRow = function (rowIndex) {\r\n  let row = [1];\r\n\r\n  for (let index1 = 0; index1 < rowIndex; index1++) {\r\n    const newRow = Array(index1 + 2).fill(1);\r\n\r\n    for (let index2 = 0; index2 < index1;index2++) {\r\n      newRow[index2 + 1] = row[index2] + row[index2 + 1];\r\n    }\r\n\r\n    row = newRow;\r\n  }\r\n\r\n  return row\r\n}", "testcase": "console.log(getRow(3), [1, 3, 3, 1])\r\nconsole.log(getRow(0), [1])\r\nconsole.log(getRow(1), [1, 1])\r\nconsole.log(getRow(2), [1, 2, 1])", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-01-07T12:37:06.926Z", "updated_at": "2025-01-07T12:37:06.959Z"}}, {"model": "python_problems.solution", "pk": 367, "fields": {"problem": 193, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def tribonacci(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [0, 1, 1]\r\n\r\n        if number < 3:\r\n            return cache[number]\r\n        \r\n        for _ in range(3, number + 1):\r\n            cache = [cache[1], cache[2], cache[2] + cache[1] + cache[0]]\r\n\r\n        return cache[2]\r\n\r\n\r\nclass Solution:\r\n    def tribonacci(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up, fancy\r\n        \"\"\"\r\n        triplet = [0, 1, 1]\r\n        \r\n        for index in range(3, number + 1):\r\n            triplet[index % 3] = sum(triplet)\r\n\r\n        return triplet[number % 3]\r\n\r\n\r\nclass Solution:\r\n    def tribonacci(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [None] * (number + 1)\r\n        cache[:3] = [0, 1, 1]\r\n\r\n        if number < 3:\r\n            return cache[number]\r\n        \r\n        for index in range(3, number + 1):\r\n            cache[index] = cache[index - 1] + cache[index - 2] + cache[index - 3]\r\n\r\n        return cache[number]\r\n\r\n\r\nclass Solution:\r\n    def tribonacci(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        memo = {0: 0, 1: 1, 2: 1}\r\n        \r\n        def dfs(index):\r\n            if index < 0:\r\n                return 0\r\n            elif index in memo:\r\n                return memo[index]\r\n            \r\n            memo[index] = dfs(index - 1) + dfs(index - 2) + dfs(index - 3)\r\n            return memo[index]\r\n\r\n        return dfs(number)\r\n\r\n\r\nclass Solution:\r\n    def tribonacci(self, number: int) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [None] * (number + 1)\r\n        memo[:3] = [0, 1, 1]\r\n        \r\n        def dfs(index):\r\n            if index < 0:\r\n                return 0\r\n            elif memo[index]:\r\n                return memo[index]\r\n            \r\n            memo[index] = dfs(index - 1) + dfs(index - 2) + dfs(index - 3)\r\n            return memo[index]\r\n\r\n        return dfs(number)\r\n\r\n\r\nclass Solution:\r\n    def tribonacci(self, number: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        memo = {0: 0, 1: 1, 2: 1}\r\n        \r\n        def dfs(index):\r\n            if index < 0:\r\n                return 0\r\n            elif index in memo:\r\n                return memo[index]\r\n            \r\n            return dfs(index - 1) + dfs(index - 2) + dfs(index - 3)\r\n\r\n        return dfs(number)\r\n\r\n\r\nclass Solution:\r\n    def tribonacci(self, number: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        memo = [None] * (number + 1)\r\n        memo[:3] = [0, 1, 1]\r\n        \r\n        def dfs(index):\r\n            if index < 0:\r\n                return 0\r\n            elif index in memo:\r\n                return memo[index]\r\n            \r\n            return dfs(index - 1) + dfs(index - 2) + dfs(index - 3)\r\n\r\n        return dfs(number)", "testcase": "print(Solution().tribonacci(3), 2)\r\nprint(Solution().tribonacci(4), 4)\r\nprint(Solution().tribonacci(25), 1389537)\r\nprint(Solution().tribonacci(0), 0)\r\nprint(Solution().tribonacci(31), 53798080)\r\nprint(Solution().tribonacci(35), 615693474)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-07T20:41:56.451Z", "updated_at": "2025-02-16T08:46:05.489Z"}}, {"model": "python_problems.solution", "pk": 368, "fields": {"problem": 193, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * dp, bottom-up\r\n * @param {number} number\r\n * @return {number}\r\n */\r\nvar tribonacci = function (number) {\r\n  const dp = Array(number + 1).fill(1);\r\n  dp[0] = 0;\r\n\r\n  for (let index = 3; index < number + 1; index++) {\r\n    dp[index] = (\r\n      dp[index - 1] +\r\n      dp[index - 2] +\r\n      dp[index - 3]);\r\n  }\r\n\r\n  return dp[number]\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(1)\r\n * dp, bottom-up\r\n * @param {number} number\r\n * @return {number}\r\n */\r\nvar tribonacci = function (number) {\r\n  const triplet = [0, 1, 1];\r\n  \r\n  for (let index = 3; index < number + 1; index++) {\r\n    triplet[index % 3] = triplet.reduce((total, current) => total + current);\r\n  }\r\n\r\n  return triplet[number % 3]\r\n}\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * dp, top-down with memoization, with inner function\r\n * @param {number} number\r\n * @return {number}\r\n */\r\nvar tribonacci = function (number) {\r\n  const memo = new Map();\r\n  \r\n  function trib(number) {\r\n\r\n    if (number === 0) return 0\r\n    else if (number === 1 || number === 2) return 1\r\n    else if (!memo.has(number)) {\r\n      const value = trib(number - 1) + trib(number - 2) + trib(number - 3);\r\n      memo.set(number, value)\r\n    }\r\n\r\n    return memo.get(number)\r\n  }\r\n\r\n  return trib(number);\r\n}", "testcase": "console.log(tribonacci(4), 4)\r\nconsole.log(tribonacci(25), 1389537)\r\nconsole.log(tribonacci(0), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-07T20:42:28.420Z", "updated_at": "2025-01-07T20:42:28.440Z"}}, {"model": "python_problems.solution", "pk": 369, "fields": {"problem": 194, "language": 1, "owner": 3, "solution": "# O(n2), O(1)\r\n# hash map\r\nclass Solution:\r\n    def is_word_good(self, word: str, counter: dict) -> bool:\r\n        counter_copy = counter.copy()\r\n\r\n        for letter in word:\r\n            if letter not in counter_copy:\r\n                return\r\n            else:\r\n                if counter_copy[letter] == 0:\r\n                    return\r\n                counter_copy[letter] -= 1\r\n        \r\n        return True\r\n\r\n    def countCharacters(self, words: list[str], chars: str) -> int:\r\n        counter = {}  # {letter: frequency}\r\n        sum_of_lengths = 0\r\n\r\n        for char in chars:\r\n            counter[char] = counter.get(char, 0) + 1\r\n\r\n        for word in words:\r\n            if self.is_word_good(word, counter):\r\n                sum_of_lengths += len(word)\r\n            \r\n        return sum_of_lengths", "testcase": "print(Solution().countCharacters([\"cat\", \"bt\", \"hat\", \"tree\"], \"atach\"), 6)\r\nprint(Solution().countCharacters([\"hello\", \"world\", \"leetcode\"], \"welldonehoneyr\"), 10)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-09T21:52:10.980Z", "updated_at": "2025-01-09T21:52:11.013Z"}}, {"model": "python_problems.solution", "pk": 370, "fields": {"problem": 194, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(1)\r\n * hash map\r\n * @param {string[]} words\r\n * @param {string} chars\r\n * @return {number}\r\n */\r\nvar countCharacters = function (words, chars) {\r\n  function isWordGood(word) {\r\n    const counterCopy = new Map(counter);\r\n\r\n    for (const letter of word) {\r\n      if (!counterCopy.has(letter)) \r\n        return false\r\n      else {\r\n        if (counterCopy.get(letter) === 0) \r\n          return false\r\n        counterCopy.set(letter, counterCopy.get(letter) - 1);\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n\r\n  const counter = new Map();  // {letter: frequency}\r\n  let sumOfLengths = 0;\r\n\r\n for (const char of chars) {\r\n  counter.set(char, (counter.get(char) || 0) + 1);\r\n }\r\n\r\n for (const word of words) {\r\n  if (isWordGood(word))\r\n    sumOfLengths += word.length;\r\n }\r\n \r\n return sumOfLengths\r\n}", "testcase": "console.log(countCharacters(['cat', 'bt', 'hat', 'tree'], 'atach'), 6)\r\nconsole.log(countCharacters(['hello', 'world', 'leetcode'], 'welldonehoneyr'), 10)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-09T22:04:28.648Z", "updated_at": "2025-01-09T22:04:28.669Z"}}, {"model": "python_problems.solution", "pk": 371, "fields": {"problem": 195, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\nclass Solution:\r\n    def largestGoodInteger(self, number: str) -> str:\r\n        triplet = []\r\n        solution = []\r\n        \r\n        for digit in number:\r\n            if (solution and  # if solution exists\r\n                    digit <= solution[0]):  # digit smaller than solution\r\n                triplet = []  # reset triplet\r\n                continue\r\n\r\n            if (triplet and  # if triplet exists\r\n                    digit != triplet[-1]):  # digit is different than those in current triplet\r\n                triplet = []  # reset triplet\r\n            \r\n            triplet.append(digit)  # append ditigt to the triplet\r\n\r\n            if len(triplet) == 3:  # if triplet is long enough\r\n                solution = triplet.copy()  # save curren triplet\r\n        \r\n        return \"\".join(solution)\r\n\r\n# O(n), O(1)\r\nclass Solution:\r\n    def largestGoodInteger(self, number: str) -> str:\r\n        triplet = \"\"\r\n        \r\n        for index in range(len(number) - 2):\r\n            if number[index] == number[index + 1] == number[index + 2]:\r\n                triplet = max(triplet, number[index] * 3)\r\n        \r\n        return triplet", "testcase": "print(Solution().largestGoodInteger(\"6777133339\"), \"777\")\r\nprint(Solution().largestGoodInteger(\"2300019\"), \"000\")\r\nprint(Solution().largestGoodInteger(\"42352338\"), \"\")\r\nprint(Solution().largestGoodInteger(\"7678222622241118390785777474281834906756431393782326744172075725179542796491876218340\"), \"777\")", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-09T23:41:43.334Z", "updated_at": "2025-01-09T23:41:43.358Z"}}, {"model": "python_problems.solution", "pk": 372, "fields": {"problem": 195, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * @param {string} number\r\n * @return {string}\r\n */\r\nvar largestGoodInteger = function (number) {\r\n  let triplet = '';\r\n\r\n  for (let index = 0; index < number.length - 2; index++) {\r\n    if (\r\n      number[index] === number[index + 1] && \r\n      number[index + 1] === number[index + 2]\r\n    ) {\r\n      triplet = Math.max(triplet, (number[index]).repeat(3));\r\n    }\r\n  }\r\n  return triplet.toString() === '0' ? '000' : triplet.toString()\r\n}", "testcase": "console.log(largestGoodInteger(\"6777133339\"), \"777\")\r\nconsole.log(largestGoodInteger(\"2300019\"), \"000\")\r\nconsole.log(largestGoodInteger(\"42352338\"), \"\")\r\nconsole.log(largestGoodInteger(\"7678222622241118390785777474281834906756431393782326744172075725179542796491876218340\"), \"777\")", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-09T23:42:57.489Z", "updated_at": "2025-01-09T23:42:57.512Z"}}, {"model": "python_problems.solution", "pk": 373, "fields": {"problem": 196, "language": 1, "owner": 3, "solution": "# O(nlogn), O(n)\r\n# two pointers\r\nclass Solution:\r\n    def rearrangeArray(self, numbers: list[int]) -> list[int]:\r\n        numbers.sort()\r\n        new_numbers = [0] * len(numbers)\r\n        index = 0\r\n        left = 0\r\n        right = len(numbers) - 1\r\n        \r\n        while left < right:\r\n            new_numbers[index] = numbers[left]\r\n            index += 1\r\n            new_numbers[index] = numbers[right]\r\n            index += 1\r\n            left += 1\r\n            right -= 1\r\n        \r\n        if len(numbers) % 2:\r\n            new_numbers[-1] = numbers[len(numbers) // 2]\r\n        \r\n        return new_numbers\r\n\r\n\r\n# O(nlogn), O(n)\r\n# slice\r\nclass Solution:\r\n    def rearrangeArray(self, numbers: list[int]) -> list[int]:\r\n        numbers.sort()\r\n        length = len(numbers)\r\n        new_numbers = [0] * length\r\n\r\n        new_numbers[: length + 1 :2] = numbers[:(length + 1) // 2]\r\n        new_numbers[1: length + 1 :2] = numbers[(length + 1) // 2 :]\r\n\r\n        return new_numbers", "testcase": "print(Solution().rearrangeArray([1, 2, 3, 4, 5]), [1, 5, 2, 4, 3])\r\nprint(Solution().rearrangeArray([1, 2, 3, 4]), [1, 4, 2, 3])\r\nprint(Solution().rearrangeArray([6, 2, 0, 9, 7]), [0, 9, 2, 7, 6])\r\nprint(Solution().rearrangeArray([1, 3, 2]), [1, 3, 2])", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-10T11:36:50.555Z", "updated_at": "2025-01-10T11:36:50.577Z"}}, {"model": "python_problems.solution", "pk": 374, "fields": {"problem": 196, "language": 2, "owner": 3, "solution": "/**\r\n * O(nlogn), O(n)\r\n * two pointers\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar rearrangeArray = function (numbers) {\r\n  numbers.sort();\r\n  const newNumbers = [];\r\n  let left = 0;\r\n  let right = numbers.length - 1;\r\n  let index = 0;\r\n\r\n  while (left < right) {\r\n    newNumbers[index] = numbers[left];\r\n    index++;\r\n    newNumbers[index] = numbers[right];\r\n    index++;\r\n    left++;\r\n    right--;\r\n  }\r\n\r\n  if (numbers.length % 2) \r\n    newNumbers[index] = numbers[numbers.length / 2 | 0];\r\n\r\n  return newNumbers\r\n}", "testcase": "console.log(rearrangeArray([1, 2, 3, 4, 5]), [1, 5, 2, 4, 3])\r\nconsole.log(rearrangeArray([1, 2, 3, 4]), [1, 4, 2, 3])\r\nconsole.log(rearrangeArray([6, 2, 0, 9, 7]), [0, 9, 2, 7, 6])\r\nconsole.log(rearrangeArray([1, 3, 2]), [1, 3, 2])", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-10T11:37:23.017Z", "updated_at": "2025-01-10T11:37:23.044Z"}}, {"model": "python_problems.solution", "pk": 375, "fields": {"problem": 197, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# sliding window\r\nclass Solution:\r\n    def maxSubarrayLength(self, numbers: list[int], k: int) -> int:\r\n        window = {}  # {number: frequency}\r\n        left = 0\r\n        subarray_length = 0\r\n\r\n        for right, number in enumerate(numbers):\r\n            window[number] = window.get(number, 0) + 1\r\n\r\n            while window[number] > k:\r\n                window[numbers[left]] -= 1\r\n                if number not in window:\r\n                    window.pop(number)\r\n                left += 1\r\n\r\n            subarray_length = max(subarray_length, \r\n                                  right - left + 1)\r\n\r\n        return subarray_length", "testcase": "print(Solution().maxSubarrayLength([1, 2, 3, 1, 2, 3, 1, 2], 2), 6)\r\nprint(Solution().maxSubarrayLength([1, 2, 1, 2, 1, 2, 1, 2], 1), 2)\r\nprint(Solution().maxSubarrayLength([5, 5, 5, 5, 5, 5, 5], 4), 4)\r\nprint(Solution().maxSubarrayLength([1, 1, 2], 2), 3)\r\nprint(Solution().maxSubarrayLength([1, 4, 4, 3], 1), 2)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-10T13:55:51.539Z", "updated_at": "2025-02-04T03:11:39.698Z"}}, {"model": "python_problems.solution", "pk": 376, "fields": {"problem": 197, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * sliding window\r\n * @param {number[]} numbers\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar maxSubarrayLength = function (numbers, k) {\r\n  const counter = new Map();  // {number: frequency}\r\n  let left = 0;\r\n  let subarrayLength = 0;\r\n\r\n  for (let right = 0; right < numbers.length; right++) {\r\n    const number = numbers[right];\r\n    counter.set(number, (counter.get(number) ?? 0) + 1);\r\n\r\n    while (counter.get(number) > k) {\r\n      counter.set(numbers[left], (counter.get(numbers[left])) - 1);\r\n      left++;\r\n    }\r\n\r\n    subarrayLength = Math.max(subarrayLength, right - left + 1);\r\n  }\r\n\r\n  return subarrayLength\r\n}", "testcase": "console.log(maxSubarrayLength([1, 2, 3, 1, 2, 3, 1, 2], 2), 6)\r\nconsole.log(maxSubarrayLength([1, 2, 1, 2, 1, 2, 1, 2], 1), 2)\r\nconsole.log(maxSubarrayLength([5, 5, 5, 5, 5, 5, 5], 4), 4)\r\nconsole.log(maxSubarrayLength([1, 1, 2], 2), 3)\r\nconsole.log(maxSubarrayLength([1, 4, 4, 3], 1), 2)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-10T13:56:19.865Z", "updated_at": "2025-01-10T13:56:19.884Z"}}, {"model": "python_problems.solution", "pk": 377, "fields": {"problem": 198, "language": 1, "owner": 3, "solution": "# O(nlogn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def days_to_ship(self, capacity: int) -> int:\r\n        days = 1  # days to ship with current capacity\r\n        current_capacity = capacity  # capacity for current day\r\n\r\n        for weight in self.weights:\r\n            if current_capacity - weight < 0:  # if ship capacity in bounds\r\n                days += 1  # increse days to ship\r\n                current_capacity = capacity\r\n\r\n            current_capacity -= weight  # add a cargo to the current ship         \r\n\r\n        return days  # days to ship with current capacity\r\n\r\n\r\n    def shipWithinDays(self, weights: list[int], days: int) -> int:\r\n        self.weights = weights\r\n        low_capacity = max(weights)  # min ship cargo\r\n        high_capacity = sum(weights)  # max ship cargo\r\n\r\n        while low_capacity < high_capacity:\r\n            capacity = (low_capacity + high_capacity) // 2  # capacity of a cargo\r\n\r\n            if (self.days_to_ship(capacity) > days):  # if more days to ship than planned\r\n                low_capacity = capacity + 1  # increase capacity\r\n            else:\r\n                high_capacity = capacity  # decrease capacity\r\n\r\n        return high_capacity", "testcase": "print(Solution().shipWithinDays([1, 2, 3, 1, 1], 4), 3)\r\nprint(Solution().shipWithinDays([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5), 15)\r\nprint(Solution().shipWithinDays([3, 2, 2, 4, 1, 4], 3), 6)", "time_complexity": 5, "space_complexity": 1, "created_at": "2025-01-11T12:15:52.497Z", "updated_at": "2025-01-11T12:15:52.521Z"}}, {"model": "python_problems.solution", "pk": 378, "fields": {"problem": 198, "language": 2, "owner": 3, "solution": "/**\r\n * O(nlogn), O(1)\r\n * binary search\r\n * @param {number[]} weights\r\n * @param {number} days\r\n * @return {number}\r\n */\r\nvar shipWithinDays = function (weights, days) {\r\n  function daysToShip(capacity) {\r\n    let days = 1;\r\n    let currentCapacity = capacity;\r\n\r\n    for (const weight of weights) {\r\n      if (currentCapacity - weight < 0) {\r\n        days++;\r\n        currentCapacity = capacity;\r\n      }\r\n      currentCapacity -= weight;\r\n    }\r\n    return days;\r\n  }\r\n\r\n  let lowCap = Math.max(...weights);\r\n  let highCap = weights.reduce((total, current) => total + current);\r\n\r\n  while (lowCap < highCap) {\r\n    const capacity = (lowCap + highCap) / 2 | 0\r\n\r\n    if (daysToShip(capacity) > days) {\r\n      lowCap = capacity + 1;\r\n    } else {\r\n      highCap = capacity;\r\n    }\r\n  }\r\n\r\n  return highCap\r\n}", "testcase": "console.log(shipWithinDays([1, 2, 3, 1, 1], 4), 3)\r\nconsole.log(shipWithinDays([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5), 15)\r\nconsole.log(shipWithinDays([3, 2, 2, 4, 1, 4], 3), 6)", "time_complexity": 5, "space_complexity": 1, "created_at": "2025-01-11T12:16:27.958Z", "updated_at": "2025-01-11T12:16:27.977Z"}}, {"model": "python_problems.solution", "pk": 379, "fields": {"problem": 199, "language": 1, "owner": 3, "solution": "# dummy > head > .. -> node -> .. > tail > None\r\n# O(n), O(n)\r\n# linked list, singly linked list\r\n\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass MyLinkedList:\r\n    def __init__(self):\r\n      self.dummy = ListNode()  \r\n\r\n    def get(self, index: int) -> int:\r\n        node = self.dummy.next\r\n        if not node:  # no nodes\r\n            return -1\r\n\r\n        while index:  # while not in the right index\r\n            if not node.next:  # if no next node\r\n                return -1\r\n            \r\n            node = node.next  # next node\r\n            index -= 1  # next index\r\n            \r\n        return node.val\r\n\r\n\r\n    def addAtHead(self, val: int) -> None:\r\n        head = ListNode(val, self.dummy.next)  # create a new head\r\n        self.dummy.next = head  # point dummy to new head\r\n        \r\n\r\n    def addAtTail(self, val: int) -> None:\r\n        tail = ListNode(val)  # create a new tail\r\n        node = self.dummy\r\n        \r\n        while node.next:\r\n            node = node.next\r\n        \r\n        node.next = tail\r\n\r\n\r\n    def addAtIndex(self, index: int, val: int) -> None:\r\n        node = self.dummy\r\n\r\n        while index:  # while not in the right index\r\n            if not node.next:  # if no next node\r\n                return\r\n            \r\n            node = node.next  # next node\r\n            index -= 1  # next index\r\n\r\n        new_node = ListNode(val, node.next)\r\n        node.next = new_node\r\n\r\n\r\n    def deleteAtIndex(self, index: int) -> None:\r\n        node = self.dummy\r\n\r\n        while index:  # while not in the right index\r\n            if not node.next:  # if no next node\r\n                return\r\n            \r\n            node = node.next  # next node\r\n            index -= 1  # next index\r\n\r\n        if not node.next:  # if no next node\r\n            return\r\n\r\n        node.next = node.next.next\r\n\r\n\r\n# Your MyLinkedList object will be instantiated and called as such:\r\n# obj = MyLinkedList()\r\n# param_1 = obj.get(index)\r\n# obj.addAtHead(val)\r\n# obj.addAtTail(val)\r\n# obj.addAtIndex(index,val)\r\n# obj.deleteAtIndex(index)\r\n\r\n\r\n# left <> head <> ... <> node <> ... <> tail <> right > None\r\n# O(n), O(n)\r\n# linked list, doubly linked list\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None, prev=None):\r\n        self.val = val\r\n        self.next = next\r\n        self.prev = prev\r\n\r\n\r\nclass MyLinkedList:\r\n    def __init__(self):\r\n        self.left = ListNode()  # left dummy node\r\n        self.right = ListNode()  # right dummy node\r\n        self.left.next = self.right\r\n        self.right.prev = self.left\r\n\r\n    def addAtHead(self, val: int) -> None:\r\n        next = self.left.next  # get old head\r\n        prev = self.left  # get left dummy node\r\n        node = ListNode(val, next, prev)  # create a new head\r\n        prev.next = node  # point left dummy to new head\r\n        next.prev = node  # point old head to new head\r\n\r\n    def addAtTail(self, val: int) -> None:\r\n        next = self.right  # get right dummy node\r\n        prev = self.right.prev  # get old tail\r\n        node = ListNode(val, next, prev)  # create a new tail\r\n        prev.next = node  # point old tail to new tail\r\n        next.prev = node  # point right dummy to new tail\r\n\r\n    def get(self, index: int) -> int:\r\n        node = self.left.next  # get head node\r\n\r\n        while index and node != self.right:  # while index > 0 and not on right node\r\n            node = node.next  # next node\r\n            index -= 1  # next index\r\n\r\n        if (index == 0 and\r\n                node != self.right):  # not on right node\r\n            return node.val\r\n        else:\r\n            return - 1\r\n\r\n    def addAtIndex(self, index: int, val: int) -> None:\r\n        next = self.left.next  # get head node\r\n\r\n        while index and next != self.right:  # while index > 0 and next not on None\r\n            next = next.next  # next node\r\n            index -= 1  # next index\r\n\r\n        if (index == 0 and next):  # not on right node\r\n            prev = next.prev  # get previous node\r\n            node = ListNode(val, next, prev)  # create a new node between next and previous nodes\r\n            prev.next = node  # point previous node to new node\r\n            next.prev = node  # point next node to new node\r\n\r\n    def deleteAtIndex(self, index: int) -> None:\r\n        node = self.left.next  # get head node\r\n\r\n        while index and node.next != self.right:  # while index > 0 and next not on None\r\n            node = node.next  # next node\r\n            index -= 1  # next index\r\n\r\n        if (node and index == 0 and \r\n                node != self.right):\r\n            node.prev.next = node.next  # point previous node to next node\r\n            node.next.prev = node.prev  # poion next node to previous node\r\n\r\n\r\n# Your MyLinkedList object will be instantiated and called as such:\r\n# obj = MyLinkedList()\r\n# param_1 = obj.get(index)\r\n# obj.addAtHead(val)\r\n# obj.addAtTail(val)\r\n# obj.addAtIndex(index,val)\r\n# obj.deleteAtIndex(index)", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-12T12:29:10.860Z", "updated_at": "2025-01-12T12:29:10.886Z"}}, {"model": "python_problems.solution", "pk": 380, "fields": {"problem": 199, "language": 2, "owner": 3, "solution": "var ListNode = function (val = 0, next = null, prev = null) {\r\n  this.val = val;\r\n  this.next = next;\r\n  this.prev = prev;\r\n};\r\n\r\nvar MyLinkedList = function () {\r\n  this.left = new ListNode();\r\n  this.right = new ListNode();\r\n  this.left.next = this.right;\r\n  this.right.prev = this.left;\r\n};\r\n\r\n/** \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nMyLinkedList.prototype.addAtHead = function (val) {\r\n  let next = this.left.next;\r\n  let prev = this.left\r\n  let node = new ListNode(val, next, prev);\r\n  next.prev = node;\r\n  prev.next = node;\r\n};\r\n\r\n/** \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nMyLinkedList.prototype.addAtTail = function (val) {\r\n  let next = this.right;\r\n  let prev = this.right.prev;\r\n  let node = new ListNode(val, next, prev);\r\n  next.prev = node;\r\n  prev.next = node;\r\n};\r\n\r\n/** \r\n * @param {number} index\r\n * @return {number}\r\n */\r\nMyLinkedList.prototype.get = function (index) {\r\n  let node = this.left.next;\r\n\r\n  while (index && node != this.right) {\r\n    node = node.next;\r\n    index--;\r\n  }\r\n\r\n  if (index === 0 && node != this.right)\r\n    return node.val\r\n  else\r\n    return -1\r\n};\r\n\r\n/** \r\n * @param {number} index \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nMyLinkedList.prototype.addAtIndex = function (index, val) {\r\n  let next = this.left.next;\r\n\r\n  while (index && next != this.right) {\r\n    next = next.next;\r\n    index--;\r\n  }\r\n\r\n  if (index === 0 && next) {\r\n    let prev = next.prev;\r\n    let node = new ListNode(val, next, prev);\r\n    prev.next = node;\r\n    next.prev = node;\r\n  }\r\n};\r\n/** \r\n * @param {number} index\r\n * @return {void}\r\n */\r\nMyLinkedList.prototype.deleteAtIndex = function (index) {\r\n  let node = this.left.next;\r\n\r\n  while (index && node.next != this.right) {\r\n    node = node.next;\r\n    index--;\r\n  }\r\n\r\n  if (index === 0 && node && node != this.right) {\r\n    node.prev.next = node.next;\r\n    node.next.prev = node.prev;\r\n  }\r\n};\r\n\r\n\r\n// left <> head <> ... <> node <> ... <> tail <> right > None\r\n/** \r\n * Your MyLinkedList object will be instantiated and called as such:\r\n * var obj = new MyLinkedList()\r\n * var param_1 = obj.get(index)\r\n * obj.addAtHead(val)\r\n * obj.addAtTail(val)\r\n * obj.addAtIndex(index,val)\r\n * obj.deleteAtIndex(index)\r\n */", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-12T12:29:42.434Z", "updated_at": "2025-01-12T12:29:42.457Z"}}, {"model": "python_problems.solution", "pk": 381, "fields": {"problem": 200, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\n# O(n), O(n)\r\n# binary tree\r\nclass Solution:\r\n    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:\r\n        leaf_list = []\r\n\r\n        def dfs(node):\r\n            if not node:\r\n                return\r\n            elif (not node.left and  # if both child nodes are None (== leaf), \r\n                    not node.right):\r\n                leaf_list.append(node.val)  # append value to leaf list\r\n                return\r\n\r\n            dfs(node.left)\r\n            dfs(node.right)\r\n        \r\n        dfs(root1)\r\n        leaf_list.reverse()\r\n\r\n        def dfs2(node):\r\n            if not node:\r\n                return True\r\n            elif (not node.left and \r\n                    not node.right):\r\n                # early exit\r\n                if (leaf_list and  # if list is empty then there is nothing to compare to\r\n                        node.val == leaf_list[-1]):  # same values\r\n                    leaf_list.pop()\r\n                    return True\r\n                else:\r\n                    return False\r\n\r\n            return (dfs2(node.left) and  # left child is leaf-similar\r\n                    dfs2(node.right))  # right child is leaf-similar\r\n        \r\n        return (dfs2(root2) and  # all leafs from root2 are in root1\r\n                not leaf_list)  # leaf list is empty", "testcase": "print(Solution().leafSimilar(build_tree_from_list([3, 5, 1, 6, 2, 9, 8, None, None, 7, 4]), build_tree_from_list([3, 5, 1, 6, 7, 4, 2, None, None, None, None, None, None, 9, 8])), True)\r\nprint(Solution().leafSimilar(build_tree_from_list([1, 2, 3]), build_tree_from_list([1, 3, 2])), False)\r\nprint(Solution().leafSimilar(build_tree_from_list([1, 2]), build_tree_from_list([2, 2])), True)\r\nprint(Solution().leafSimilar(build_tree_from_list([3, 5, 1, 6, 7, 4, 2, None, None, None, None, None,None, 9, 11, None, None, 8, 10]), build_tree_from_list([3, 5, 1, 6, 2, 9, 8, None, None, 7, 4])), False)\r\nprint(Solution().leafSimilar(build_tree_from_list([3, 5, 1, 6, 2, 9, 8, None, None, 7, 4]), build_tree_from_list([3, 5, 1, 6, 7, 4, 2, None, None, None, None, None, None, 9, 11, None, None, 8, 10])), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-12T14:52:32.966Z", "updated_at": "2025-01-12T14:52:32.991Z"}}, {"model": "python_problems.solution", "pk": 382, "fields": {"problem": 200, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root1\r\n * @param {TreeNode} root2\r\n * @return {boolean}\r\n */\r\nvar leafSimilar = function (root1, root2) {\r\n  const leafList = [];\r\n\r\n  function dfs(node) {\r\n    if (!node) return\r\n    else if (!node.left && !node.right) {\r\n      leafList.push(node.val);\r\n      return\r\n    }\r\n\r\n    dfs(node.left);\r\n    dfs(node.right);\r\n  }\r\n\r\n  dfs(root1)\r\n  leafList.reverse();\r\n\r\n  function dfs2(node) {\r\n    if (!node) return true\r\n    else if (!node.left && !node.right) {\r\n      if (\r\n        leafList &&\r\n        node.val === leafList[leafList.length - 1]\r\n      ) {\r\n        leafList.pop();\r\n        return true\r\n      } else return false\r\n    }\r\n\r\n    return (\r\n      dfs2(node.left) &&\r\n      dfs2(node.right))\r\n  }\r\n\r\n  return (\r\n    dfs2(root2) &&\r\n    !leafList.length)\r\n}", "testcase": "console.log(leafSimilar(buildTreeFromList([3, 5, 1, 6, 2, 9, 8, null, null, 7, 4]), buildTreeFromList([3, 5, 1, 6, 7, 4, 2, null, null, null, null, null, null, 9, 8])), true)\r\nconsole.log(leafSimilar(buildTreeFromList([1, 2, 3]), buildTreeFromList([1, 3, 2])), false)\r\nconsole.log(leafSimilar(buildTreeFromList([1, 2]), buildTreeFromList([2, 2])), true)\r\nconsole.log(leafSimilar(buildTreeFromList([3, 5, 1, 6, 7, 4, 2, null, null, null, null, null,null, 9, 11, null, null, 8, 10]), buildTreeFromList([3, 5, 1, 6, 2, 9, 8, null, null, 7, 4])), false)\r\nconsole.log(leafSimilar(buildTreeFromList([3, 5, 1, 6, 2, 9, 8, null, null, 7, 4]), buildTreeFromList([3, 5, 1, 6, 7, 4, 2, null, null, null, null, null, null, 9, 11, null, null, 8, 10])), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-12T15:06:10.739Z", "updated_at": "2025-01-12T15:06:10.765Z"}}, {"model": "python_problems.solution", "pk": 383, "fields": {"problem": 201, "language": 1, "owner": 3, "solution": "# O(1), O(1)\r\n# backtarcking\r\n# the recursion tree is bounded by 3**4 and validation within each call is O(1)\r\nclass Solution:\r\n    def restoreIpAddresses(self, text: str) -> list[str]:\r\n        if (len(text) < 4 or\r\n                len(text) > 12):\r\n            return []\r\n        \r\n        ip = []\r\n        ip_list = []\r\n\r\n        def dfs(index):\r\n            if index == len(text):\r\n                if len(ip) == 4:\r\n                    ip_list.append(\".\".join(number[0] for number in ip))\r\n                return\r\n            \r\n            # 0->3, 1->2, 2->1, 3->0\r\n            # if len(text) - (index + 1) >= (3 - index):\r\n            # check for 0:9\r\n            ip.append([text[index: index + 1]])\r\n            dfs(index + 1)\r\n            ip.pop()\r\n            \r\n            # check for 10:99\r\n            if (index < len(text) - 1 and \r\n                    text[index] != \"0\"):\r\n                ip.append([text[index: index + 2]])\r\n                dfs(index + 2)\r\n                ip.pop()\r\n\r\n            # check for 100:255\r\n            if (index < len(text) - 2 and \r\n                text[index] != \"0\" and\r\n                    text[index: index + 3] <= \"255\"):\r\n                ip.append([text[index: index + 3]])\r\n                dfs(index + 3)\r\n                ip.pop()\r\n\r\n        dfs(0)\r\n        return ip_list", "testcase": "print(Solution().restoreIpAddresses(\"25525511135\")== [\"255.255.11.135\", \"255.255.111.35\"])\r\nprint(Solution().restoreIpAddresses(\"0000\")== [\"0.0.0.0\"])\r\nprint(Solution().restoreIpAddresses(\"101023\")== [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"])\r\nprint(Solution().restoreIpAddresses(\"000256\")== [])", "time_complexity": 1, "space_complexity": 1, "created_at": "2025-01-12T17:59:21.662Z", "updated_at": "2025-01-12T17:59:21.688Z"}}, {"model": "python_problems.solution", "pk": 384, "fields": {"problem": 201, "language": 2, "owner": 3, "solution": "/**\r\n * O(1), O(1)\r\n * backtarcking\r\n * the recursion tree is bounded by 3**4 and validation within each call is O(1)\r\n * @param {string} text\r\n * @return {string[]}\r\n */\r\nvar restoreIpAddresses = function (text) {\r\n  if (\r\n    text.length < 4 ||\r\n    text.length > 12) return []\r\n\r\n  const ip = [];\r\n  const ipList = [];\r\n\r\n  function dfs(index) {\r\n    if (index === text.length) {\r\n      if (ip.length === 4) {\r\n        ipList.push(ip\r\n          .map((x) => x[0])\r\n          .join('.')\r\n        );\r\n      }\r\n      return\r\n    }\r\n\r\n    // check for 0:9\r\n    ip.push([text[index]]);\r\n    dfs(index + 1);\r\n    ip.pop();\r\n\r\n    // check for 10:99\r\n    if (\r\n      index < text.length - 1 &&\r\n      text[index] != '0'\r\n    ) {\r\n      ip.push([text.slice(index, index + 2)]);\r\n      dfs(index + 2);\r\n      ip.pop();\r\n    }\r\n\r\n    // check for 100:255\r\n    if (\r\n      index < text.length - 2 &&\r\n      text[index] != '0' &&\r\n      text.slice(index, index + 3) <= '255'\r\n    ) {\r\n      ip.push([text.slice(index, index + 3)]);\r\n      dfs(index + 3);\r\n      ip.pop();\r\n    }\r\n  }\r\n\r\n  dfs(0);\r\n  return ipList\r\n}", "testcase": "console.log(restoreIpAddresses(\"25525511135\"), [\"255.255.11.135\", \"255.255.111.35\"])\r\nconsole.log(restoreIpAddresses(\"0000\"), [\"0.0.0.0\"])\r\nconsole.log(restoreIpAddresses(\"101023\"), [\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"])\r\nconsole.log(restoreIpAddresses(\"000256\"), [])", "time_complexity": 1, "space_complexity": 1, "created_at": "2025-01-12T18:59:33.094Z", "updated_at": "2025-01-12T18:59:33.113Z"}}, {"model": "python_problems.solution", "pk": 385, "fields": {"problem": 202, "language": 1, "owner": 3, "solution": "class TrieNode:\r\n    def __init__(self):\r\n        self.letters = {}\r\n        self.is_word = False\r\n\r\n\r\nclass WordDictionary:\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n\r\n\r\n    def addWord(self, word: str) -> None:\r\n        node = self.root\r\n        \r\n        for letter in word:\r\n            if letter not in node.letters:\r\n                node.letters[letter] = TrieNode()\r\n            \r\n            node = node.letters[letter]\r\n        \r\n        node.is_word = True\r\n\r\n\r\n    def search(self, word: str) -> bool:\r\n        def dfs(left, node):\r\n            for right, letter in enumerate(word[left:], left):\r\n                if letter == \".\":\r\n                    for value_node in node.letters.values():  # if key is `.` check all value nodes\r\n                        if dfs(right + 1, value_node):\r\n                            return True\r\n                    return False\r\n                else:\r\n                    if letter not in node.letters:\r\n                        return False\r\n                    else:\r\n                        node = node.letters[letter]\r\n    \r\n            return node.is_word\r\n    \r\n        return dfs(0, self.root)\r\n\r\n\r\n# Your WordDictionary object will be instantiated and called as such:\r\n# obj = WordDictionary()\r\n# obj.addWord(word)\r\n# param_2 = obj.search(word)", "testcase": "word_dictionary = WordDictionary()\r\nword_dictionary.addWord(\"bad\")\r\nword_dictionary.addWord(\"dad\")\r\nword_dictionary.addWord(\"mad\")\r\nprint(word_dictionary.search(\"pad\")) # False\r\nprint(word_dictionary.search(\"bad\")) # True\r\nprint(word_dictionary.search(\".ad\")) # True\r\nprint(word_dictionary.search(\"b..\")) # True", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-12T21:29:26.193Z", "updated_at": "2025-01-12T21:29:26.210Z"}}, {"model": "python_problems.solution", "pk": 386, "fields": {"problem": 202, "language": 2, "owner": 3, "solution": "class TrieNode {\r\n  constructor() {\r\n    this.letters = new Map();\r\n    this.isWord = false;\r\n  }\r\n}\r\n\r\n/**\r\n * @return {TrieNode}\r\n */\r\nvar WordDictionary = function () {\r\n  this.root = new TrieNode();\r\n};\r\n\r\n/** \r\n * @param {string} word\r\n * @return {void}\r\n */\r\nWordDictionary.prototype.addWord = function (word) {\r\n  let node = this.root;\r\n\r\n  for (const letter of word) {\r\n    if (!node.letters.has(letter))\r\n      node.letters.set(letter, new TrieNode());\r\n\r\n    node = node.letters.get(letter);\r\n  }\r\n\r\n  node.isWord = true;\r\n};\r\n\r\n/** \r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nWordDictionary.prototype.search = function (word) {\r\n  /** \r\n   * @param {number} left\r\n   * @param {TrieNode} node\r\n   * @return {boolean}\r\n   */\r\n  function dfs(left, node) {\r\n    for (let right = left; right < word.length; right++) {\r\n      const letter = word[right];\r\n\r\n      if (letter === '.') {\r\n        for (const valueNode of node.letters.values()) {\r\n          if (dfs(right + 1, valueNode)) return true\r\n        }\r\n        return false\r\n      } else {\r\n        if (!node.letters.has(letter)) return false\r\n        else node = node.letters.get(letter);\r\n      }\r\n    }\r\n    return node.isWord\r\n  }\r\n\r\n  return dfs(0, this.root)\r\n};\r\n\r\n\r\n/** \r\n * Your WordDictionary object will be instantiated and called as such:\r\n * var obj = new WordDictionary()\r\n * obj.addWord(word)\r\n * var param_2 = obj.search(word)\r\n */", "testcase": "const wordDictionary = new WordDictionary();\r\nwordDictionary.addWord(\"bad\");\r\nwordDictionary.addWord(\"dad\");\r\nwordDictionary.addWord(\"mad\");\r\nconsole.log(wordDictionary.search(\"pad\")); // return false\r\nconsole.log(wordDictionary.search(\"bad\")); // return true\r\nconsole.log(wordDictionary.search(\".ad\")); // return true\r\nconsole.log(wordDictionary.search(\"b..\")); // return true", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-12T21:30:04.824Z", "updated_at": "2025-01-12T21:30:04.845Z"}}, {"model": "python_problems.solution", "pk": 387, "fields": {"problem": 203, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def minimumTotal(self, triangle: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        in-place\r\n        \"\"\"\r\n        for level in reversed(range(len(triangle) - 1)):\r\n            for index in range(len(triangle[level])):\r\n                triangle[level][index] += (\r\n                    min(triangle[level + 1][index], \r\n                        triangle[level + 1][index + 1]))\r\n                \r\n        return triangle[0][0]\r\n\r\n\r\nclass Solution:\r\n    def minimumTotal(self, triangle: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        in-place\r\n        \"\"\"\r\n        for level in range(1, len(triangle)):\r\n            triangle[level - 1] = ([triangle[level - 1][0]] + \r\n                                   triangle[level - 1] + \r\n                                   [triangle[level - 1][-1]])\r\n            \r\n            for index in range(len(triangle[level])):\r\n                triangle[level][index] += (\r\n                    min(triangle[level - 1][index], \r\n                        triangle[level - 1][index + 1]))\r\n                \r\n        return min(triangle[-1])\r\n\r\n\r\nclass Solution:\r\n    def minimumTotal(self, triangle: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        def dfs(index: int, level: int) -> int:\r\n            if level == len(triangle):\r\n                return 0\r\n            \r\n            return (triangle[level][index] + \r\n                    min(dfs(index, level + 1), \r\n                        dfs(index + 1, level + 1)))\r\n        \r\n        return dfs(0, 0)", "testcase": "print(Solution().minimumTotal([[2]]), 2)\r\nprint(Solution().minimumTotal([[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]), 11)\r\nprint(Solution().minimumTotal([[-10]]), -10)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-12T22:25:49.249Z", "updated_at": "2025-02-18T13:42:41.371Z"}}, {"model": "python_problems.solution", "pk": 388, "fields": {"problem": 203, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(1)\r\n * dp, in-place\r\n * @param {number[][]} triangle\r\n * @return {number}\r\n */\r\nvar minimumTotal = function (triangle) {\r\n  for (let row = triangle.length - 2; row >= 0; row--) {\r\n    for (let col = 0; col < triangle[row].length; col++) {\r\n      triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1])\r\n    }\r\n  }\r\n  return triangle[0][0]\r\n}", "testcase": "console.log(minimumTotal([[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]), 11)\r\nconsole.log(minimumTotal([[-10]]), -10)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-12T22:40:08.538Z", "updated_at": "2025-01-12T22:40:08.559Z"}}, {"model": "python_problems.solution", "pk": 389, "fields": {"problem": 204, "language": 1, "owner": 3, "solution": "import heapq\r\n\r\n# O(nlogn), O(k)\r\n# heap\r\nclass KthLargest:\r\n    def __init__(self, k: int, numbers: list[int]):\r\n        self.k = k\r\n        self.min_heap = numbers\r\n        heapq.heapify(self.min_heap)\r\n\r\n        while len(self.min_heap) > self.k:\r\n            heapq.heappop(self.min_heap)\r\n\r\n    def add(self, val: int) -> int:\r\n        heapq.heappush(self.min_heap, val)\r\n\r\n        while len(self.min_heap) > self.k:\r\n            heapq.heappop(self.min_heap)\r\n        \r\n        return self.min_heap[0]\r\n\r\n\r\n# Your KthLargest object will be instantiated and called as such:\r\n# obj = KthLargest(k, nums)\r\n# param_1 = obj.add(val)\r\n\r\n\r\n# O(n^2*logn), O(n)\r\n# sort\r\nclass KthLargest:\r\n    def __init__(self, k: int, numbers: list[int]):\r\n        self.numbers = numbers\r\n        self.k = k\r\n\r\n    def add(self, val: int) -> int:\r\n        self.numbers.append(val)\r\n        self.numbers.sort(reverse=True)\r\n\r\n        return self.numbers[self.k - 1]\r\n\r\n\r\nkthLargest = KthLargest(3, [4, 5, 8, 2])\r\nkthLargest.add(3) #  return 4\r\nkthLargest.add(5) #  return 5\r\nkthLargest.add(10) #  return 5\r\nkthLargest.add(9) #  return 8\r\nkthLargest.add(4) #  return 8", "testcase": "", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-13T00:18:42.603Z", "updated_at": "2025-01-13T01:29:39.338Z"}}, {"model": "python_problems.solution", "pk": 390, "fields": {"problem": 204, "language": 2, "owner": 3, "solution": "import { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number[]} numbers\r\n */\r\nvar KthLargest = function (k, numbers) {\r\n  this.k = k;\r\n  this.minHeap = new MinPriorityQueue();\r\n\r\n  for (const number of numbers)\r\n    this.minHeap.enqueue(number);\r\n\r\n  while (this.minHeap.size() > k)\r\n    this.minHeap.dequeue();\r\n};\r\n\r\n/** \r\n * @param {number} val\r\n * @return {number}\r\n */\r\nKthLargest.prototype.add = function (val) {\r\n  this.minHeap.enqueue(val);\r\n\r\n  while (this.minHeap.size() > this.k)\r\n    this.minHeap.dequeue();\r\n\r\n  return typeof this.minHeap.front() === 'object'\r\n    ? this.minHeap.front().element\r\n    : this.minHeap.front()\r\n};\r\n\r\n/**\r\n * Your KthLargest object will be instantiated and called as such:\r\n * var obj = new KthLargest(k, nums)\r\n * var param_1 = obj.add(val)\r\n */\r\n\r\n\r\nconst kthLargest = new KthLargest(3, [4, 5, 8, 2]);\r\nconsole.log(kthLargest.add(3)); // return 4\r\nconsole.log(kthLargest.add(5)) //  return 5\r\nconsole.log(kthLargest.add(10)) //  return 5\r\nconsole.log(kthLargest.add(9)) //  return 8\r\nconsole.log(kthLargest.add(4)) //  return 8", "testcase": "", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-13T01:27:42.460Z", "updated_at": "2025-01-13T01:34:56.291Z"}}, {"model": "python_problems.solution", "pk": 391, "fields": {"problem": 205, "language": 1, "owner": 3, "solution": "import heapq\r\n\r\n# O(nlogn), O(n)\r\n# heap\r\nclass Solution:\r\n    def lastStoneWeight(self, stones: list[int]) -> int:\r\n        stones = [-stone for stone in stones]\r\n        heapq.heapify(stones)  # make a heap\r\n        \r\n        while len(stones) > 1:\r\n            # 8 - 7 = 1  => -8 - -7 = - 1\r\n            stone = heapq.heappop(stones) - heapq.heappop(stones)\r\n            \r\n            if stone:\r\n                heapq.heappush(stones, stone)\r\n\r\n        return -stones[0] if stones else 0", "testcase": "print(Solution().lastStoneWeight([2, 7, 4, 1, 8, 1]), 1)\r\nprint(Solution().lastStoneWeight([1]), 1)\r\nprint(Solution().lastStoneWeight([1, 1]), 0)", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-13T17:33:02.265Z", "updated_at": "2025-01-13T17:33:02.291Z"}}, {"model": "python_problems.solution", "pk": 392, "fields": {"problem": 205, "language": 2, "owner": 3, "solution": "import { MaxPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\n/**\r\n * O(nlogn), O(n)\r\n * heap\r\n * @param {number[]} stones\r\n * @return {number}\r\n */\r\nvar lastStoneWeight = function (stones) {\r\n  const maxHeap = new MaxPriorityQueue();\r\n\r\n  for (const stone of stones) {\r\n    maxHeap.enqueue(stone);\r\n  }\r\n\r\n  while (maxHeap.size() > 1) {\r\n    const stone = maxHeap.dequeue() - maxHeap.dequeue();\r\n    // const stone = maxHeap.dequeue().element - maxHeap.dequeue().element;\r\n    if (stone)\r\n      maxHeap.enqueue(stone);\r\n  }\r\n\r\n  return maxHeap.dequeue()\r\n  // return maxHeap.size() === 0 ? 0 : maxHeap.dequeue().element;\r\n}", "testcase": "console.log(lastStoneWeight([2, 7, 4, 1, 8, 1]), 1)\r\nconsole.log(lastStoneWeight([1]), 1)\r\nconsole.log(lastStoneWeight([1, 1]), 0)", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-13T17:33:37.059Z", "updated_at": "2025-01-13T17:33:37.078Z"}}, {"model": "python_problems.solution", "pk": 393, "fields": {"problem": 206, "language": 1, "owner": 3, "solution": "# O(nlogn), O(n)\r\n# megret sort\r\nclass Solution:\r\n    def sortArray(self, numbers: list[int]) -> list[int]:\r\n        def merge(left, middle, right):\r\n            left_chunk = numbers[left: middle + 1]  # clone left chunk\r\n            right_chunk = numbers[middle + 1: right + 1]  # colone right chunk\r\n            index = left\r\n            left, right = 0, 0\r\n\r\n            while (left < len(left_chunk) and  # while numbers in left chunk and\r\n                   right < len(right_chunk)):  # in right chunk\r\n                # if left number is less than right\r\n                if left_chunk[left] <= right_chunk[right]:\r\n                    numbers[index] = left_chunk[left]\r\n                    left += 1\r\n                else:\r\n                    numbers[index] = right_chunk[right]\r\n                    right += 1\r\n                index += 1\r\n\r\n            while left < len(left_chunk):  # while still numbers in left chunk\r\n                numbers[index] = left_chunk[left]\r\n                left += 1\r\n                index += 1\r\n\r\n            while right < len(right_chunk):  # while still numbers in right chunk\r\n                numbers[index] = right_chunk[right]\r\n                right += 1\r\n                index += 1\r\n\r\n        def merge_sort(left, right):\r\n            if left == right:  # if pointers point only one number\r\n                return\r\n\r\n            middle = (left + right) // 2\r\n            # divide\r\n            merge_sort(left, middle)\r\n            merge_sort(middle + 1, right)\r\n            # merge\r\n            merge(left, middle, right)\r\n\r\n        merge_sort(0, len(numbers) - 1)\r\n        return numbers\r\n\r\n\r\n# O(nlogn), O(n)\r\n# quick sort, tle\r\nclass Solution:\r\n    def partition(self, numbers: list[int], left: int, end: int) -> int:\r\n        pivot = numbers[end]\r\n        left -= 1\r\n\r\n        for right in range(left + 1, end):\r\n            if numbers[right] < pivot:\r\n                left += 1\r\n                self.swap(numbers, left, right)\r\n\r\n        self.swap(numbers, left + 1, end)\r\n        return left + 1\r\n\r\n    def swap(self, numbers: list[int], left: int, right: int) -> None:\r\n        numbers[left], numbers[right] = numbers[right], numbers[left]\r\n\r\n    def quick_sort(self, numbers: list[int], left: int, right: int) -> None:\r\n        if left < right:\r\n            pivot = self.partition(numbers, left, right)\r\n            self.quick_sort(numbers, left, pivot - 1)\r\n            self.quick_sort(numbers, pivot + 1, right)\r\n\r\n    def quick_sort(self, numbers: list[int], left: int, right: int) -> None:\r\n        if right <= left:\r\n            return \r\n        pivot = self.partition(numbers, left, right)\r\n        self.quick_sort(numbers, left, pivot - 1)\r\n        self.quick_sort(numbers, pivot + 1, right)\r\n\r\n    def sortArray(self, numbers: list[int]) -> list[int]:\r\n        self.quick_sort(numbers, 0, len(numbers) - 1)\r\n        return numbers\r\n\r\n\r\n# O(n2), O(1)\r\n# insertion sort, tle\r\nclass Solution:\r\n    def insertionSort(self, numbers: list[int]) -> None:\r\n        for right in range(1, len(numbers)):\r\n            number = numbers[right]\r\n            left = right - 1\r\n\r\n            # Move elements of arr[0..i-1], that are\r\n            # greater than number, to one position ahead\r\n            # of their current position\r\n            while (left >= 0 and \r\n                   numbers[left] > number):\r\n                numbers[left + 1] = numbers[left]\r\n                left -= 1\r\n            numbers[left + 1] = number\r\n\r\n    def sortArray(self, numbers: list[int]) -> list[int]:\r\n        self.insertionSort(numbers)\r\n        return numbers", "testcase": "print(Solution().sortArray([5, 2, 3, 1]), [1, 2, 3, 5])\r\nprint(Solution().sortArray([5, 1, 1, 2, 0, 0]), [0, 0, 1, 1, 2, 5])", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-15T14:31:17.901Z", "updated_at": "2025-01-15T14:33:43.799Z"}}, {"model": "python_problems.solution", "pk": 394, "fields": {"problem": 206, "language": 2, "owner": 3, "solution": "/**\r\n * O(nlogn), O(n)\r\n * megret sort\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar sortArray = function (numbers) {\r\n  mergeSort(numbers, 0, numbers.length - 1)\r\n  return numbers\r\n}\r\n\r\nfunction merge(numbers, start, middle, end) {\r\n  const left_chunk = numbers.slice(start, middle + 1);\r\n  const right_chunk = numbers.slice(middle + 1, end + 1);\r\n  let index = start;\r\n  let left = 0;\r\n  let right = 0;\r\n\r\n  while (\r\n    left < left_chunk.length &&\r\n    right < right_chunk.length) {\r\n    if (left_chunk[left] <= right_chunk[right]) {\r\n      numbers[index] = left_chunk[left];\r\n      left++;\r\n    } else {\r\n      numbers[index] = right_chunk[right];\r\n      right++;\r\n    }\r\n    index++;\r\n  }\r\n\r\n  while (left < left_chunk.length) {\r\n    numbers[index] = left_chunk[left];\r\n    left++;\r\n    index++;\r\n  }\r\n\r\n  while (right < right_chunk.length) {\r\n    numbers[index] = right_chunk[right];\r\n    right++;\r\n    index++;\r\n  }\r\n}\r\n\r\nfunction mergeSort(numbers, left, right) {\r\n  if (left === right) return\r\n  const middle = (left + right) / 2 | 0;\r\n  mergeSort(numbers, left, middle);\r\n  mergeSort(numbers, middle + 1, right);\r\n  merge(numbers, left, middle, right);\r\n}\r\n\r\n\r\n/**\r\n * O(nlogn), O(n)\r\n * quick sort, tle\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar sortArray = function (numbers) {\r\n  quickSort(numbers, 0, numbers.length - 1)\r\n  return numbers\r\n}\r\n\r\nfunction swap(numbers, left, right) {\r\n  [numbers[left], numbers[right]] = [numbers[right], numbers[left]]\r\n}\r\n\r\nfunction partition(numbers, start, end) {\r\n  const pivot = numbers[end];\r\n  let left = start - 1;\r\n\r\n  for (let right = start; right < end; right++) {\r\n    if (numbers[right] < pivot) {\r\n      left++;\r\n      swap(numbers, left, right);\r\n    }\r\n  }\r\n  swap(numbers, left + 1, end);\r\n  return left + 1\r\n}\r\n\r\nfunction quickSort(numbers, left, right) {\r\n  if (left >= right) return\r\n  const pivot = partition(numbers, left, right)\r\n  quickSort(numbers, left, pivot - 1);\r\n  quickSort(numbers, pivot + 1, right);\r\n}\r\n\r\n\r\n/**\r\n * O(n2), O(1)\r\n * quick sort\r\n * @param {number[]} numbers\r\n * @return {number[]}\r\n */\r\nvar sortArray = function (numbers) {\r\n  insertionSort(numbers);\r\n  return numbers\r\n}\r\n\r\nfunction insertionSort(numbers) {\r\n  for (let right = 1; right < numbers.length; right++) {\r\n    const number = numbers[right];\r\n    let left = right - 1;\r\n\r\n    while (\r\n      left >= 0 &&\r\n      numbers[left] > number\r\n    ) {\r\n      numbers[left + 1] = numbers[left];\r\n      left--;\r\n    }\r\n\r\n    numbers[left + 1] = number;\r\n  }\r\n}", "testcase": "console.log(sortArray([5, 2, 3, 1]), [1, 2, 3, 5])\r\nconsole.log(sortArray([5, 1, 1, 2, 0, 0]), [0, 0, 1, 1, 2, 5])", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-15T14:33:26.184Z", "updated_at": "2025-01-15T14:33:26.219Z"}}, {"model": "python_problems.solution", "pk": 395, "fields": {"problem": 207, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\n# two pointers, two pass\r\nclass Solution:\r\n    def sortColors(self, nums: list[int]) -> None:\r\n        left = 0\r\n\r\n        # move zeros left\r\n        for right, number in enumerate(nums):\r\n            if number == 0:\r\n                nums[left], nums[right] = nums[right], nums[left]\r\n                left += 1\r\n\r\n        # move ones left\r\n        for right, number in enumerate(nums[left:], left):\r\n            if number == 1:\r\n                nums[left], nums[right] = nums[right], nums[left]\r\n                left += 1\r\n\r\n        return nums\r\n\r\n\r\n# O(n), O(1)\r\n# bucket sort, tow pass\r\nclass Solution:\r\n    def sortColors(self, nums: list[int]) -> None:\r\n        bucket = [0] * 3  # i-th index is a frequency of i-th number\r\n        \r\n        for number in nums:\r\n            bucket[number] += 1\r\n        \r\n        index = 0\r\n        \r\n        for number, frequency in enumerate(bucket):\r\n            for _ in range(frequency):\r\n                nums[index] = number\r\n                index += 1\r\n            \r\n        return nums\r\n\r\n\r\n# O(n), O(1)\r\n# three pointers, one pass\r\nclass Solution:\r\n    def sortColors(self, nums: list[int]) -> None:\r\n        left = 0\r\n        right = len(nums) - 1\r\n        index = 0\r\n\r\n        while index <= right:\r\n            number = nums[index]\r\n\r\n            if number == 0:\r\n                nums[left], nums[index] = nums[index], nums[left]\r\n                left += 1\r\n            elif number == 2:\r\n                nums[index], nums[right] = nums[right], nums[index]\r\n                right -= 1\r\n                # swapped value should be checked at the next iteration\r\n                index -= 1\r\n\r\n            index += 1\r\n\r\n        return nums", "testcase": "print(Solution().sortColors([2, 0, 2, 1, 1, 0]), [0, 0, 1, 1, 2, 2])\r\nprint(Solution().sortColors([2, 0, 1]), [0, 1, 2])", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-15T17:58:50.357Z", "updated_at": "2025-01-15T17:58:50.378Z"}}, {"model": "python_problems.solution", "pk": 396, "fields": {"problem": 207, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * three pointers, one pass\r\n * @param {number[]} nums\r\n * @return {void} Do not return anything, modify nums in-place instead.\r\n */\r\nvar sortColors = function (nums) {\r\n  let left = 0;\r\n  let right = nums.length - 1;\r\n  let index = 0;\r\n\r\n  while (index <= right) {\r\n    if (nums[index] === 0) {\r\n      [nums[index], nums[left]] = [nums[left], nums[index]];\r\n      left++;\r\n    }\r\n    else if (nums[index] === 2) {\r\n      [nums[index], nums[right]] = [nums[right], nums[index]];\r\n      right--;\r\n      index--;\r\n    }\r\n    index++;\r\n  }\r\n  // return nums\r\n}", "testcase": "console.log(sortColors([2, 0, 2, 1, 1, 0]), [0, 0, 1, 1, 2, 2])\r\nconsole.log(sortColors([2, 0, 1]), [0, 1, 2])", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-15T17:59:21.383Z", "updated_at": "2025-01-15T17:59:32.820Z"}}, {"model": "python_problems.solution", "pk": 397, "fields": {"problem": 208, "language": 1, "owner": 3, "solution": "# O(nlogn), O(n)\r\n# two pointers\r\nclass Solution:\r\n    def numRescueBoats(self, people: list[int], limit: int) -> int:\r\n        people.sort()\r\n        left = 0\r\n        right = len(people) - 1\r\n        boats = 0\r\n\r\n        while left <= right:\r\n            delta = limit - people[right]\r\n            right -= 1\r\n            boats += 1\r\n\r\n            if (left <= right and\r\n                   people[left] <= delta):\r\n                left += 1\r\n\r\n        return boats\r\n\r\n\r\n# O(n), O(n)\r\n# two pointers, bucket\r\nclass Solution:\r\n    def numRescueBoats(self, people: list[int], limit: int) -> int:\r\n        bucket = [0] * (max(people) + 1)\r\n        for weight in people:\r\n            bucket[weight] += 1\r\n\r\n        weight = 1  # current weight\r\n        for index in range(len(people)):\r\n            while bucket[weight] == 0:  # while no people of current weight\r\n                weight += 1  # next weight\r\n\r\n            people[index] = weight  # populate people weights\r\n            bucket[weight] -= 1  # decrease current weight in bucket\r\n\r\n        left = 0\r\n        right = len(people) - 1\r\n        boats = 0\r\n\r\n        while left <= right:\r\n            delta = limit - people[right]\r\n            right -= 1\r\n            boats += 1\r\n\r\n            if (left <= right and\r\n                    people[left] <= delta):\r\n                left += 1\r\n\r\n        return boats\r\n\r\n\r\n# slow\r\nclass Solution:\r\n    def numRescueBoats(self, people: list[int], limit: int) -> int:\r\n        counter = {}\r\n        weights = list(set(people))\r\n        weights.sort()\r\n        boat_count = 0\r\n\r\n        for weight in people:\r\n            counter[weight] = counter.get(weight, 0) + 1\r\n\r\n        while weights:\r\n            weight = weights[-1]\r\n            counter[weight] -= 1\r\n            if counter[weight] == 0:\r\n                counter.pop(weight)\r\n                weights.pop()\r\n\r\n            if not weights:\r\n                return boat_count + 1\r\n\r\n            diff = limit - weight\r\n\r\n            for smaller_weight in reversed(range(min(weights), diff + 1)):\r\n                if smaller_weight in counter:\r\n                    counter[smaller_weight] -= 1\r\n                    if counter[smaller_weight] == 0:\r\n                        counter.pop(smaller_weight)\r\n                        weights.remove(smaller_weight)\r\n                    break\r\n\r\n            boat_count += 1\r\n\r\n        return boat_count\r\n\r\n\r\n# tle\r\nclass Solution:\r\n    def numRescueBoats(self, people: list[int], limit: int) -> int:\r\n        people.sort()\r\n        boat_count = 0\r\n\r\n        while people:\r\n            weight = people.pop()\r\n            if not people:\r\n                return boat_count + 1\r\n\r\n            for smaller_weight in reversed(people):\r\n                if smaller_weight <= limit - weight:\r\n                    people.remove(smaller_weight)\r\n                    break\r\n\r\n            boat_count += 1\r\n\r\n        return boat_count", "testcase": "print(Solution().numRescueBoats([1, 2], 3), 1)\r\nprint(Solution().numRescueBoats([3, 2, 2, 1], 3), 3)\r\nprint(Solution().numRescueBoats([3, 5, 3, 4], 5), 4)\r\nprint(Solution().numRescueBoats([3, 2, 3, 2, 2], 6), 3)", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-15T20:03:53.707Z", "updated_at": "2025-01-15T21:33:16.356Z"}}, {"model": "python_problems.solution", "pk": 398, "fields": {"problem": 208, "language": 2, "owner": 3, "solution": "/**\r\n * O(nlogn), O(n)\r\n * two pointers\r\n * @param {number[]} people\r\n * @param {number} limit\r\n * @return {number}\r\n */\r\nvar numRescueBoats = function (people, limit) {\r\n  people.sort((a, b) => a - b);\r\n  let left = 0;\r\n  let right = people.length - 1;\r\n  let boats = 0;\r\n\r\n  while (left <= right) {\r\n    const delta = limit - people[right];\r\n    boats++;\r\n    right--;\r\n\r\n    if (\r\n      left <= right &&\r\n      people[left] <= delta) {\r\n      left++;\r\n    }\r\n  }\r\n  return boats\r\n}", "testcase": "console.log(numRescueBoats([1, 2], 3), 1)\r\nconsole.log(numRescueBoats([3, 2, 2, 1], 3), 3)\r\nconsole.log(numRescueBoats([3, 5, 3, 4], 5), 4)\r\nconsole.log(numRescueBoats([3, 2, 3, 2, 2], 6), 3)", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-15T20:08:43.840Z", "updated_at": "2025-01-15T20:08:43.861Z"}}, {"model": "python_problems.solution", "pk": 399, "fields": {"problem": 209, "language": 1, "owner": 3, "solution": "# draft\r\n# [1, 3, 2, 3, 3]\r\n# [1,3,2,3], [3,2,3],        [1,3,2,3,3], [3,2,3,3], [2,3,3] and [3,3]\r\n\r\n# [1, 3, 2, 3, 1]\r\n# [1,3,2,3], [3,2,3],        [1,3,2,3,1], [3,2,3,1]\r\n\r\n\r\n# O(n), O(1)\r\n# sliding window\r\nclass Solution:\r\n    def countSubarrays(self, numbers: list[int], k: int) -> int:\r\n        left = 0  # start of the sliding window\r\n        max_number = max(numbers)  # the maximum number from numbers\r\n        max_count = 0  # count occurences of the maximum number\r\n        counter = 0  # count number of subsets\r\n\r\n        for right, number in enumerate(numbers):\r\n            if number == max_number:  # if number is the maximum number\r\n                max_count += 1  # increase maximum number counter\r\n\r\n            # move the left pointer that in between left and right pointers\r\n            # (inclusive) are exactly k maximun numbers\r\n            while (max_count > k or  # too many maximum numbers or\r\n                   (max_count == k and  # exact number of maximum numbers and\r\n                    numbers[left] != max_number)):  # current numbers is not a maximum number\r\n                if numbers[left] == max_number:  # if current number is a maximum number\r\n                    max_count -= 1  # decrease maximum number counter\r\n                left += 1  # move left pointer\r\n            \r\n            if max_count == k:  # exact number of maximum numbers\r\n                counter += left + 1  # `left + 1` is the current subarray counter to add\r\n        \r\n        return counter\r\n\r\n\r\n# O(n3), O(1)\r\n# brute force\r\nclass Solution:\r\n    def countSubarrays(self, numbers: list[int], k: int) -> int:\r\n        counter = 0\r\n\r\n        for i in range(len(numbers)):\r\n            for j in range(i, len(numbers)):\r\n                if numbers[i: j + 1].count(max(numbers)) >= 2:\r\n                    counter += 1\r\n\r\n        return counter\r\n\r\n# O(n2), O(1)\r\n# brute force\r\nclass Solution:\r\n    def countSubarrays(self, numbers: list[int], k: int) -> int:\r\n        counter = 0\r\n        max_number = max(numbers)\r\n\r\n        for i in range(len(numbers)):\r\n            max_count = 0\r\n           \r\n            for j in range(i, len(numbers)):\r\n                if numbers[j] == max_number:\r\n                    max_count += 1\r\n                if  max_count >= 2:\r\n                    counter += 1\r\n\r\n        return counter", "testcase": "print(Solution().countSubarrays([1, 3, 2, 3, 3], 2), 6)\r\nprint(Solution().countSubarrays([1, 3, 2, 3, 3, 1], 2), 10)\r\nprint(Solution().countSubarrays([1, 3, 2, 3, 1], 2), 4)\r\nprint(Solution().countSubarrays([1, 3, 2, 3, 1, 1], 2), 6)\r\nprint(Solution().countSubarrays([1, 3, 2, 3, 1, 1, 3], 2), 10)\r\nprint(Solution().countSubarrays([1, 4, 2, 1], 3), 0)\r\nprint(Solution().countSubarrays([37,20,38,66,34,38,9,41,1,14,25,63,8,12,66,66,60,12,35,27,16,38,12,66,38,36,59,54,66,54,66,48,59,66,34,11,50,66,42,51,53,66,31,24,66,44,66,1,66,66,29,54], 5), 594)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-16T11:42:40.368Z", "updated_at": "2025-02-04T18:41:53.331Z"}}, {"model": "python_problems.solution", "pk": 400, "fields": {"problem": 209, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * sliding window\r\n * @param {number[]} numbers\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar countSubarrays = function (numbers, k) {\r\n  let left = 0;\r\n  let maxNumberCount = 0;\r\n  const maxNumber = Math.max(...numbers);\r\n  let counter = 0;\r\n\r\n  for (const number of numbers) {\r\n    if (number === maxNumber) {\r\n      maxNumberCount++;\r\n    }\r\n    while (maxNumberCount > k) {\r\n      if (numbers[left] === maxNumber) {\r\n        maxNumberCount--;\r\n        left++;\r\n      }\r\n    }\r\n    while (numbers[left] != maxNumber) {\r\n      left++;\r\n    }\r\n\r\n    if (maxNumberCount === k) {\r\n      counter += left + 1;\r\n    }\r\n  }\r\n  return counter\r\n}", "testcase": "console.log(countSubarrays([1, 3, 2, 3, 3], 2), 6)\r\nconsole.log(countSubarrays([1, 3, 2, 3, 3, 1], 2), 10)\r\nconsole.log(countSubarrays([1, 3, 2, 3, 1], 2), 4)\r\nconsole.log(countSubarrays([1, 3, 2, 3, 1, 1], 2), 6)\r\nconsole.log(countSubarrays([1, 3, 2, 3, 1, 1, 3], 2), 10)\r\nconsole.log(countSubarrays([1, 4, 2, 1], 3), 0)\r\nconsole.log(countSubarrays([37, 20, 38, 66, 34, 38, 9, 41, 1, 14, 25, 63, 8, 12, 66, 66, 60, 12, 35, 27, 16, 38, 12, 66, 38, 36, 59, 54, 66, 54, 66, 48, 59, 66, 34, 11, 50, 66, 42, 51, 53, 66, 31, 24, 66, 44, 66, 1, 66, 66, 29, 54], 5), 594)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-16T12:30:19.305Z", "updated_at": "2025-01-16T12:30:19.326Z"}}, {"model": "python_problems.solution", "pk": 401, "fields": {"problem": 210, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# stack\r\n# monotonically decreasing stack\r\nclass Solution:\r\n    def find132pattern(self, numbers: list[int]) -> bool:\r\n        stack = []  # (min_left, number)  # monotonic decreasing\r\n        prev_min = numbers[0]  # minimum before `j`\r\n\r\n        for number in numbers[1:]:\r\n            # pop all smaller equal values from the stack\r\n            while stack and number >= stack[-1][1]:\r\n                stack.pop()\r\n\r\n            # check if `numbers[k]` is: nums[i] < nums[k] < nums[j]\r\n            if stack and stack[-1][0] < number < stack[-1][1]:  # `number < stack[-1][1]` not nesessery because of previous while loop\r\n                return True\r\n\r\n            stack.append((prev_min, number))  # if stack is empty or `numbers[k]` not in bounds\r\n            prev_min = min(prev_min, number)  # update previous minimum value\r\n\r\n        return False\r\n\r\n\r\n# O(n2), O(1)\r\n# tle\r\nclass Solution:\r\n    def find132pattern(self, numbers: list[int]) -> bool:\r\n        for right, number in enumerate(numbers[2:], 2):\r\n            middle = right - 1\r\n\r\n            while middle > 0:\r\n                if numbers[middle] > number:\r\n                    left = middle - 1\r\n\r\n                    while left >= 0:\r\n                        if numbers[left] < number:\r\n                            return True\r\n\r\n                        left -= 1\r\n\r\n                middle -= 1\r\n\r\n        return False\r\n\r\n\r\n# O(n3), O(1)\r\nclass Solution:\r\n    def find132pattern(self, numbers: list[int]) -> bool:\r\n        for i in range(len(numbers)):\r\n            for j in range(i + 1, len(numbers)):\r\n                for k in range(j + 1, len(numbers)):\r\n                    if (numbers[i] < numbers[k] and\r\n                            numbers[j] > numbers[k]):\r\n                        return True\r\n\r\n        return False", "testcase": "print(Solution().find132pattern([3, 1, 4, 2]), True)\r\nprint(Solution().find132pattern([1, 2, 3, 4]), False)\r\nprint(Solution().find132pattern([-1, 3, 2, 0]), True)\r\nprint(Solution().find132pattern([3, 5, 0, 3, 4]), True)\r\nprint(Solution().find132pattern([1, 0, 1, -4, -3]), False)\r\nprint(Solution().find132pattern([-2, 1, 2, -2, 1, 2]), True)\r\nprint(Solution().find132pattern([1, 2, 3, 4, -4, -3, -5, -1]), False)\r\nprint(Solution().find132pattern([1, 3, -4, 2]), True)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-16T18:44:57.801Z", "updated_at": "2025-02-13T00:21:30.010Z"}}, {"model": "python_problems.solution", "pk": 402, "fields": {"problem": 210, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * sliding window\r\n * @param {number[]} numbers\r\n * @return {boolean}\r\n */\r\nvar find132pattern = function (numbers) {\r\n  const stack = [];\r\n  let minLeft = numbers[0];\r\n\r\n  for (const number of numbers) {\r\n    while (stack.length > 0 &&\r\n      number >= stack[stack.length - 1][0]\r\n    ) stack.pop()\r\n\r\n    if (\r\n      stack.length > 0 &&\r\n      number < stack[stack.length - 1][0] &&\r\n      number > stack[stack.length - 1][1]\r\n    ) return true\r\n\r\n    stack.push([number, minLeft]);\r\n    minLeft = Math.min(minLeft, number);\r\n  }\r\n  return false\r\n}", "testcase": "console.log(find132pattern([3, 1, 4, 2]), true)\r\nconsole.log(find132pattern([1, 2, 3, 4]), false)\r\nconsole.log(find132pattern([-1, 3, 2, 0]), true)\r\nconsole.log(find132pattern([3, 5, 0, 3, 4]), true)\r\nconsole.log(find132pattern([1, 0, 1, -4, -3]), false)\r\nconsole.log(find132pattern([-2, 1, 2, -2, 1, 2]), true)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-16T18:45:32.424Z", "updated_at": "2025-02-13T00:22:00.774Z"}}, {"model": "python_problems.solution", "pk": 403, "fields": {"problem": 211, "language": 1, "owner": 3, "solution": "browserHistory = BrowserHistory(\"leetcode.com\")\r\nbrowserHistory.visit(\"google.com\")  # You are in \"leetcode.com\". Visit \"google.com\"\r\nbrowserHistory.visit(\"facebook.com\")  # You are in \"google.com\". Visit \"facebook.com\"\r\nbrowserHistory.visit(\"youtube.com\")  # You are in \"facebook.com\". Visit \"youtube.com\"\r\nprint(browserHistory.back(1))  # You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"\r\nprint(browserHistory.back(1))  # You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"\r\nprint(browserHistory.forward(1))  # You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"\r\nbrowserHistory.visit(\"linkedin.com\")  # You are in \"facebook.com\". Visit \"linkedin.com\"\r\nprint(browserHistory.forward(2))  # You are in \"linkedin.com\", you cannot move forward any steps.\r\nprint(browserHistory.back(2))  # You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"\r\nprint(browserHistory.back(7))  # You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"\r\n\r\n\r\n# O(1): visit, O(n): back, forward, O(n)\r\n# linked list\r\nclass ListNode:\r\n    def __init__(self, val=\"\", next=None, prev=None):\r\n        self.val = val\r\n        self.next = next\r\n        self.prev = prev\r\n\r\nclass BrowserHistory:\r\n    def __init__(self, homepage: str):\r\n        self.home = ListNode(homepage)\r\n        self.node = self.home\r\n\r\n    def visit(self, url: str) -> None:\r\n        self.node.next = ListNode(url, None, self.node)\r\n        self.node = self.node.next\r\n\r\n    def back(self, steps: int) -> str:\r\n        while (steps and \r\n               self.node.prev):\r\n            self.node = self.node.prev\r\n            steps -= 1\r\n        \r\n        return self.node.val\r\n\r\n    def forward(self, steps: int) -> str:\r\n        while (steps and \r\n               self.node.next):\r\n            self.node = self.node.next\r\n            steps -= 1\r\n        \r\n        return self.node.val\r\n\r\n\r\n# Your BrowserHistory object will be instantiated and called as such:\r\n# obj = BrowserHistory(homepage)\r\n# obj.visit(url)\r\n# param_2 = obj.back(steps)\r\n# param_3 = obj.forward(steps)\r\n\r\n\r\n# linked list\r\n# first try\r\nclass ListNode:\r\n    def __init__(self, val=\"\", next=None, prev=None):\r\n        self.val = val\r\n        self.next = next\r\n        self.prev = prev\r\n\r\nclass BrowserHistory:\r\n    def __init__(self, homepage: str):\r\n        self.home = ListNode(homepage)\r\n        self.end = ListNode()\r\n        self.home.next = self.end\r\n        self.end.prev = self.home\r\n        self.pointer = 0\r\n\r\n    def visit(self, url: str) -> None:\r\n        prev = self.home\r\n        pointer = self.pointer\r\n        \r\n        while pointer > 0:\r\n            prev = prev.next\r\n            pointer -= 1\r\n\r\n        self.node = ListNode(url, self.end, prev)\r\n        prev.next = self.node\r\n        self.end.prev = self.node\r\n        self.pointer += 1\r\n\r\n    def back(self, steps: int) -> str:\r\n        node = self.home\r\n        pointer = self.pointer\r\n        backing = max(pointer - steps, 0)\r\n        self.pointer = 0\r\n        \r\n        while backing != 0:\r\n            node = node.next\r\n            backing -= 1\r\n            self.pointer += 1\r\n        \r\n        return node.val\r\n\r\n    def forward(self, steps: int) -> str:\r\n        node = self.home\r\n        pointer = 0\r\n        \r\n        while pointer != self.pointer:\r\n            node = node.next\r\n            pointer += 1\r\n\r\n        while steps and node.next.next:\r\n            node = node.next\r\n            steps -= 1\r\n            self.pointer += 1\r\n        \r\n        return node.val\r\n\r\n\r\n# O(1), O(n)\r\n# stack\r\nclass BrowserHistory:\r\n    def __init__(self, homepage: str):\r\n        self.history = [homepage]  # stack\r\n        self.index = 0  # current page index\r\n        self.len = 1  # true length of the stack\r\n\r\n    def visit(self, url: str) -> None:\r\n        self.index += 1\r\n        if len(self.history) == self.index:\r\n            self.history.append(url)\r\n        else:\r\n            self.history[self.index] = url\r\n        # soft delete values after current index by setting length\r\n        self.len = self.index + 1\r\n\r\n    def back(self, steps: int) -> str:\r\n        self.index = max(self.index - steps, 0)\r\n        return self.history[self.index]\r\n\r\n    def forward(self, steps: int) -> str:\r\n        self.index = min(self.index + steps, self.len - 1)\r\n        return self.history[self.index]\r\n\r\n\r\n# O(n): visit, O(1): back, forward, O(n)\r\n# stack\r\nclass BrowserHistory:\r\n    def __init__(self, homepage: str):\r\n        self.history = [homepage]  # stack\r\n        self.index = 0  # current page index\r\n\r\n    def visit(self, url: str) -> None:\r\n        self.index += 1\r\n        # self.history = self.history[:self.index]\r\n        while len(self.history) > self.index:\r\n            self.history.pop()\r\n        self.history.append(url)\r\n\r\n    def back(self, steps: int) -> str:\r\n        steps = min(steps, self.index)\r\n        self.index -= steps\r\n        # self.index = max(self.index - steps, 0)\r\n        return self.history[self.index]\r\n\r\n    def forward(self, steps: int) -> str:\r\n        steps = min(steps, len(self.history) - 1 - self.index)\r\n        self.index += steps\r\n        # self.index = min(self.index + steps, len(self.history) - 1)\r\n        return self.history[self.index]", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2025-01-17T09:45:45.296Z", "updated_at": "2025-01-17T09:45:45.321Z"}}, {"model": "python_problems.solution", "pk": 404, "fields": {"problem": 211, "language": 2, "owner": 3, "solution": "class ListNode {\r\n  constructor(val = '', next = null, prev = null) {\r\n    this.val = val;\r\n    this.next = next;\r\n    this.prev = prev;\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} homepage\r\n */\r\nvar BrowserHistory = function (homepage) {\r\n  this.home = new ListNode(homepage);\r\n  this.node = this.home;\r\n};\r\n\r\n/** \r\n * @param {string} url\r\n * @return {void}\r\n */\r\nBrowserHistory.prototype.visit = function (url) {\r\n  this.node.next = new ListNode(url, null, this.node);\r\n  this.node = this.node.next;\r\n};\r\n\r\n/** \r\n * @param {number} steps\r\n * @return {string}\r\n */\r\nBrowserHistory.prototype.back = function (steps) {\r\n  while (\r\n    steps &&\r\n    this.node.prev\r\n  ) {\r\n    this.node = this.node.prev;\r\n    steps--;\r\n  }\r\n  return this.node.val\r\n};\r\n\r\n/** \r\n * @param {number} steps\r\n * @return {string}\r\n */\r\nBrowserHistory.prototype.forward = function (steps) {\r\n  while (\r\n    steps &&\r\n    this.node.next\r\n  ) {\r\n    this.node = this.node.next;\r\n    steps--;\r\n  }\r\n  return this.node.val\r\n};\r\n\r\n/** \r\n * Your BrowserHistory object will be instantiated and called as such:\r\n * var obj = new BrowserHistory(homepage)\r\n * obj.visit(url)\r\n * var param_2 = obj.back(steps)\r\n * var param_3 = obj.forward(steps)\r\n */\r\n\r\n\r\nconst browserHistory = new BrowserHistory(\"leetcode.com\")\r\nbrowserHistory.visit(\"google.com\")  // You are in \"leetcode.com\". Visit \"google.com\"\r\nbrowserHistory.visit(\"facebook.com\")  // You are in \"google.com\". Visit \"facebook.com\"\r\nbrowserHistory.visit(\"youtube.com\")  // You are in \"facebook.com\". Visit \"youtube.com\"\r\nconsole.log(browserHistory.back(1))  // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"\r\nconsole.log(browserHistory.back(1))  // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"\r\nconsole.log(browserHistory.forward(1))  // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"\r\nbrowserHistory.visit(\"linkedin.com\")  // You are in \"facebook.com\". Visit \"linkedin.com\"\r\nconsole.log(browserHistory.forward(2))  // You are in \"linkedin.com\", you cannot move forward any steps.\r\nconsole.log(browserHistory.back(2))  // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"\r\nconsole.log(browserHistory.back(7))  // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"", "testcase": "", "time_complexity": 1, "space_complexity": 2, "created_at": "2025-01-17T09:46:13.240Z", "updated_at": "2025-01-17T09:46:13.264Z"}}, {"model": "python_problems.solution", "pk": 405, "fields": {"problem": 212, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def evaluateTree(self, root: TreeNode) -> bool:\r\n        if (not root or\r\n                not root.val):\r\n            return False\r\n        elif root.val == 1:\r\n            return True\r\n        elif root.val == 2:\r\n            return (self.evaluateTree(root.left) or\r\n                    self.evaluateTree(root.right))\r\n        else:  # root.val == 3:\r\n            return (self.evaluateTree(root.left) and\r\n                    self.evaluateTree(root.right))", "testcase": "print(Solution().evaluateTree(build_tree_from_list([2, 1, 3, None, None, 0, 1])), True)\r\nprint(Solution().evaluateTree(build_tree_from_list([0])), False)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-17T12:33:48.812Z", "updated_at": "2025-01-17T12:33:48.832Z"}}, {"model": "python_problems.solution", "pk": 406, "fields": {"problem": 212, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {boolean}\r\n */\r\nvar evaluateTree = function (root) {\r\n  if (\r\n    !root ||\r\n    !root.val)\r\n    return false\r\n  else if (root.val === 1)\r\n    return true\r\n  else if (root.val === 2)\r\n    return (\r\n      evaluateTree(root.left) ||\r\n      evaluateTree(root.right))\r\n  else\r\n    return (\r\n      evaluateTree(root.left) &&\r\n      evaluateTree(root.right))\r\n}", "testcase": "console.log(evaluateTree(buildTreeFromList([2, 1, 3, null, null, 0, 1])), true)\r\nconsole.log(evaluateTree(buildTreeFromList([0])), false)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-17T12:34:55.744Z", "updated_at": "2025-01-17T12:34:55.764Z"}}, {"model": "python_problems.solution", "pk": 407, "fields": {"problem": 213, "language": 1, "owner": 3, "solution": "import numpy as np\r\nimport heapq\r\n\r\n# O(klogn), O(n)\r\n# heap, optimal\r\nclass Solution:\r\n    def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\r\n        distances = []  # [-distance, [x, y]]\r\n        k_points = [0] * k  # solution frame\r\n\r\n        for (x, y) in points:\r\n            # distance = np.sqrt(x**2 + y**2)  # calculate distance to origin\r\n            distance = -(x**2 + y**2)  # calculate distance to origin\r\n            if len(distances) < k:\r\n                heapq.heappush(distances, (distance, (x, y)))  # push to heap: [distance, [x, y]]\r\n            else:\r\n                heapq.heappushpop(distances, (distance, (x, y)))  # push then pop largest element\r\n        for index in range(k):  # loop k times\r\n            k_points[index] = heapq.heappop(distances)[1]  # update k closest points\r\n\r\n        return k_points\r\n\r\n\r\nimport numpy as np\r\nimport heapq\r\n\r\n# O(klogn), O(n)\r\n# heap\r\nclass Solution:\r\n    def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\r\n        distances = []  # [distance, [x, y]]\r\n        k_points = [0] * k  # solution frame\r\n\r\n        for (x, y) in points:\r\n            distance = np.sqrt(x**2 + y**2)  # calculate distance to origin\r\n            heapq.heappush(distances, (distance, (x, y)))  # push to heap: [distance, [x, y]]\r\n        for index in range(k):  # loop k times\r\n            k_points[index] = heapq.heappop(distances)[1]  # update k closest points\r\n\r\n        return k_points", "testcase": "print(Solution().kClosest([[1, 3], [-2, 2]], 1), [[-2, 2]])\r\nprint(Solution().kClosest([[3, 3], [5, -1], [-2, 4]], 2), [[3, 3], [-2, 4]])", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-17T15:21:32.926Z", "updated_at": "2025-01-17T15:21:32.950Z"}}, {"model": "python_problems.solution", "pk": 408, "fields": {"problem": 213, "language": 2, "owner": 3, "solution": "import { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\n/**\r\n * O(nlogn), O(n)\r\n * heap\r\n * @param {number[][]} points\r\n * @param {number} k\r\n * @return {number[][]}\r\n */\r\nvar kClosest = function (points, k) {\r\n  const minHeap = new MinPriorityQueue();  // (point, distance(as a priortiy))\r\n  const kPoints = Array(k).fill(0);\r\n\r\n  for (const point of points) {\r\n    const distance = Math.sqrt(point[0]**2 + point[1]**2);\r\n    minHeap.enqueue(point, distance)\r\n  }\r\n\r\n  for (let index = 0; index < k; index++) {\r\n    kPoints[index] = minHeap.dequeue();\r\n    // kPoints[index] = minHeap.dequeue().element;\r\n  }\r\n  \r\n  return kPoints\r\n}", "testcase": "console.log(kClosest([[1, 3], [-2, 2]], 1), [[-2, 2]])\r\nconsole.log(kClosest([[3, 3], [5, -1], [-2, 4]], 2), [[3, 3], [-2, 4]])", "time_complexity": 4, "space_complexity": 2, "created_at": "2025-01-17T15:22:17.359Z", "updated_at": "2025-01-17T15:22:17.382Z"}}, {"model": "python_problems.solution", "pk": 409, "fields": {"problem": 214, "language": 1, "owner": 3, "solution": "# O(4^n), O(n)\r\n# backtracking\r\nclass Solution:\r\n    def makesquare(self, matchsticks: list[int]) -> bool:\r\n        if sum(matchsticks) % 4:\r\n            return False\r\n\r\n        matchsticks.sort(reverse=True)\r\n        max_side_len = sum(matchsticks) // 4\r\n        side_len = [0] * 4  # each side length cache\r\n\r\n        def dfs(index):\r\n            if index == len(matchsticks):\r\n                return True\r\n\r\n            for side in range(4):  # check every square side\r\n                if side_len[side] + matchsticks[index] <= max_side_len:  # if side length in bounds\r\n                    side_len[side] += matchsticks[index]\r\n                    \r\n                    if dfs(index + 1):  # check next match\r\n                        return True\r\n                    \r\n                    side_len[side] -= matchsticks[index]  # backtrack\r\n            \r\n            return False\r\n\r\n        return dfs(0)", "testcase": "print(Solution().makesquare([1, 1, 2, 2, 2]), True)\r\nprint(Solution().makesquare([3, 3, 3, 3, 4]), False)\r\nprint(Solution().makesquare([5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3]), True)\r\nprint(Solution().makesquare([7215807,6967211,5551998,6632092,2802439,821366,2465584,9415257,8663937,3976802,2850841,803069,2294462,8242205,9922998]), False)", "time_complexity": 6, "space_complexity": 2, "created_at": "2025-01-17T21:57:11.979Z", "updated_at": "2025-01-17T21:57:11.998Z"}}, {"model": "python_problems.solution", "pk": 410, "fields": {"problem": 214, "language": 2, "owner": 3, "solution": "/**\r\n * O(4^n), O(n)\r\n * backtracking\r\n * @param {number[]} matchsticks\r\n * @return {boolean}\r\n */\r\nvar makesquare = function (matchsticks) {\r\n  if (matchsticks.reduce((total, current) => total + current) % 4)\r\n    return false\r\n\r\n  matchsticks.sort((a, b) => b - a);\r\n  const sideLength = matchsticks.reduce((total, current) => total + current) / 4;\r\n  const currentSideLength = new Array(4).fill(0);\r\n\r\n  function dfs(index) {\r\n    if (index === matchsticks.length) return true\r\n\r\n    for (let side = 0; side < 4; side++) {\r\n      if (currentSideLength[side] + matchsticks[index] <= sideLength) {\r\n        currentSideLength[side] += matchsticks[index]\r\n        if (dfs(index + 1)) return true\r\n        currentSideLength[side] -= matchsticks[index]\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  return dfs(0)\r\n}", "testcase": "console.log(makesquare([1, 1, 2, 2, 2]), true)\r\nconsole.log(makesquare([3, 3, 3, 3, 4]), false)\r\nconsole.log(makesquare([5, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3]), true)\r\nconsole.log(makesquare([7215807, 6967211, 5551998, 6632092, 2802439, 821366, 2465584, 9415257, 8663937, 3976802, 2850841, 803069, 2294462, 8242205, 9922998]), false)", "time_complexity": 6, "space_complexity": 2, "created_at": "2025-01-17T21:57:52.767Z", "updated_at": "2025-01-17T21:57:52.786Z"}}, {"model": "python_problems.solution", "pk": 411, "fields": {"problem": 215, "language": 1, "owner": 3, "solution": "# draft\r\n# \"leets43210\"\r\n\r\n# O(n3), O(n)\r\n# dp, bottom-up\r\nclass Solution:\r\n    def minExtraChar(self, text: str, word_list: list[str]) -> int:\r\n        words = set(word_list)\r\n        text_len = len(text)\r\n        cache = [0] * (text_len + 1)\r\n\r\n        for index in reversed(range(text_len)):  # check all indexes\r\n            cache[index] = cache[index + 1] + 1  # set default cache as if word is not found\r\n            \r\n            for word in words:  # check every word\r\n                if (index + len(word) <= text_len and  # check if end of the word is in bounds\r\n                    text[index: index + len(word)] in words):  # if word in text\r\n                        cache[index] = min(cache[index], cache[index + len(word)])  # update cache\r\n                       \r\n                        if not cache[index]:  # early exit, if cache is 0 than this is the best case\r\n                            break\r\n        \r\n        return cache[0]\r\n\r\n\r\n# O(n3), O(n)\r\n# dp, bottom-up, optimal\r\nclass Solution:\r\n    def minExtraChar(self, text: str, word_list: list[str]) -> int:\r\n        words = set(word_list)\r\n        word_lengths = set()  # get all word lengths\r\n        text_len = len(text)\r\n        cache = [0] * (text_len + 1)\r\n\r\n        # make word lengths to later iterate in word lengths not in words\r\n        # don't check the same word length twice\r\n        # when legit length is found still check in words if the word is legit\r\n        for word in word_list:\r\n            word_lengths.add(len(word))\r\n\r\n        for index in reversed(range(text_len)):  # check all indexes\r\n            cache[index] = cache[index + 1] + 1  # set default cache as if word is not found\r\n            \r\n            for word_length in word_lengths:  # check every word length\r\n                if (index + word_length <= text_len and  # check if end of the word is in bounds\r\n                    text[index: index + word_length] in words):  # if word in text\r\n                        cache[index] = min(cache[index], cache[index + word_length])  # update cache\r\n                       \r\n                        if not cache[index]:  # early exit, if cache is 0 than this is the best case\r\n                            break\r\n        \r\n        return cache[0]\r\n\r\n\r\n# O(n3), O(n2)\r\n# dp, bottom-up, trie, optimal\r\n\r\nclass TrieNode:\r\n    def __init__(self):\r\n        self.letters = {}\r\n        self.is_word = False\r\n\r\n\r\nclass Trie:\r\n    def __init__(self):\r\n        self.root = TrieNode()\r\n    \r\n    def insert(self, word):\r\n        node = self.root\r\n\r\n        for letter in word:\r\n            if letter not in node.letters:\r\n                node.letters[letter] = TrieNode()\r\n            \r\n            node = node.letters[letter]\r\n\r\n        node.is_word = True\r\n\r\n    def search(self, word):\r\n        node = self.root\r\n\r\n        for letter in word:\r\n            if letter not in node.letters:\r\n                return False\r\n            \r\n            node = node.letters[letter]\r\n\r\n        return node.is_word\r\n\r\n\r\nclass Solution:\r\n    def minExtraChar(self, text: str, word_list: list[str]) -> int:\r\n        # initialize trie\r\n        trie = Trie()\r\n        for word in word_list:\r\n            trie.insert(word)\r\n            \r\n        word_lengths = set()  # get all word lengths\r\n        text_len = len(text)\r\n        cache = [0] * (text_len + 1)\r\n\r\n        # make word lengths to later iterate in word lengths not in words\r\n        # don't check the same word length twice\r\n        # when legit length is found still check in words if the word is legit\r\n        for word in word_list:\r\n            word_lengths.add(len(word))\r\n\r\n        for index in reversed(range(text_len)):  # check all indexes\r\n            cache[index] = cache[index + 1] + 1  # set default cache as if word is not found\r\n            \r\n            for word_length in word_lengths:  # check every word length\r\n                if (index + word_length <= text_len and  # check if end of the word is in bounds\r\n                    trie.search(text[index: index + word_length])):  # if word in trie\r\n                        cache[index] = min(cache[index], cache[index + word_length])  # update cache\r\n                       \r\n                        if not cache[index]:  # early exit, if cache is 0 than this is the best case\r\n                            break\r\n        \r\n        return cache[0]", "testcase": "print(Solution().minExtraChar(\"leetcode\", [\"leet\", \"code\", \"leetcode\"]), 0)\r\nprint(Solution().minExtraChar(\"leetscode\", [\"leet\", \"code\", \"leetcode\"]), 1)\r\nprint(Solution().minExtraChar(\"sayhelloworld\", [\"hello\", \"world\"]), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-01-18T12:45:57.287Z", "updated_at": "2025-01-18T12:47:55.923Z"}}, {"model": "python_problems.solution", "pk": 412, "fields": {"problem": 215, "language": 2, "owner": 3, "solution": "/**\r\n * O(n3), O(n)\r\n * dp, bottom-up, optimal\r\n * @param {string} text\r\n * @param {string[]} dictionary\r\n * @return {number}\r\n */\r\nvar minExtraChar = function (text, dictionary) {\r\n  const cache = Array(text.length + 1).fill(0);\r\n  const words = new Set(dictionary);\r\n  const wordLengths = new Set(dictionary.map(word => word.length))\r\n\r\n  for (let index = text.length - 1; index >= 0; index--) {\r\n    cache[index] = cache[index + 1] + 1;\r\n\r\n    for (const wordLength of wordLengths) {\r\n      if (\r\n        index + wordLength <= text.length &&\r\n        words.has(text.slice(index, index + wordLength))\r\n      ) {\r\n        cache[index] = Math.min(cache[index], cache[index + wordLength]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return cache[0]\r\n}\r\n\r\n\r\nclass TrieNode {\r\n  constructor() {\r\n    this.letters = new Map();\r\n    this.isWord = false;\r\n  }\r\n}\r\n\r\nclass Trie {\r\n  constructor() {\r\n    this.root = new TrieNode()\r\n  }\r\n\r\n  insert(word) {\r\n    let node = this.root;\r\n\r\n    for (const letter of word) {\r\n      if (!node.letters.has(letter))\r\n        node.letters.set(letter, new TrieNode());\r\n\r\n      node = node.letters.get(letter);\r\n    }\r\n    node.isWord = true;\r\n  }\r\n\r\n  search(word) {\r\n    let node = this.root;\r\n\r\n    for (const letter of word) {\r\n      if (!node.letters.has(letter))\r\n        return false\r\n\r\n      node = node.letters.get(letter);\r\n    }\r\n    return node.isWord\r\n  }\r\n}\r\n\r\n/**\r\n * O(n3), O(n2)\r\n * dp, bottom-up, trie\r\n * @param {string} text\r\n * @param {string[]} dictionary\r\n * @return {number}\r\n */\r\nvar minExtraChar = function (text, dictionary) {\r\n  const trie = new Trie();\r\n  for (const word of dictionary) {\r\n    trie.insert(word);\r\n  }\r\n\r\n  const cache = Array(text.length + 1).fill(0);\r\n  const words = new Set(dictionary);\r\n  const wordLengths = new Set(dictionary.map(word => word.length))\r\n\r\n  for (let index = text.length - 1; index >= 0; index--) {\r\n    cache[index] = cache[index + 1] + 1;\r\n\r\n    for (const wordLength of wordLengths) {\r\n      if (\r\n        index + wordLength <= text.length &&\r\n        trie.search(text.slice(index, index + wordLength))\r\n      ) {\r\n        cache[index] = Math.min(cache[index], cache[index + wordLength]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return cache[0]\r\n}", "testcase": "lconsole.log(minExtraChar(\"leetcode\", [\"leet\", \"code\", \"leetcode\"]), 0)\r\nconsole.log(minExtraChar(\"leetscode\", [\"leet\", \"code\", \"leetcode\"]), 1)\r\nconsole.log(minExtraChar(\"sayhelloworld\", [\"hello\", \"world\"]), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-01-18T14:11:34.843Z", "updated_at": "2025-01-18T14:11:34.865Z"}}, {"model": "python_problems.solution", "pk": 413, "fields": {"problem": 216, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n[2, 3, 4]\r\n2; max(2, 3); max((2 + 4)+ or (3)+)\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def deleteAndEarn(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        counter = {}\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n\r\n        sorted_numbers = sorted(set(numbers))\r\n        cache = [0] * len(sorted_numbers)\r\n\r\n        for index, number in enumerate(sorted_numbers):\r\n            cache[index] = number * counter[number]  # calculate current value\r\n            if index == 0:\r\n                continue\r\n\r\n            if sorted_numbers[index - 1] + 1 != number:  # if previous number was not less by one from current number\r\n                cache[index] += cache[index - 1]  # add previous cache\r\n            else:\r\n                if index != 1:  # exclude the first index\r\n                    cache[index] += cache[index - 2]  # add `before previous` cache\r\n                cache[index] = max(cache[index], cache[index - 1])  # previous number is one less to current number, but cache[index - 1] (previous cache) is better\r\n\r\n        return cache[-1]\r\n\r\n\r\nclass Solution:\r\n    def deleteAndEarn(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        cache optimized\r\n        \"\"\"\r\n        counter = {}\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n\r\n        sorted_numbers = sorted(set(numbers))\r\n        cache = [0, 0]\r\n\r\n        for index, number in enumerate(sorted_numbers):\r\n            current_cache = number * counter[number]\r\n            if index == 0:\r\n                cache = [0, current_cache]\r\n                continue\r\n\r\n            if sorted_numbers[index - 1] + 1 != number:\r\n                current_cache += cache[1]\r\n            else:\r\n                if index != 1:\r\n                    current_cache += cache[0]\r\n                current_cache = max(current_cache, cache[1])\r\n\r\n            cache = [cache[1], current_cache]\r\n\r\n        return cache[-1]\r\n\r\n\r\nclass Solution:\r\n    def deleteAndEarn(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        counter = {}\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n\r\n        sorted_numbers = sorted(set(numbers))\r\n        memo = [None] * (len(sorted_numbers) + 2)\r\n        memo[-1] = memo[-2] = 0\r\n\r\n        def dfs(index: int) -> int:\r\n            if memo[index] is not None:\r\n                return memo[index]\r\n            \r\n            number = sorted_numbers[index]\r\n            val = number * counter[number]\r\n\r\n            if (index + 1 < len(sorted_numbers) and \r\n                    sorted_numbers[index] + 1 != sorted_numbers[index + 1]):\r\n                val += dfs(index + 1)\r\n            else:\r\n                val += dfs(index + 2)\r\n            \r\n            memo[index] = max(val, dfs(index + 1))\r\n            return memo[index]\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def deleteAndEarn(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        counter = {}\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n\r\n        sorted_numbers = sorted(set(numbers))\r\n        memo = {\r\n            len(sorted_numbers): 0, \r\n            len(sorted_numbers) + 1: 0\r\n        }\r\n\r\n        def dfs(index: int) -> int:\r\n            if index in memo:\r\n                return memo[index]\r\n            \r\n            number = sorted_numbers[index]\r\n            val = number * counter[number]\r\n\r\n            if (index + 1 < len(sorted_numbers) and \r\n                    sorted_numbers[index] + 1 != sorted_numbers[index + 1]):\r\n                val += dfs(index + 1)\r\n            else:\r\n                val += dfs(index + 2)\r\n            \r\n            memo[index] = max(val, dfs(index + 1))\r\n            return memo[index]\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def deleteAndEarn(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        counter = {}\r\n        for number in numbers:\r\n            counter[number] = counter.get(number, 0) + 1\r\n\r\n        sorted_numbers = sorted(set(numbers))\r\n\r\n        def dfs(index: int) -> int:\r\n            if index >= len(sorted_numbers):\r\n                return 0\r\n            \r\n            number = sorted_numbers[index]\r\n            val = number * counter[number]\r\n\r\n            if (index + 1 < len(sorted_numbers) and \r\n                    sorted_numbers[index] + 1 != sorted_numbers[index + 1]):\r\n                val += dfs(index + 1)\r\n            else:\r\n                val += dfs(index + 2)\r\n            \r\n            return max(val, dfs(index + 1))\r\n\r\n        return dfs(0)", "testcase": "print(Solution().deleteAndEarn([1]), 1)\r\nprint(Solution().deleteAndEarn([2, 3]), 3)\r\nprint(Solution().deleteAndEarn([2, 4]), 6)\r\nprint(Solution().deleteAndEarn([3, 4, 2]), 6)\r\nprint(Solution().deleteAndEarn([2, 2, 3, 3, 3, 4]), 9)\r\nprint(Solution().deleteAndEarn([8, 10, 4, 9, 1, 3, 5, 9, 4, 10]), 37)\r\nprint(Solution().deleteAndEarn([1, 1, 1, 2, 4, 5, 5, 5, 6]), 18)\r\nprint(Solution().deleteAndEarn([1, 6, 3, 3, 8, 4, 8, 10, 1, 3]), 43)\r\nprint(Solution().deleteAndEarn([1, 1, 1]), 3)\r\nprint(Solution().deleteAndEarn([12,32,93,17,100,72,40,71,37,92,58,34,29,78,11,84,77,90,92,35,12,5,27,92,91,23,65,91,85,14,42,28,80,85,38,71,62,82,66,3,33,33,55,60,48,78,63,11,20,51,78,42,37,21,100,13,60,57,91,53,49,15,45,19,51,2,96,22,32,2,46,62,58,11,29,6,74,38,70,97,4,22,76,19,1,90,63,55,64,44,90,51,36,16,65,95,64,59,53,93]), 3451)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-19T12:58:59.141Z", "updated_at": "2025-02-19T11:12:06.716Z"}}, {"model": "python_problems.solution", "pk": 414, "fields": {"problem": 216, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * dp, bottom-up\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar deleteAndEarn = function (numbers) {\r\n  numbers = numbers.sort((a, b) => a - b);\r\n  const numberSet = new Set(numbers);\r\n  const numbers2 = Array.from(numberSet)\r\n  const cache = Array(numbers).fill(0);\r\n  const counter = new Map();\r\n\r\n  for (const number of numbers) {\r\n    counter.set(number, (counter.get(number) || 0) + 1);\r\n  }\r\n\r\n  for (let index = 0; index < numbers2.length; index++) {\r\n    const number = numbers2[index];\r\n    const value = number * counter.get(number);\r\n\r\n    if (index === 0) {\r\n      cache[index] = value;\r\n    }\r\n    else if (index === 1) {\r\n      if (number === numbers2[index - 1] + 1)\r\n        cache[index] = Math.max(value, cache[index - 1]);\r\n      else\r\n        cache[index] = value + cache[index - 1]\r\n    }\r\n    else {\r\n      if (number === numbers2[index - 1] + 1)\r\n        cache[index] = Math.max(value + cache[index - 2], cache[index - 1]);\r\n      else\r\n        cache[index] = value + cache[index - 1]\r\n    }\r\n  }\r\n\r\n  return cache[numberSet.size - 1]\r\n}", "testcase": "console.log(deleteAndEarn([3, 4, 2]), 6)\r\nconsole.log(deleteAndEarn([2, 2, 3, 3, 3, 4]), 9)\r\nconsole.log(deleteAndEarn([8, 10, 4, 9, 1, 3, 5, 9, 4, 10]), 37)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-19T12:59:33.321Z", "updated_at": "2025-01-19T12:59:33.340Z"}}, {"model": "python_problems.solution", "pk": 415, "fields": {"problem": 217, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n                                .\r\n                   /            |           \\\r\n                  17            2           17\r\n              /       \\     /      \\      /     \\\r\n            16        5    16      5    16      16\r\n          /    \\    /  \\   /  \\   / \\  /  \\    /   \\\r\n        3      19  14  3  3   19 14  3  3  19 14   19\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def minCost(self, houses: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        in-place\r\n        \"\"\"\r\n        for index, house in enumerate(houses[1:], 1):\r\n            prev_house = houses[index - 1]\r\n            houses[index] = [\r\n                house[0] + min(prev_house[1], prev_house[2]),\r\n                house[1] + min(prev_house[2], prev_house[0]),\r\n                house[2] + min(prev_house[0], prev_house[1])\r\n            ]\r\n\r\n        return min(houses[-1])\r\n\r\n\r\nclass Solution:\r\n    def minCost(self, houses: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = tuple(houses[0])\r\n        \r\n        for house in houses[1:]:\r\n            cache = (\r\n                house[0] + min(cache[1], cache[2]),\r\n                house[1] + min(cache[2], cache[0]),\r\n                house[2] + min(cache[0], cache[1])\r\n            )\r\n\r\n        return min(cache)\r\n\r\n\r\nclass Solution:\r\n    def minCost(self, houses: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [()] * len(houses)\r\n        cache[0] = tuple(houses[0])\r\n        \r\n        for index, house in enumerate(houses[1:], 1):\r\n            prev_house = cache[index - 1]\r\n            cache[index] = (\r\n                house[0] + min(prev_house[1], prev_house[2]),\r\n                house[1] + min(prev_house[2], prev_house[0]),\r\n                house[2] + min(prev_house[0], prev_house[1])\r\n            )\r\n\r\n        return min(cache[-1])\r\n\r\n\r\nclass Solution:\r\n    def minCost(self, houses: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        memo = {len(houses): 0}\r\n        \r\n        def dfs(index: int, house_number: int) -> int:\r\n            if index in memo:\r\n                return memo[index]\r\n\r\n\r\n            memo[index] = min(house + dfs(index + 1, house_ind) \r\n                              for house_ind, house in enumerate(houses[index])\r\n                              if house_ind != house_number)\r\n            return memo[index]\r\n\r\n        return memo\r\n\r\n\r\nclass Solution:\r\n    def minCost(self, houses: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        def dfs(index: int, house_number: int) -> int:\r\n            if index == len(houses):\r\n                return 0\r\n\r\n            cost = float(\"inf\")\r\n            for house_ind, house in enumerate(houses[index]):\r\n                if house_ind != house_number:\r\n                    cost = min(cost, house + dfs(index + 1, house_ind))\r\n\r\n            return cost\r\n\r\n        return dfs(0, -1)\r\n\r\n\r\nclass Solution:\r\n    def minCost(self, houses: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        def dfs(index: int, house_number: int) -> int:\r\n            if index == len(houses):\r\n                return 0\r\n\r\n            return min(house + dfs(index + 1, house_ind) \r\n                       for house_ind, house in enumerate(houses[index])\r\n                       if house_ind != house_number)\r\n\r\n        return dfs(0, -1)", "testcase": "print(Solution().minCost([[1, 2, 3]]), 1)\r\nprint(Solution().minCost([[1, 2, 3], [1, 4, 6]]), 3)\r\nprint(Solution().minCost([[17, 2, 17], [16, 16, 5], [14, 3, 19]]), 10)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-19T23:00:28.246Z", "updated_at": "2025-02-19T12:54:47.463Z"}}, {"model": "python_problems.solution", "pk": 416, "fields": {"problem": 217, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * dp, bottom-up\r\n * @param {number[][]} houses\r\n * @return {number}\r\n */\r\nvar minCost = (houses) => {\r\n  let cache = houses[0];\r\n\r\n  for (let index = 1; index < houses.length; index ++) {\r\n    cache = [\r\n      houses[index][0] + Math.min(cache[1], cache[2]),\r\n      houses[index][1] + Math.min(cache[2], cache[0]),\r\n      houses[index][2] + Math.min(cache[0], cache[1])\r\n    ]\r\n  }\r\n\r\n  return Math.min(...cache)\r\n}", "testcase": "console.log(minCost([[17, 2, 17], [16, 16, 5], [14, 3, 19]]), 10)\r\nconsole.log(minCost([[1, 2, 3], [1, 4, 6]]), 3)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-19T23:17:23.436Z", "updated_at": "2025-01-19T23:17:23.455Z"}}, {"model": "python_problems.solution", "pk": 417, "fields": {"problem": 218, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# hash map\r\nclass Solution:\r\n    def destCity(self, paths: list[list[str]]) -> str:\r\n        city_map = {start: stop  # {starting city: destination city}\r\n                    for start, stop in paths}\r\n\r\n        city = paths[0][0]  # some starting city\r\n        \r\n        while city in city_map:  # while starting city have destination city\r\n            city = city_map[city]\r\n            \r\n        return city\r\n\r\n\r\n# O(n), O(n)\r\n# hash set\r\nclass Solution:\r\n    def destCity(self, paths: list[list[str]]) -> str:\r\n        cities_a = {city for city, _ in paths}  # starting cities\r\n        cities_b = {city for _, city in paths}  # destination cities\r\n\r\n        for city in cities_b:  # for every destination city\r\n            if city not in cities_a:  # if its not a starting city\r\n                return city", "testcase": "print(Solution().destCity([[\"London\", \"New York\"], [\"New York\", \"Lima\"], [\"Lima\", \"Sao Paulo\"]]), \"Sao Paulo\")\r\nprint(Solution().destCity([[\"B\", \"C\"], [\"D\", \"B\"], [\"C\", \"A\"]]), \"A\")\r\nprint(Solution().destCity([[\"A\", \"Z\"]]), \"Z\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-20T11:15:19.797Z", "updated_at": "2025-01-20T11:15:19.821Z"}}, {"model": "python_problems.solution", "pk": 418, "fields": {"problem": 218, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * hash set\r\n * @param {string[][]} paths\r\n * @return {string}\r\n */\r\nvar destCity = function (paths) {\r\n  const citiesA = new Set(paths.map(([a, _]) => a));\r\n  const citiesB = new Set(paths.map(([_, b]) => b));\r\n\r\n  for (const city of citiesB)\r\n    if (!citiesA.has(city))\r\n      return city\r\n}", "testcase": "console.log(destCity([['London', 'New York'], ['New York', 'Lima'], ['Lima', 'Sao Paulo']]), 'Sao Paulo')\r\nconsole.log(destCity([['B', 'C'], ['D', 'B'], ['C', 'A']]), 'A')\r\nconsole.log(destCity([['A', 'Z']]), 'Z')", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-20T11:15:52.668Z", "updated_at": "2025-01-20T11:15:52.689Z"}}, {"model": "python_problems.solution", "pk": 419, "fields": {"problem": 219, "language": 1, "owner": 3, "solution": "import heapq\r\n\r\n# O(n), O(1)\r\n# heap\r\nclass Solution:\r\n    def maxProductDifference(self, numbers: list[int]) -> int:\r\n        heap_min = []\r\n        heap_max = []\r\n\r\n        for number in numbers:\r\n            if len(heap_max) < 2:\r\n                heapq.heappush(heap_max, number)\r\n            else:\r\n                heapq.heappushpop(heap_max, number)\r\n\r\n            if len(heap_min) < 2:\r\n                heapq.heappush(heap_min, -number)\r\n            else:\r\n                heapq.heappushpop(heap_min, -number)\r\n\r\n        return (heap_max[0] * heap_max[1] - heap_min[0] * heap_min[1])\r\n\r\n\r\n# draft\r\n# 5, 6   4\r\n# 4, 6,  5\r\n\r\n# O(n), O(1)\r\nclass Solution:\r\n    def maxProductDifference(self, numbers: list[int]) -> int:\r\n        min1 = min2 = max(numbers)\r\n        max1 = max2 = 0\r\n\r\n        for number in numbers:\r\n            if number < min1:\r\n                min1, min2 = number, min1\r\n            elif number < min2:\r\n                min2 = number\r\n            \r\n            if number > max1:\r\n                max1, max2 = number, max1\r\n            elif number > max2:\r\n                max2 = number\r\n        \r\n        return max1 * max2 - min1 * min2", "testcase": "print(Solution().maxProductDifference([5, 6, 2, 7, 4]), 34)\r\nprint(Solution().maxProductDifference([4, 2, 5, 9, 7, 4, 8]), 64)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-20T14:29:23.090Z", "updated_at": "2025-01-20T14:29:23.115Z"}}, {"model": "python_problems.solution", "pk": 420, "fields": {"problem": 219, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar maxProductDifference = function (numbers) {\r\n  let min1 = Math.max(...numbers);\r\n  let min2 = Math.max(...numbers);\r\n  let max1 = 0;\r\n  let max2 = 0;\r\n\r\n  for (const number of numbers) {\r\n    if (number < min1)\r\n      [min1, min2] = [number, min1];\r\n    else if (number < min2)\r\n      min2 = number;\r\n\r\n    if (number > max1)\r\n      [max1, max2] = [number, max1];\r\n    else if (number > max2)\r\n      max2 = number;\r\n  }\r\n\r\n  return max1 * max2 - min1 * min2\r\n}", "testcase": "console.log(maxProductDifference([5, 6, 2, 7, 4]), 34)\r\nconsole.log(maxProductDifference([4, 2, 5, 9, 7, 4, 8]), 64)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-20T14:36:57.371Z", "updated_at": "2025-01-20T14:36:57.392Z"}}, {"model": "python_problems.solution", "pk": 421, "fields": {"problem": 220, "language": 1, "owner": 3, "solution": "# draft\r\n#         0          1 = 2**0\r\n#        01          2 = 2**1\r\n#       0110         4 = 2**2\r\n#     01101001\r\n# 0110100110010110\r\n\r\n\r\n# O(n), O(1)\r\n# two pointers, binary search\r\nclass Solution:\r\n    def kthGrammar(self, n: int, k: int) -> int:\r\n        left = 1\r\n        right = 2 ** (n - 1)\r\n        value = 0\r\n\r\n        while left < right:\r\n            middle = (left + right) // 2\r\n\r\n            if k <= middle:\r\n                right = middle\r\n            else:\r\n                left = middle + 1\r\n                value = 0 if value else 1\r\n\r\n        return value\r\n\r\n\r\n# O(n2), O(n)\r\n# mle\r\nclass Solution:\r\n    def kthGrammar(self, number: int, k: int) -> int:\r\n        row = [0]\r\n        \r\n        for _ in range(number - 1):\r\n            for index in range(len(row)):\r\n                if row[index]:\r\n                    row.append(0)\r\n                else:\r\n                    row.append(1)\r\n        \r\n        return row[k - 1]", "testcase": "print(Solution().kthGrammar(1, 1), 0)\r\nprint(Solution().kthGrammar(2, 1), 0)\r\nprint(Solution().kthGrammar(2, 2), 1)\r\nprint(Solution().kthGrammar(30, 434991989), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-20T17:32:16.856Z", "updated_at": "2025-01-20T17:32:16.879Z"}}, {"model": "python_problems.solution", "pk": 422, "fields": {"problem": 220, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * two pointers, binary search\r\n * @param {number} n\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar kthGrammar = function (n, k) {\r\n  let left = 1;\r\n  let right = 2 ** (n - 1);\r\n  let value = 0;\r\n\r\n  while (left < right) {\r\n    const middle = (left + right) / 2 | 0;\r\n\r\n    if (k <= middle)\r\n      right = middle;\r\n    else {\r\n      left = middle + 1;\r\n      value = value === 0 ? 1 : 0;\r\n    }\r\n  }\r\n\r\n  return value\r\n}", "testcase": "console.log(kthGrammar(1, 1), 0)\r\nconsole.log(kthGrammar(2, 1), 0)\r\nconsole.log(kthGrammar(2, 2), 1)\r\nconsole.log(kthGrammar(30, 434991989), 0)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-20T17:32:47.965Z", "updated_at": "2025-01-20T17:32:47.989Z"}}, {"model": "python_problems.solution", "pk": 423, "fields": {"problem": 221, "language": 1, "owner": 3, "solution": "# O(n2), O(n)\r\n# brute force\r\nclass Solution:\r\n    def subarraysWithKDistinct(self, numbers: list[int], k: int) -> int:\r\n        good_subarray_count = 0\r\n        \r\n        for i in range(len(numbers)):\r\n            counter = {}\r\n            \r\n            for j in range(i, len(numbers)):\r\n                counter[numbers[j]] = counter.get(numbers[j], 0) + 1\r\n                if len(counter) == k:\r\n                    good_subarray_count += 1\r\n        \r\n        return good_subarray_count", "testcase": "print(Solution().subarraysWithKDistinct([1, 2, 1, 2, 3], 2), 7)\r\nprint(Solution().subarraysWithKDistinct([1, 2, 1, 3, 4], 3), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-01-20T20:23:19.284Z", "updated_at": "2025-02-05T01:00:30.139Z"}}, {"model": "python_problems.solution", "pk": 424, "fields": {"problem": 221, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * sliding window\r\n * @param {number[]} numbers\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar subarraysWithKDistinct = function (numbers, k) {\r\n  const counter = new Map();\r\n  let left = 0;\r\n  let middle = 0;\r\n  let subarrayCount = 0;\r\n\r\n  for (const number of numbers) {\r\n    counter.set(number, (counter.get(number) || 0) + 1);\r\n\r\n    while (counter.size > k) {\r\n      counter.set(numbers[middle], counter.get(numbers[middle]) - 1);\r\n\r\n      if (counter.get(numbers[middle]) === 0)\r\n        counter.delete(numbers[middle]);\r\n\r\n      middle++;\r\n      left = middle;\r\n    }\r\n\r\n    while (counter.get(numbers[middle]) > 1) {\r\n      counter.set(numbers[middle], counter.get(numbers[middle]) - 1);\r\n      middle++;\r\n    }\r\n\r\n    if (counter.size === k) {\r\n      subarrayCount += (middle - left + 1);\r\n    }\r\n  }\r\n\r\n  return subarrayCount\r\n}", "testcase": "console.log(subarraysWithKDistinct([1, 2, 1, 2, 3], 2), 7)\r\nconsole.log(subarraysWithKDistinct([1, 2, 1, 3, 4], 3), 3)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-20T21:21:10.646Z", "updated_at": "2025-01-20T21:21:10.671Z"}}, {"model": "python_problems.solution", "pk": 425, "fields": {"problem": 222, "language": 1, "owner": 3, "solution": "# draft\r\n# 3, 4, 0, 1, 2\r\n# 4, 0, 1, 2, 3\r\n# 0, 1, 2, 3, 4\r\n\r\n# 2, 3, 4, 0, 1\r\n# 1, 2, 3, 4, 0\r\n\r\n# O(n), O(1)\r\n# binary search\r\nclass Solution:\r\n    def search(self, numbers: list[int], target: int) -> bool:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n\r\n            if numbers[middle] == target:\r\n                return True\r\n            elif numbers[middle] < numbers[right]:  # the right side of portion is contiguous\r\n                if numbers[middle] < target <= numbers[right]:  # if target value in the right portion\r\n                    left = middle + 1\r\n                else:\r\n                    right = middle - 1\r\n            elif numbers[middle] > numbers[right]:  # the left side of portion if contiguous\r\n                if numbers[left] <= target < numbers[middle]:  # if target value in the left side portion\r\n                    right = middle - 1\r\n                else:\r\n                    left = middle + 1\r\n            else:  # no way to tell which side of portion is contiguous\r\n                # Comparing middle number with right number, so need to\r\n                # remove the right number. Removing left could remove the target.\r\n                right -= 1\r\n\r\n        return False", "testcase": "print(Solution().search([2, 5, 6, 0, 0, 1, 2], 0), True)\r\nprint(Solution().search([2, 5, 6, 0, 0, 1, 2], 3), False)\r\nprint(Solution().search([1], 0), False)\r\nprint(Solution().search([0, 1], 0), True)\r\nprint(Solution().search([1, 0], 0), True)\r\nprint(Solution().search([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1], 2), True)\r\nprint(Solution().search([1, 0, 1, 1, 1], 0), True)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-21T10:43:14.532Z", "updated_at": "2025-01-21T10:43:14.555Z"}}, {"model": "python_problems.solution", "pk": 426, "fields": {"problem": 222, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * binary search\r\n * @param {number[]} numbers\r\n * @param {number} target\r\n * @return {boolean}\r\n */\r\nvar search = function (numbers, target) {\r\n  let left = 0;\r\n  let right = numbers.length - 1;\r\n\r\n  while (left <= right) {\r\n    const middle = (left + right) / 2 | 0;\r\n\r\n    if (numbers[middle] === target)\r\n      return true\r\n    else if (numbers[middle] < numbers[right]) {\r\n      if (\r\n        numbers[middle] < target &&\r\n        target <= numbers[right]\r\n      ) left = middle + 1;\r\n      else\r\n        right = middle - 1;\r\n    }\r\n    else if (numbers[middle] > numbers[right]) {\r\n      if (\r\n        numbers[left] <= target &&\r\n        target < numbers[middle]\r\n      ) right = middle - 1;\r\n      else\r\n        left = middle + 1;\r\n    }\r\n    else\r\n      right--\r\n  }\r\n\r\n  return false\r\n}", "testcase": "console.log(search([2, 5, 6, 0, 0, 1, 2], 0), true)\r\nconsole.log(search([2, 5, 6, 0, 0, 1, 2], 3), false)\r\nconsole.log(search([1], 0), false)\r\nconsole.log(search([0, 1], 0), true)\r\nconsole.log(search([1, 0], 0), true)\r\nconsole.log(search([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1], 2), true)\r\nconsole.log(search([1, 0, 1, 1, 1], 0), true)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-21T10:49:40.516Z", "updated_at": "2025-01-21T10:49:40.538Z"}}, {"model": "python_problems.solution", "pk": 427, "fields": {"problem": 223, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n# O(n), O(n)\r\n# binary tree\r\nclass Solution:\r\n    def tree2str(self, root: TreeNode) -> str:\r\n        text = []\r\n\r\n        def dfs(node):\r\n            if not node:\r\n                return\r\n\r\n            text.append(str(node.val))\r\n            if node.left or node.right:\r\n                text.append(\"(\")\r\n            dfs(node.left)\r\n            if node.left or node.right:\r\n                text.append(\")\")\r\n            if node.right:\r\n                text.append(\"(\")\r\n            dfs(node.right)\r\n            if node.right:\r\n                text.append(\")\")\r\n\r\n        dfs(root)\r\n        return \"\".join(text)\r\n\r\n\r\n# O(n), O(n)\r\n# binary tree\r\nclass Solution:\r\n    def tree2str(self, root: TreeNode) -> str:\r\n        text = []\r\n\r\n        def dfs(node):\r\n            if not node:\r\n                return\r\n\r\n            text.append(\"(\")\r\n            text.append(str(node.val))\r\n            if not node.left and node.right:\r\n                text.append(\"()\")\r\n            dfs(node.left)\r\n            dfs(node.right)\r\n            text.append(\")\")\r\n\r\n        dfs(root)\r\n        return \"\".join(text)[1:-1]", "testcase": "print(Solution().tree2str(build_tree_from_list([1, 2, 3, 4])), \"1(2(4))(3)\")\r\nprint(Solution().tree2str(build_tree_from_list([1, 2, 3, None, 4])), \"1(2()(4))(3)\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-21T16:30:58.984Z", "updated_at": "2025-01-21T16:30:59.009Z"}}, {"model": "python_problems.solution", "pk": 428, "fields": {"problem": 223, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\nvar tree2str = function (root) {\r\n  const text = [];\r\n\r\n  var dfs = function (node) {\r\n    if (!node) return\r\n\r\n    text.push(node.val);\r\n\r\n    if (node.left || node.right)\r\n      text.push('(');\r\n    dfs(node.left);\r\n    if (node.left || node.right)\r\n      text.push(')');\r\n\r\n    if (node.right)\r\n      text.push('(');\r\n    dfs(node.right);\r\n    if (node.right)\r\n      text.push(')');\r\n  }\r\n\r\n  dfs(root);\r\n  return text.join('')\r\n}", "testcase": "console.log(tree2str(buildTreeFromList([1, 2, 3, 4])), '1(2(4))(3)')\r\nconsole.log(tree2str(buildTreeFromList([1, 2, 3, null, 4])), '1(2()(4))(3)')", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-21T16:53:14.942Z", "updated_at": "2025-01-21T16:53:14.964Z"}}, {"model": "python_problems.solution", "pk": 429, "fields": {"problem": 224, "language": 1, "owner": 3, "solution": "import heapq\r\n\r\n# O(nlogk), O(k)\r\n# heap\r\nclass Solution:\r\n    def findKthLargest(self, numbers: list[int], k: int) -> int:\r\n        heap_min = []\r\n\r\n        for number in numbers:\r\n            if len(heap_min) < k:\r\n                heapq.heappush(heap_min, number)\r\n            else:\r\n                heapq.heappushpop(heap_min, number)\r\n\r\n        return heapq.heappop(heap_min)\r\n\r\n\r\n# O(n + klogn), O(1)\r\n# heap\r\nclass Solution:\r\n    def findKthLargest(self, numbers: list[int], k: int) -> int:\r\n        for index in range(len(numbers)):\r\n            numbers[index] = -numbers[index]\r\n        \r\n        heapq.heapify(numbers)\r\n\r\n        for _ in range(k - 1):\r\n            heapq.heappop(numbers)\r\n        \r\n        return -heapq.heappop(numbers)\r\n\r\n\r\n# O(nlogk), O(n)\r\n# heap\r\nclass Solution:\r\n    def findKthLargest(self, numbers: list[int], k: int) -> int:\r\n        return heapq.nlargest(k, numbers)[-1]\r\n\r\n\r\n# O(nlogn), O(n)\r\n# quick select, tle\r\nclass Solution:\r\n    def findKthLargest(self, numbers: list[int], k: int) -> int:\r\n        k = len(numbers) - k\r\n        \r\n        def quick_select(left, right):\r\n            pivot = numbers[right]\r\n            pivot_index = left\r\n\r\n            for index in range(left, right):\r\n                if numbers[index] < pivot:\r\n                    numbers[index], numbers[pivot_index] = numbers[pivot_index], numbers[index]\r\n                    pivot_index += 1\r\n                \r\n            numbers[pivot_index], numbers[right] = numbers[right], numbers[pivot_index]\r\n            \r\n            if k < pivot_index:\r\n                return quick_select(left, pivot_index - 1)\r\n            elif k > pivot_index:\r\n                return quick_select(pivot_index + 1, right)\r\n            else:\r\n                return numbers[pivot_index]\r\n        \r\n        return quick_select(0, len(numbers) - 1)", "testcase": "print(Solution().findKthLargest([3, 2, 1, 5, 6, 4], 2), 5)\r\nprint(Solution().findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4), 4)", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-21T20:47:32.346Z", "updated_at": "2025-01-21T20:47:32.370Z"}}, {"model": "python_problems.solution", "pk": 430, "fields": {"problem": 224, "language": 2, "owner": 3, "solution": "import { MinPriorityQueue } from '@datastructures-js/priority-queue';\r\n\r\n/**\r\n * O(nlogk), O(k)\r\n * heap\r\n * @param {number[]} numbers\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar findKthLargest = function (numbers, k) {\r\n  const minHeap = new MinPriorityQueue();\r\n\r\n  for (const number of numbers) {\r\n    minHeap.enqueue(number)\r\n    \r\n    if (minHeap.size() > k)\r\n      minHeap.dequeue()\r\n      // minHeap.dequeue().element\r\n\r\n  }\r\n  return minHeap.dequeue()\r\n  // return minHeap.dequeue().element\r\n}", "testcase": "console.log(findKthLargest([3, 2, 1, 5, 6, 4], 2), 5)\r\nconsole.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4), 4)", "time_complexity": 5, "space_complexity": 2, "created_at": "2025-01-21T20:59:22.821Z", "updated_at": "2025-01-21T20:59:22.840Z"}}, {"model": "python_problems.solution", "pk": 431, "fields": {"problem": 225, "language": 1, "owner": 3, "solution": "# O(n^2*2^n), O(n)\r\n# backtracking\r\nclass Solution:\r\n    def splitString(self, text: str) -> bool:\r\n        def dfs(index, prev, parts):\r\n            if index == len(text):\r\n                return parts > 1  # valid solution has at least two parts\r\n\r\n            for right in range(index, len(text)):  # check all substrings\r\n                value = int(text[index: right + 1])  # convert to int\r\n\r\n                if (prev == float(\"inf\") or  # first numeber or\r\n                        value == prev - 1):  # lower than previous one by one\r\n                    if dfs(right + 1, value, parts + 1):  # check current number\r\n                        return True\r\n\r\n            return False\r\n\r\n        return dfs(0, float(\"inf\"), 0)", "testcase": "print(Solution().splitString(\"1\"), False)\r\nprint(Solution().splitString(\"21\"), True)\r\nprint(Solution().splitString(\"1234\"), False)\r\nprint(Solution().splitString(\"050043\"), True)\r\nprint(Solution().splitString(\"9080701\"), False)\r\nprint(Solution().splitString(\"0090089\"), True)\r\nprint(Solution().splitString(\"001\"), False)", "time_complexity": 7, "space_complexity": 2, "created_at": "2025-01-22T07:29:21.359Z", "updated_at": "2025-01-22T07:29:21.379Z"}}, {"model": "python_problems.solution", "pk": 432, "fields": {"problem": 225, "language": 2, "owner": 3, "solution": "/**\r\n * O(n^2*2^n), O(n)\r\n * backtracking\r\n * @param {string} text\r\n * @return {boolean}\r\n */\r\nvar splitString = function (text) {\r\n  var dfs = function (index, prev, parts) {\r\n    if (index === text.length)\r\n      return parts > 1\r\n\r\n    for (let right = index; right < text.length; right++) {\r\n      const value = Number(text.slice(index, right + 1));\r\n      \r\n      if (\r\n        prev === Infinity ||\r\n        value === prev - 1\r\n      ) {\r\n        if (dfs(right + 1, value, parts + 1))\r\n          return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  return dfs(0, Infinity, 0)\r\n}", "testcase": "console.log(splitString('1'), false)\r\nconsole.log(splitString('21'), true)\r\nconsole.log(splitString('1234'), false)\r\nconsole.log(splitString('050043'), true)\r\nconsole.log(splitString('9080701'), false)\r\nconsole.log(splitString('0090089'), true)\r\nconsole.log(splitString('001'), false)", "time_complexity": 7, "space_complexity": 2, "created_at": "2025-01-22T07:30:01.679Z", "updated_at": "2025-01-22T07:30:01.702Z"}}, {"model": "python_problems.solution", "pk": 433, "fields": {"problem": 226, "language": 1, "owner": 3, "solution": "# O(n2), O(1)\r\n# matrix\r\nclass Solution:\r\n    def islandPerimeter(self, grid: list[list[int]]) -> int:\r\n        def count_borders(row, col, border):\r\n            # if adjecent tile out of bounds or a water tile, add a border\r\n            if (row - 1 < 0 or grid[row - 1][col] == 0):\r\n                border += 1\r\n            if (row + 1 == rows or grid[row + 1][col] == 0):\r\n                border += 1\r\n            if (col - 1 < 0 or grid[row][col - 1] == 0):\r\n                border += 1\r\n            if (col + 1 == cols or grid[row][col + 1] == 0):\r\n                border += 1\r\n            return border\r\n\r\n        border = 0\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        \r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if grid[row][col] == 1:\r\n                    border = count_borders(row, col, border)\r\n        \r\n        return border\r\n\r\n\r\n# O(n2), O(1)\r\n# matrix\r\nclass Solution:\r\n    def __init__(self):\r\n        self.border = 0\r\n    def islandPerimeter(self, grid: list[list[int]]) -> int:\r\n        def count_borders(row, col):\r\n            self.border += 4\r\n            \r\n            # if adjecent tile in bounds and a land tile: subtract a border\r\n            if (row - 1 >= 0 and grid[row - 1][col] == 1):\r\n                self.border -= 1\r\n            if (row + 1 < rows and grid[row + 1][col] == 1):\r\n                self.border -= 1\r\n            if (col - 1 >= 0 and grid[row][col - 1] == 1):\r\n                self.border -= 1\r\n            if (col + 1 < cols and grid[row][col + 1] == 1):\r\n                self.border -= 1\r\n\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        \r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if grid[row][col] == 1:\r\n                    count_borders(row, col)\r\n        \r\n        return self.border\r\n\r\n\r\n# O(n2), O(n2)\r\n# matrix, dfs\r\nclass Solution:\r\n    def islandPerimeter(self, grid: list[list[int]]) -> int:\r\n        tabu = set()\r\n        \r\n        def dfs(row, col):\r\n            if ((row, col) in tabu):\r\n                return 0\r\n            elif (row < 0 or\r\n                row == rows or\r\n                col < 0 or\r\n                col == cols or\r\n                    grid[row][col] == 0):\r\n                return 1\r\n            \r\n            tabu.add((row, col))\r\n            return (\r\n                dfs(row - 1, col) + \r\n                dfs(row + 1, col) + \r\n                dfs(row, col - 1) + \r\n                dfs(row, col + 1)\r\n            )\r\n\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        \r\n        for row in range(rows):\r\n            for col in range(cols):\r\n                if grid[row][col]:\r\n                    return dfs(row, col)", "testcase": "print(Solution().islandPerimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]), 16)\r\nprint(Solution().islandPerimeter([[1]]), 4)\r\nprint(Solution().islandPerimeter([[1, 0]]), 4)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-22T20:40:58.505Z", "updated_at": "2025-01-22T20:41:18.786Z"}}, {"model": "python_problems.solution", "pk": 434, "fields": {"problem": 226, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(n2)\r\n * matrix, dfs\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar islandPerimeter = function (grid) {\r\n  const rows = grid.length;\r\n  const cols = grid[0].length;\r\n  const tabu = new Set();\r\n\r\n  var dfs = function (row, col) {\r\n    if (tabu.has(`${row},${col}`))\r\n      return 0\r\n    else if (\r\n      row < 0 ||\r\n      row === rows ||\r\n      col < 0 ||\r\n      col === cols ||\r\n      grid[row][col] === 0\r\n    ) return 1\r\n  \r\n    tabu.add(`${row},${col}`);\r\n\r\n    return (\r\n      dfs(row - 1, col) +\r\n      dfs(row + 1, col) +\r\n      dfs(row, col - 1) +\r\n      dfs(row, col + 1)\r\n    )\r\n  }\r\n\r\n  for (let row = 0; row < rows; row++) {\r\n    for (let col = 0; col < cols; col++) {\r\n      if (grid[row][col] === 1)\r\n        return dfs(row, col)\r\n    }\r\n  }\r\n}", "testcase": "console.log(islandPerimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]), 16)\r\nconsole.log(islandPerimeter([[1]]), 4)\r\nconsole.log(islandPerimeter([[1, 0]]), 4)", "time_complexity": 3, "space_complexity": 3, "created_at": "2025-01-22T20:42:01.824Z", "updated_at": "2025-01-22T20:42:01.846Z"}}, {"model": "python_problems.solution", "pk": 435, "fields": {"problem": 227, "language": 1, "owner": 3, "solution": "# O(n2), O(1)\r\n# hash map\r\nclass Solution:\r\n    def isAlienSorted(self, words: list[str], order: str) -> bool:\r\n        order_of_letters = {letter: index  # {letter: index}\r\n                            for index, letter \r\n                            in enumerate(order)}\r\n\r\n        for word_index in range(len(words) - 1):  # for every two words\r\n            for letter_index in range(len(words[word_index])):  # for every letter first word\r\n                if letter_index == len(words[word_index + 1]):  # first word is seconds word prefix\r\n                    return False\r\n\r\n                left_letter = words[word_index][letter_index]  # left word letter\r\n                right_letter = words[word_index + 1][letter_index]  # right word letter\r\n                \r\n                if order_of_letters[left_letter] < order_of_letters[right_letter]:  # if left letter is lower, check next pair\r\n                    break\r\n                elif order_of_letters[left_letter] > order_of_letters[right_letter]:  # if right letter is higher, then wrong sort\r\n                    return False\r\n                \r\n        return True", "testcase": "print(Solution().isAlienSorted([\"hello\", \"leetcode\"], \"hlabcdefgijkmnopqrstuvwxyz\"), True)\r\nprint(Solution().isAlienSorted([\"word\", \"world\", \"row\"], \"worldabcefghijkmnpqstuvxyz\"), False)\r\nprint(Solution().isAlienSorted([\"apple\", \"app\"], \"abcdefghijklmnopqrstuvwxyz\"), False)\r\nprint(Solution().isAlienSorted([\"ubg\", \"kwh\"], \"qcipyamwvdjtesbghlorufnkzx\"), True)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-22T21:56:49.450Z", "updated_at": "2025-01-22T22:30:28.576Z"}}, {"model": "python_problems.solution", "pk": 436, "fields": {"problem": 227, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(1)\r\n * hash map\r\n * @param {string[]} words\r\n * @param {string} order\r\n * @return {boolean}\r\n */\r\nvar isAlienSorted = function (words, order) {\r\n  const orderOfLetters = new Map(order.split('').map((letter, index) => [letter, index]));\r\n\r\n  for (let wordIndex = 0; wordIndex < words.length - 1; wordIndex++) {\r\n    for (let letterIndex = 0; letterIndex < words[wordIndex].length; letterIndex++) {\r\n      if (letterIndex === words[wordIndex + 1].length)\r\n        return false\r\n\r\n      const leftLetter = words[wordIndex][letterIndex];\r\n      const rightLetter = words[wordIndex + 1][letterIndex];\r\n\r\n      if (orderOfLetters.get(leftLetter) < orderOfLetters.get(rightLetter))\r\n        break\r\n      else if (orderOfLetters.get(leftLetter) > orderOfLetters.get(rightLetter))\r\n        return false\r\n    }\r\n  }\r\n  return true\r\n}", "testcase": "console.log(isAlienSorted(['hello', 'leetcode'], 'hlabcdefgijkmnopqrstuvwxyz'), true)\r\nconsole.log(isAlienSorted(['word', 'world', 'row'], 'worldabcefghijkmnpqstuvxyz'), false)\r\nconsole.log(isAlienSorted(['apple', 'app'], 'abcdefghijklmnopqrstuvwxyz'), false)\r\nconsole.log(isAlienSorted([\"ubg\", \"kwh\"], \"qcipyamwvdjtesbghlorufnkzx\"), true)", "time_complexity": 3, "space_complexity": 1, "created_at": "2025-01-22T22:30:03.947Z", "updated_at": "2025-01-22T22:30:39.445Z"}}, {"model": "python_problems.solution", "pk": 437, "fields": {"problem": 228, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# hash map\r\nclass Solution:\r\n    def findJudge(self, n: int, trust_list: list[list[int]]) -> int:\r\n        if not trust_list and n == 1:  # one person and no votes\r\n            return 1\r\n\r\n        if (not trust_list or  # if no list or\r\n                len(trust_list) < n - 1):  # not enough votes to identify the judge\r\n            return -1\r\n\r\n        a_to_b = {}  # {a: [b]}  person a to person b map\r\n        b_to_a = {}  # {b: [a]}  person b to person a map\r\n\r\n        for a, b in trust_list:  # traverse trust list\r\n            if a not in a_to_b:\r\n                a_to_b[a] = []\r\n            if b not in b_to_a:\r\n                b_to_a[b] = []\r\n\r\n            a_to_b[a].append(b)\r\n            b_to_a[b].append(a)\r\n\r\n        for key, val in b_to_a.items():\r\n            if (len(val) == (n - 1) and  # enough votes for the judge and\r\n                    key not in a_to_b):  # judge didn't vote\r\n                return key\r\n\r\n        return -1", "testcase": "print(Solution().findJudge(2, [[1, 2]]), 2)\r\nprint(Solution().findJudge(3, [[1, 3], [2, 3]]), 3)\r\nprint(Solution().findJudge(3, [[1, 3], [2, 3], [3, 1]]), -1)\r\nprint(Solution().findJudge(3, [[1, 2], [2, 3]]), -1)\r\nprint(Solution().findJudge(1, []), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-23T11:56:01.401Z", "updated_at": "2025-01-23T11:56:01.435Z"}}, {"model": "python_problems.solution", "pk": 438, "fields": {"problem": 228, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * hash map\r\n * @param {number} n\r\n * @param {number[][]} trust\r\n * @return {number}\r\n */\r\nvar findJudge = function (n, trustList) {\r\n  if (trustList.length === 0 &&\r\n    n === 1)\r\n    return 1\r\n\r\n  const aToB = new Map();\r\n  const bToA = new Map();\r\n\r\n  for (const [a, b] of trustList) {\r\n    if (!aToB.has(a))\r\n      aToB.set(a, []);\r\n    if (!bToA.has(b))\r\n      bToA.set(b, []);\r\n\r\n    aToB.get(a, []).push(b);\r\n    bToA.get(b, []).push(a);\r\n  }\r\n\r\n  for (const [key, val] of bToA.entries()) {\r\n    if (\r\n      val.length === n - 1 &&\r\n      !aToB.has(key))\r\n      return key\r\n  }\r\n\r\n  return -1\r\n}", "testcase": "console.log(findJudge(2, [[1, 2]]), 2)\r\nconsole.log(findJudge(3, [[1, 3], [2, 3]]), 3)\r\nconsole.log(findJudge(3, [[1, 3], [2, 3], [3, 1]]), -1)\r\nconsole.log(findJudge(3, [[1, 2], [2, 3]]), -1)\r\nconsole.log(findJudge(1, []), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-23T11:56:34.008Z", "updated_at": "2025-01-23T11:56:34.029Z"}}, {"model": "python_problems.solution", "pk": 439, "fields": {"problem": 229, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n[1, 4, 9, 16, 25]\r\n12 = 4 + 4 + 4 => 3\r\n13 = 4 + 9 => 2\r\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\r\n[   1  1  2  1  2  2  3  2  1           3]\r\n[   1, 2,    4              9]\r\n\"\"\"\r\n\r\n\r\ndef get_squares(n: int) -> set:\r\n    \"\"\"\r\n    Get all squared numbers smaller than n.\r\n    \"\"\"\r\n    squares = set()\r\n    number = 0\r\n\r\n    while True:\r\n        number += 1\r\n        if number**2 > n:\r\n            break\r\n        squares.add(number**2)\r\n        \r\n    return squares\r\n\r\n\r\nclass Solution:\r\n    def numSquares(self, n: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        O(n^sqrtn)\r\n        \"\"\"\r\n        self.squares = get_squares(n)\r\n\r\n        def dfs(n: int) -> int:\r\n            if n == 0:\r\n                return 0\r\n            # elif n < 0:  # equals to `if n - number >= 0` in return\r\n            #     return 2\r\n            \r\n            return min(1 + dfs(n - number)\r\n                       for number in self.squares\r\n                       if n - number >= 0)\r\n        \r\n        return dfs(n)\r\n\r\n\r\nclass Solution:\r\n    def numSquares(self, n: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as hash map\r\n        O(nsqrtn)\r\n        \"\"\"\r\n        self.squares = get_squares(n)\r\n        memo = {0: 0}  # number of ways to get to the target (index)\r\n\r\n        def dfs(n: int) -> int:\r\n            if n in memo:\r\n                return memo[n]\r\n            elif n in self.squares:  # Explicitly handle perfect squares\r\n                memo[n] = 1\r\n                return 1\r\n            # elif n < 0:  # equals to `if n - number >= 0` in return\r\n            #     return 2\r\n            \r\n            memo[n] = min(1 + dfs(n - number)\r\n                          for number in self.squares\r\n                          if n - number >= 0)\r\n            return memo[n]\r\n        \r\n        return dfs(n)\r\n\r\n\r\nclass Solution:\r\n    def numSquares(self, n: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as list\r\n        O(nsqrtn)\r\n        \"\"\"\r\n        self.squares = get_squares(n)\r\n        memo = [None] * (n + 1)  # number of ways to get to the target (index)\r\n        memo[0] = 0\r\n\r\n        def dfs(n: int) -> int:\r\n            if memo[n] is not None:\r\n                return memo[n]\r\n            elif n in self.squares:  # Explicitly handle perfect squares\r\n                memo[n] = 1\r\n                return 1\r\n            # elif n < 0:  # equals to `if n - number >= 0` in return\r\n            #     return 2\r\n            \r\n            memo[n] = min(1 + dfs(n - number)\r\n                          for number in self.squares\r\n                          if n - number >= 0)\r\n            return memo[n]\r\n        return dfs(n)\r\n\r\n\r\nclass Solution:\r\n    def numSquares(self, n: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up\r\n        O(nsqrtn)\r\n        \"\"\"\r\n        self.squares = get_squares(n)\r\n        cache = [n + 1] * (n + 1)  # number of ways to get to the target (index)\r\n        cache[0] = 0\r\n\r\n        for index in range(1, n + 1):\r\n            if index in self.squares:  # early continue: if target (index) is in squares there is no need to calculate it\r\n                cache[index] = 1\r\n                continue\r\n\r\n            for number in self.squares:\r\n                if index - number >= 0:\r\n                    cache[index] = min(cache[index], \r\n                                       cache[index - number] + 1)\r\n\r\n        return cache[-1]", "testcase": "print(Solution().numSquares(1), 1)  # 1\r\nprint(Solution().numSquares(9), 1)  # 9\r\nprint(Solution().numSquares(16), 1)  # 1\r\nprint(Solution().numSquares(2), 2)  # 2 = 1 + 1\r\nprint(Solution().numSquares(5), 2)  # 5 = 4 + 1\r\nprint(Solution().numSquares(13), 2)  # 13 = 9 + 4\r\nprint(Solution().numSquares(12), 3)  # 12 = 4 + 4 + 4\r\nprint(Solution().numSquares(7), 4)  # 7 = 4 + 1 + 1 + 1\r\nprint(Solution().numSquares(28), 4)  # 28 = 16 + 9 + 1 + 1 + 1 or 28 = 25 + 1 + 1 + 1\r\nprint(Solution().numSquares(43), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-01-24T17:10:57.864Z", "updated_at": "2025-02-20T07:34:17.205Z"}}, {"model": "python_problems.solution", "pk": 440, "fields": {"problem": 229, "language": 2, "owner": 3, "solution": "/**\r\n * O(nsqrtn), O(n)\r\n * dp, botom-up, tabulation with list\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar numSquares = function (n) {\r\n  const cache = Array(n + 1).fill(n + 1);\r\n  const primarySquared = Array.from({length: Number(n ** 0.5) + 1}, (_, index) => index ** 2);\r\n\r\n  for (let index = 1; index <= n; index++) {\r\n    if (primarySquared.includes(index)) {\r\n      cache[index] = 1;\r\n    }\r\n    else {\r\n      for (const number of primarySquared) {\r\n        if (index - number > 0) {\r\n          cache[index] = Math.min(cache[index], cache[index - number] + 1)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return cache[cache.length - 1]\r\n};", "testcase": "console.log(numSquares(13), 2)\r\nconsole.log(numSquares(12), 3)\r\nconsole.log(numSquares(9), 1)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-01-24T17:11:43.498Z", "updated_at": "2025-01-24T17:11:43.518Z"}}, {"model": "python_problems.solution", "pk": 441, "fields": {"problem": 230, "language": 1, "owner": 3, "solution": "import heapq\r\n\r\n# O(n), O(1)\r\nclass Solution:\r\n    def buyChoco(self, prices: list[int], money: int) -> int:\r\n        if len(prices) < 2:\r\n            return money\r\n        \r\n        heapq.heapify(prices)\r\n        chocolate_cost = heapq.heappop(prices) + heapq.heappop(prices)\r\n        # chocolate_cost = sum(heapq.nsmallest(2, prices))\r\n\r\n        if chocolate_cost <= money:\r\n            return money - chocolate_cost\r\n        else:\r\n            return money\r\n\r\n\r\n# O(n), O(1)\r\nclass Solution:\r\n    def buyChoco(self, prices: list[int], money: int) -> int:\r\n        if len(prices) < 2:\r\n            return money\r\n        \r\n        min1 = min2 = max(prices)\r\n\r\n        for price in prices:\r\n            if price < min1:\r\n                min1, min2 = price, min1\r\n            elif price < min2:\r\n                min2 = price\r\n\r\n        if (min1 + min2) <= money:\r\n            return money - (min1 + min2)\r\n        else:\r\n            return money", "testcase": "print(Solution().buyChoco([1, 2, 2], 3), 0)\r\nprint(Solution().buyChoco([3, 2, 3], 3), 3)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-24T20:25:59.373Z", "updated_at": "2025-01-24T20:25:59.396Z"}}, {"model": "python_problems.solution", "pk": 442, "fields": {"problem": 230, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * @param {number[]} prices\r\n * @param {number} money\r\n * @return {number}\r\n */\r\nvar buyChoco = function (prices, money) {\r\n  let min1 = Infinity;\r\n  let min2 = Infinity;\r\n\r\n  for (const price of prices) {\r\n    if (price < min1)\r\n      [min1, min2] = [price, min1];\r\n    else if (price < min2)\r\n      min2 = price;\r\n  }\r\n\r\n  if (min1 + min2 <= money)\r\n    return money - (min1 + min2)\r\n  else\r\n    return money\r\n};", "testcase": "console.log(buyChoco([1, 2, 2], 3), 0)\r\nconsole.log(buyChoco([3, 2, 3], 3), 3)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-24T20:30:04.091Z", "updated_at": "2025-01-24T20:30:04.111Z"}}, {"model": "python_problems.solution", "pk": 443, "fields": {"problem": 231, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\n# hash map\r\nclass Solution:\r\n    def lemonadeChange(self, bills: list[int]) -> bool:\r\n        cash = {5: 0, 10: 0, 20: 0}\r\n\r\n        for bill in bills:\r\n            if bill == 5:\r\n                cash[5] += 1\r\n            elif bill == 10:\r\n                cash[5] -= 1\r\n                cash[10] += 1\r\n            elif cash[10] > 0:\r\n                cash[5] -= 1\r\n                cash[10] -= 1\r\n            else:\r\n                cash[5] -= 3\r\n                cash[20] += 1\r\n            \r\n            if (cash[5] < 0 or \r\n                    cash[10] < 0):\r\n                return False\r\n            \r\n        return True", "testcase": "print(Solution().lemonadeChange([5, 5, 5, 10, 20]), True)\r\nprint(Solution().lemonadeChange([5, 5, 10, 10, 20]), False)\r\nprint(Solution().lemonadeChange([5,5,10,20,5,5,5,5,5,5,5,5,5,10,5,5,20,5,20,5]), True)\r\nprint(Solution().lemonadeChange([5,5,5,10,5,5,10,20,20,20]), False)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-24T21:10:07.383Z", "updated_at": "2025-01-24T21:10:07.403Z"}}, {"model": "python_problems.solution", "pk": 444, "fields": {"problem": 231, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * @param {number[]} bills\r\n * @return {boolean}\r\n */\r\nvar lemonadeChange = function (bills) {\r\n  let fives = 0;\r\n  let tens = 0;\r\n\r\n  for (const bill of bills) {\r\n    if (bill === 5)\r\n      fives += 1;\r\n    else if (bill === 10) {\r\n      fives -= 1;\r\n      tens += 1;\r\n    }\r\n    else if (tens > 0) {\r\n      tens -= 1;\r\n      fives -= 1;\r\n    }\r\n    else\r\n      fives -= 3;\r\n\r\n    if (\r\n      fives < 0 ||\r\n      tens < 0\r\n    ) return false\r\n  }\r\n\r\n  return true\r\n};", "testcase": "console.log(lemonadeChange([5, 5, 5, 10, 20]), true)\r\nconsole.log(lemonadeChange([5, 5, 10, 10, 20]), false)\r\nconsole.log(lemonadeChange([5, 5, 10, 20, 5, 5, 5, 5, 5, 5, 5, 5, 5, 10, 5, 5, 20, 5, 20, 5]), true)\r\nconsole.log(lemonadeChange([5, 5, 5, 10, 5, 5, 10, 20, 20, 20]), false)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-24T21:11:01.786Z", "updated_at": "2025-01-24T21:11:01.806Z"}}, {"model": "python_problems.solution", "pk": 445, "fields": {"problem": 232, "language": 1, "owner": 3, "solution": "# O(n), O(n)\r\nclass Solution:\r\n    def maximumOddBinaryNumber(self, text: str) -> str:\r\n        ones = zeros = 0\r\n        \r\n        for digit in text:\r\n            if digit == \"1\":\r\n                ones += 1\r\n            else:\r\n                zeros += 1\r\n\r\n        return \"1\" * (ones - 1) + \"0\" * zeros + \"1\"\r\n\r\n\r\n# O(n), O(n)\r\n# quick sort\r\nclass Solution:\r\n    def maximumOddBinaryNumber(self, text: str) -> str:\r\n        text = [digit for digit in text]\r\n        left = 0\r\n\r\n        for index in range(len(text)):\r\n            if text[index] == \"1\":\r\n                text[index], text[left] = text[left], text[index]\r\n                left += 1\r\n            \r\n        text[left - 1], text[len(text) - 1] = text[len(text) - 1], text[left - 1]\r\n        return \"\".join(text)", "testcase": "print(Solution().maximumOddBinaryNumber(\"010\"), \"001\")\r\nprint(Solution().maximumOddBinaryNumber(\"0101\"), \"1001\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-24T22:11:02.101Z", "updated_at": "2025-01-24T22:11:02.129Z"}}, {"model": "python_problems.solution", "pk": 446, "fields": {"problem": 232, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * @param {string} text\r\n * @return {string}\r\n */\r\nvar maximumOddBinaryNumber = function (text) {\r\n  let ones = 0;\r\n  let zeros = 0;\r\n\r\n  for (const digit of text) {\r\n    if (digit === '1')\r\n      ones++;\r\n    else\r\n      zeros++;\r\n  }\r\n\r\n  return '1'.repeat(ones - 1) + '0'.repeat(zeros) + '1'\r\n};", "testcase": "console.log(maximumOddBinaryNumber(\"010\"), \"001\")\r\nconsole.log(maximumOddBinaryNumber(\"0101\"), \"1001\")\r\nconsole.log(maximumOddBinaryNumber(\"1\"), \"1\")", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-24T22:11:39.660Z", "updated_at": "2025-01-24T22:11:39.686Z"}}, {"model": "python_problems.solution", "pk": 447, "fields": {"problem": 233, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\nclass Solution:\r\n    def maxDepth(self, text: str) -> int:\r\n        depth = 0\r\n        opening = 0\r\n\r\n        for char in text:\r\n            if char == \"(\":\r\n                opening += 1\r\n            elif char == \")\":\r\n                opening -= 1\r\n            \r\n            depth = max(depth, opening)\r\n        \r\n        return depth", "testcase": "print(Solution().maxDepth(\"(1+(2*3)+((8)/4))+1\"), 3)\r\nprint(Solution().maxDepth(\"(1)+((2))+(((3)))\"), 3)\r\nprint(Solution().maxDepth(\"()(())((()()))\"), 3)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-24T22:54:42.907Z", "updated_at": "2025-01-24T22:54:42.927Z"}}, {"model": "python_problems.solution", "pk": 448, "fields": {"problem": 233, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * @param {string} text\r\n * @return {number}\r\n */\r\nvar maxDepth = function (text) {\r\n  let detph = 0;\r\n  let opening = 0;\r\n\r\n  for (const char of text) {\r\n    if (char === '(')\r\n      opening += 1;\r\n    else if (char === ')')\r\n      opening -= 1;\r\n\r\n    detph = Math.max(detph, opening)\r\n  }\r\n  return detph\r\n};", "testcase": "console.log(maxDepth('(1+(2*3)+((8)/4))+1'), 3)\r\nconsole.log(maxDepth('(1)+((2))+(((3)))'), 3)\r\nconsole.log(maxDepth('()(())((()()))'), 3)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-24T22:55:13.381Z", "updated_at": "2025-01-24T22:55:13.402Z"}}, {"model": "python_problems.solution", "pk": 449, "fields": {"problem": 234, "language": 1, "owner": 3, "solution": "# O(n), O(1)\r\nclass Solution:\r\n    def maxScore(self, text: str) -> int:\r\n        left_score = 0\r\n        right_score = text.count(\"1\")\r\n        max_score = 0\r\n        \r\n        for index in range(len(text) - 1):\r\n            if text[index] == \"0\":\r\n                left_score += 1\r\n            else:\r\n                right_score -= 1\r\n        \r\n            max_score = max(max_score, left_score + right_score)\r\n        \r\n        return max_score", "testcase": "print(Solution().maxScore(\"011101\"), 5)\r\nprint(Solution().maxScore(\"00111\"), 5)\r\nprint(Solution().maxScore(\"1111\"), 3)\r\nprint(Solution().maxScore(\"00\"), 1)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-25T01:18:31.826Z", "updated_at": "2025-01-25T01:18:31.846Z"}}, {"model": "python_problems.solution", "pk": 450, "fields": {"problem": 234, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * @param {string} s\r\n * @return {number}\r\n */\r\nvar maxScore = function (text) {\r\n  let rightScore = text.split('').filter((digit) => digit === '1').length;\r\n  let leftScore = 0;\r\n  let maxScore = 0;\r\n\r\n  for (let index = 0; index < text.length - 1; index++) {\r\n    const digit = text[index];\r\n\r\n    if (digit === '0')\r\n      leftScore++;\r\n    else if (digit === '1')\r\n      rightScore--;\r\n\r\n    maxScore = Math.max(maxScore, leftScore + rightScore);\r\n  }\r\n\r\n  return maxScore\r\n}", "testcase": "console.log(maxScore(\"011101\"), 5)\r\nconsole.log(maxScore(\"00111\"), 5)\r\nconsole.log(maxScore(\"1111\"), 3)\r\nconsole.log(maxScore(\"00\"), 1)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-25T01:25:50.424Z", "updated_at": "2025-01-25T01:25:50.445Z"}}, {"model": "python_problems.solution", "pk": 451, "fields": {"problem": 235, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def isPathCrossing(self, path: str) -> bool:\r\n        stops = {(0, 0)}  # {(x, y)}\r\n        prev_stop = (0, 0)\r\n\r\n        directions = {\r\n            \"E\": (1, 0),\r\n            \"W\": (-1, 0),\r\n            \"N\": (0, 1),\r\n            \"S\": (0, -1)\r\n        }\r\n\r\n        for direction in path:\r\n            next_stop = (prev_stop[0] + directions[direction][0],\r\n                         prev_stop[1] + directions[direction][1])\r\n\r\n            if next_stop in stops:\r\n                return True\r\n            else:\r\n                stops.add(next_stop)\r\n                prev_stop = next_stop\r\n\r\n        return False", "testcase": "print(Solution().isPathCrossing(\"NES\"), False)\r\nprint(Solution().isPathCrossing(\"NESWW\"), True)\r\nprint(Solution().isPathCrossing(\"WNSN\"), True)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-25T12:38:02.841Z", "updated_at": "2025-01-25T12:38:02.865Z"}}, {"model": "python_problems.solution", "pk": 452, "fields": {"problem": 235, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * @param {string} path\r\n * @return {boolean}\r\n */\r\nvar isPathCrossing = function (path) {\r\n  const stops = new Set([`0,0`]);\r\n  let prev = [0, 0];\r\n\r\n  const directions = new Map([\r\n    ['E', [1, 0]],\r\n    ['W', [-1, 0]],\r\n    ['N', [0, 1]],\r\n    ['S', [0, -1]]\r\n  ])\r\n\r\n  for (const direction of path) {\r\n    const next_x = prev[0] + directions.get(direction)[0];\r\n    const next_y = prev[1] + directions.get(direction)[1];\r\n\r\n    if (stops.has(`${next_x},${next_y}`))\r\n      return true\r\n    else {\r\n      stops.add(`${next_x},${next_y}`)\r\n      prev = [next_x, next_y]\r\n    }\r\n  }\r\n\r\n  return false\r\n};", "testcase": "console.log(isPathCrossing('NES'), false)\r\nconsole.log(isPathCrossing('NESWW'), true)\r\nconsole.log(isPathCrossing('WNSN'), true)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-25T13:00:42.015Z", "updated_at": "2025-01-25T13:00:42.039Z"}}, {"model": "python_problems.solution", "pk": 453, "fields": {"problem": 236, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def minCost(self, colors: str, neededTime: list[int]) -> int:\r\n        left = 0  # left pointer\r\n        minimum_time = 0  # minnium time to remove consecutive same color baloons\r\n\r\n        for right in range(1, len(colors)):\r\n            if colors[left] != colors[right]:  # different color\r\n                left = right  # move left pointer\r\n            else:\r\n                if neededTime[left] <= neededTime[right]:  # left time is less (equal) than right time\r\n                    minimum_time += neededTime[left]  # add time needed to remove the left baloon\r\n                    left = right  # move left pointer\r\n                else:\r\n                    minimum_time += neededTime[right]  # add time needed to remove the right baloon\r\n\r\n        return minimum_time", "testcase": "print(Solution().minCost(\"abaac\", [1, 2, 3, 4, 5]), 3)\r\nprint(Solution().minCost(\"abc\", [1, 2, 3]), 0)\r\nprint(Solution().minCost(\"aabaa\", [1, 2, 3, 4, 1]), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-25T13:59:59.543Z", "updated_at": "2025-01-25T13:59:59.567Z"}}, {"model": "python_problems.solution", "pk": 454, "fields": {"problem": 236, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * @param {string} colors\r\n * @param {number[]} neededTime\r\n * @return {number}\r\n */\r\nvar minCost = function (colors, neededTime) {\r\n  let left = 0;\r\n  let minTime = 0;\r\n\r\n  for (let right = 1; right < colors.length; right++) {\r\n    if (colors[left] === colors[right]) {\r\n      if (neededTime[left] < neededTime[right]) {\r\n        minTime += neededTime[left];\r\n        left = right;\r\n      } else {\r\n        minTime += neededTime[right];\r\n      }\r\n    } else {\r\n      left = right;\r\n    }\r\n  }\r\n  return minTime\r\n};", "testcase": "console.log(minCost(\"abaac\", [1, 2, 3, 4, 5]), 3)\r\nconsole.log(minCost(\"abc\", [1, 2, 3]), 0)\r\nconsole.log(minCost(\"aabaa\", [1, 2, 3, 4, 1]), 2)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-25T14:09:01.523Z", "updated_at": "2025-01-25T14:09:01.545Z"}}, {"model": "python_problems.solution", "pk": 455, "fields": {"problem": 237, "language": 1, "owner": 3, "solution": "# O(logn), O(1)\r\n# binary search\r\nclass Solution:\r\n    def searchRange(self, numbers: list[int], target: int) -> list[int]:\r\n        left = 0\r\n        right = len(numbers) - 1\r\n        has_target = False\r\n\r\n        # find target starting position\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n            middle_number = numbers[middle]\r\n\r\n            if target > middle_number:\r\n                left = middle + 1\r\n            else:\r\n                if target == middle_number:  # check if numbers has tagret numebr\r\n                    has_target = True\r\n                first_position = middle  # first_position == left, after exiting while loop\r\n                right = middle - 1\r\n\r\n        # no target in numbers\r\n        if not has_target:\r\n            return [-1, -1]\r\n\r\n        left = 0\r\n        right = len(numbers) - 1\r\n\r\n        # find target ending position\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n            middle_number = numbers[middle]\r\n\r\n            if target < middle_number:\r\n                right = middle - 1\r\n            else:\r\n                last_position = middle  # last_position == right, after exiting while loop\r\n                left = middle + 1\r\n\r\n        return [first_position, last_position]", "testcase": "print(Solution().searchRange([5, 7, 7, 8, 8, 10], 8), [3, 4])\r\nprint(Solution().searchRange([5, 7, 7, 8, 8, 10], 6), [-1, -1])\r\nprint(Solution().searchRange([], 0), [-1, -1])\r\nprint(Solution().searchRange([1], 1), [0, 0])", "time_complexity": 4, "space_complexity": 1, "created_at": "2025-01-26T13:14:02.833Z", "updated_at": "2025-01-26T13:14:02.859Z"}}, {"model": "python_problems.solution", "pk": 456, "fields": {"problem": 237, "language": 2, "owner": 3, "solution": "/**\r\n * O(logn), O(1)\r\n * binary search\r\n * @param {number[]} numbers\r\n * @param {number} target\r\n * @return {number[]}\r\n */\r\nvar searchRange = function (numbers, target) {\r\n  let left = 0;\r\n  let right = numbers.length - 1;\r\n  let hasTarget = false;\r\n  let first_position = -1;\r\n  let last_position = -1;\r\n\r\n  while (left <= right) {\r\n    const middle = (left + right) / 2 | 0;\r\n    const middle_number = numbers[middle];\r\n\r\n    if (target > middle_number) {\r\n      left = middle + 1;\r\n    }\r\n    else {\r\n      if (target === middle_number) {\r\n        hasTarget = true;\r\n      }\r\n      first_position = middle;\r\n      right = middle - 1;\r\n    }\r\n  }\r\n\r\n  if (!hasTarget)\r\n    return [-1, -1]\r\n\r\n  left = 0;\r\n  right = numbers.length - 1;\r\n\r\n  while (left <= right) {\r\n    const middle = (left + right) / 2 | 0;\r\n    const middle_number = numbers[middle];\r\n\r\n    if (target < middle_number) {\r\n      right = middle - 1;\r\n    }\r\n    else {\r\n      last_position = middle;\r\n      left = middle + 1;\r\n    }\r\n  }\r\n\r\n  return [first_position, last_position]\r\n};", "testcase": "console.log(searchRange([5, 7, 7, 8, 8, 10], 8), [3, 4])\r\nconsole.log(searchRange([5, 7, 7, 8, 8, 10], 6), [-1, -1])\r\nconsole.log(searchRange([], 0), [-1, -1])\r\nconsole.log(searchRange([1], 1), [0, 0])", "time_complexity": 4, "space_complexity": 1, "created_at": "2025-01-26T14:19:34.327Z", "updated_at": "2025-01-26T14:19:34.346Z"}}, {"model": "python_problems.solution", "pk": 457, "fields": {"problem": 238, "language": 1, "owner": 3, "solution": "# 1 -> 3 > 2 <-> 4\r\n# 3 -> 4 -> 2 -> 3 -> 4\r\nclass Solution:\r\n    def findDuplicate(self, numbers: list[int]) -> int:\r\n        slow = 0\r\n        fast = 0\r\n\r\n        # find the intersection\r\n        while True:\r\n            slow = numbers[slow]\r\n            fast = numbers[numbers[fast]]\r\n            if fast == slow:\r\n                break\r\n        \r\n        # return [slow, numbers[slow]]  # [index, number]\r\n\r\n        # find the beginning of the cycle\r\n        # The distance from the intersection to the beginning of the cycle is the same as\r\n        # from the beginning of the graph to the beginning of the cycle.\r\n        slow2 = 0\r\n        while True:\r\n            slow = numbers[slow]\r\n            slow2 = numbers[slow2]\r\n            if slow == slow2:\r\n                return slow", "testcase": "print(Solution().findDuplicate([1, 3, 4, 2, 2]), 2)\r\nprint(Solution().findDuplicate([3, 1, 3, 4, 2]), 3)\r\nprint(Solution().findDuplicate([3, 3, 3, 3, 3]), 3)\r\nprint(Solution().findDuplicate([2, 5, 9, 6, 9, 3, 8, 9, 7, 1]), 9)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-26T16:17:46.875Z", "updated_at": "2025-01-26T16:17:46.895Z"}}, {"model": "python_problems.solution", "pk": 458, "fields": {"problem": 238, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * linked list\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar findDuplicate = function (numbers) {\r\n  let slow = 0;\r\n  let fast = 0;\r\n\r\n  while (true) {\r\n    slow = numbers[slow];\r\n    fast = numbers[numbers[fast]];\r\n    if (slow === fast) break\r\n  }\r\n\r\n  let slow2 = 0;\r\n  while (true) {\r\n    slow = numbers[slow];\r\n    slow2 = numbers[slow2];\r\n    if (slow === slow2)\r\n      return slow\r\n  }\r\n};", "testcase": "console.log(findDuplicate([1, 3, 4, 2, 2]), 2)\r\nconsole.log(findDuplicate([3, 1, 3, 4, 2]), 3)\r\nconsole.log(findDuplicate([3, 3, 3, 3, 3]), 3)\r\nconsole.log(findDuplicate([2, 5, 9, 6, 9, 3, 8, 9, 7, 1]), 9)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-26T16:35:23.199Z", "updated_at": "2025-01-26T16:35:23.225Z"}}, {"model": "python_problems.solution", "pk": 459, "fields": {"problem": 239, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n\r\n\r\n# O(n), O(n)\r\n# binary search, recursion\r\nclass Solution:\r\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\r\n        def dfs(node):\r\n            if not node:\r\n                return TreeNode(val)\r\n            \r\n            if val < node.val:\r\n                node.left = dfs(node.left)\r\n            else:\r\n                node.right = dfs(node.right)\r\n            \r\n            return node\r\n        return dfs(root)\r\n\r\n\r\nfrom collections import deque\r\n\r\n# O(n), O(1)\r\n# binary search, iteration\r\nclass Solution:\r\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\r\n        if not root:\r\n            return TreeNode(val)\r\n        \r\n        queue = deque([root])\r\n\r\n        while queue:\r\n            node = queue.popleft()\r\n\r\n            if val < node.val:\r\n                if not node.left:\r\n                    node.left = TreeNode(val)\r\n                else:\r\n                    queue.append(node.left)\r\n            else:\r\n                if not node.right:\r\n                    node.right = TreeNode(val)\r\n                else:\r\n                    queue.append(node.right)\r\n            \r\n        return root", "testcase": "print(level_order_traversal(Solution().insertIntoBST(build_tree_from_list([4, 2, 7, 1, 3]), 5)), [4, 2, 7, 1, 3, 5])\r\nprint(level_order_traversal(Solution().insertIntoBST(build_tree_from_list([40, 20, 60, 10, 30, 50, 70]), 25)), [40, 20, 60, 10, 30, 50, 70, None, None, 25])\r\nprint(level_order_traversal(Solution().insertIntoBST(build_tree_from_list([4, 2, 7, 1, 3, None, None, None, None, None, None]), 5)), [4, 2, 7, 1, 3, 5])", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-26T20:04:21.827Z", "updated_at": "2025-01-26T20:04:47.590Z"}}, {"model": "python_problems.solution", "pk": 460, "fields": {"problem": 239, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * O(n), O(n)\r\n * binary tree, recursion\r\n * @param {TreeNode} root\r\n * @param {number} val\r\n * @return {TreeNode}\r\n */\r\nvar insertIntoBST = function (root, val) {\r\n  if (!root)\r\n    return new TreeNode(val)\r\n  if (val < root.val)\r\n    root.left = insertIntoBST(root.left, val)\r\n  else\r\n    root.right = insertIntoBST(root.right, val)\r\n  \r\n  return root\r\n};", "testcase": "console.log(levelOrderTraversal(insertIntoBST(buildTreeFromList([4, 2, 7, 1, 3]), 5)), [4, 2, 7, 1, 3, 5])\r\nconsole.log(levelOrderTraversal(insertIntoBST(buildTreeFromList([40, 20, 60, 10, 30, 50, 70]), 25)), [40, 20, 60, 10, 30, 50, 70, null, null, 25])\r\nconsole.log(levelOrderTraversal(insertIntoBST(buildTreeFromList([4, 2, 7, 1, 3, null, null, null, null, null, null]), 5)), [4, 2, 7, 1, 3, 5])", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-26T20:17:47.930Z", "updated_at": "2025-01-26T20:17:47.953Z"}}, {"model": "python_problems.solution", "pk": 461, "fields": {"problem": 240, "language": 1, "owner": 3, "solution": "import heapq\r\nfrom collections import deque\r\n\r\n# O(n), O(n)\r\n# heap, deque\r\n# O(nlogn) -> log26 => const ->  O(n)\r\nclass Solution:\r\n    def leastInterval(self, tasks: list[str], idle: int) -> int:\r\n        counter = {}\r\n        for task in tasks:\r\n            counter[task] = counter.get(task, 0) + 1\r\n\r\n        task_heap = [-value for value in counter.values()]\r\n        queue = deque()\r\n        heapq.heapify(task_heap)\r\n\r\n        time = 0\r\n        while task_heap or queue:\r\n            time += 1 # 6\r\n            \r\n            # take most frequent task from heap, decrease frequency by one\r\n            # and append it to the queue\r\n            if task_heap:  # []\r\n                task = heapq.heappop(task_heap) + 1\r\n                if task:\r\n                    queue.append((time + idle, task)) #\r\n\r\n            # if task is not idle pop it from the queue and\r\n            # push it to the task heap\r\n            if queue and queue[0][0] == time:\r\n                _, task = queue.popleft()\r\n                heapq.heappush(task_heap, task)\r\n\r\n        return time", "testcase": "print(Solution().leastInterval([\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"], 2), 8)  # A -> B -> idle -> A -> B -> idle -> A -> B\r\nprint(Solution().leastInterval([\"A\", \"C\", \"A\", \"B\", \"D\", \"B\"], 1), 6)  # A -> B -> C -> D -> A -> B\r\nprint(Solution().leastInterval([\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"], 3), 10)  # A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-28T16:14:52.727Z", "updated_at": "2025-01-28T17:33:59.008Z"}}, {"model": "python_problems.solution", "pk": 462, "fields": {"problem": 240, "language": 2, "owner": 3, "solution": "import { MaxPriorityQueue } from '@datastructures-js/priority-queue';\r\nimport { Queue } from '@datastructures-js/queue';\r\n\r\n/**\r\n * O(n), O(n)\r\n * heap, deque\r\n * O(nlogn) -> log26 => const ->  O(n)\r\n * @param {character[]} tasks\r\n * @param {number} idle\r\n * @return {number}\r\n */\r\nvar leastInterval = function (tasks, idle) {\r\n  const counter = new Map();\r\n\r\n  for (const task of tasks) {\r\n    counter.set(task, (counter.get(task) || 0) + 1)\r\n  }\r\n\r\n  consttaskList = MaxPriorityQueue.fromArray(Array.from(counter.values()));\r\n\r\n  // const taskList = new MaxPriorityQueue();\r\n  // for (const value of counter.values()) {\r\n  //   taskList.enqueue(value)\r\n  // }\r\n\r\n  let time = 0;\r\n  const queue = new Queue();\r\n\r\n  while (taskList.size() > 0 || queue.size() > 0) {\r\n    time++;\r\n\r\n    if (taskList.size() > 0) {\r\n      const task = taskList.dequeue() - 1;\r\n      // const task = taskList.dequeue().element - 1;\r\n      if (task)\r\n        queue.push([time + idle, task]);\r\n    }\r\n\r\n    if (queue.size() > 0 && queue.front()[0] === time) {\r\n      const [_, task] = queue.pop();\r\n      taskList.push(task);\r\n      // taskList.enqueue(task);\r\n    }\r\n\r\n  }\r\n  return time\r\n};", "testcase": "console.log(leastInterval(['A', 'A', 'A', 'B', 'B', 'B'], 2), 8)  // A -> B -> idle -> A -> B -> idle -> A -> B\r\nconsole.log(leastInterval(['A', 'C', 'A', 'B', 'D', 'B'], 1), 6)  // A -> B -> C -> D -> A -> B\r\nconsole.log(leastInterval(['A', 'A', 'A', 'B', 'B', 'B'], 3), 10)  // A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-28T17:37:28.720Z", "updated_at": "2025-01-28T17:37:28.746Z"}}, {"model": "python_problems.solution", "pk": 463, "fields": {"problem": 241, "language": 1, "owner": 3, "solution": "import heapq\r\nfrom collections import defaultdict\r\n\r\n\r\n# O(1): postTweet, follow, unfollow, O(n): getNewsFeed, O(n)\r\n# heap\r\n# O(nlog10) => O(n)\r\nclass Twitter:\r\n\r\n    def __init__(self):\r\n        self.user_follows = defaultdict(set)  # {user: {followee_1, followee_2, ...}}\r\n        self.user_tweets = defaultdict(list)  #  {user: [(time stamp, tweet id), ...]}\r\n        self.time_stamp = 0\r\n\r\n    def postTweet(self, userId: int, tweetId: int) -> None:\r\n        self.time_stamp += 1  # update time stamp with higher (newer) value\r\n        self.user_tweets[userId].append((self.time_stamp, tweetId))  # save users tweet\r\n\r\n    def getNewsFeed(self, userId: int) -> list[int]:\r\n        def merge_feed(tweets: dict[list]) -> None:\r\n            if news_feed and tweets[-1][0] < news_feed[0][0]:  # if the newest tweet from a user is older than the oldest tweet from the feed\r\n                return\r\n            for tweet in tweets[-10:]:  # Only consider the 10 most recent tweets\r\n                if len(news_feed) < 10:\r\n                    heapq.heappush(news_feed, tweet)\r\n                else:\r\n                    heapq.heappushpop(news_feed, tweet)\r\n\r\n        news_feed = []  # [(time stamp, tweet id)], news feed with timestamps\r\n        # Add user's own tweets\r\n        if userId in self.user_tweets:  # if user has tweets\r\n            merge_feed(self.user_tweets[userId])\r\n\r\n        # Add followees' tweets\r\n        if userId in self.user_follows:  # if user has followees\r\n            for followee in self.user_follows[userId]:  # check every followee\r\n                merge_feed(self.user_tweets[followee])\r\n        \r\n        clean_news_feed = []  # [tweet id_1, tweet id_2], tweets witwhout timestamps starting from the newest\r\n        for _ in range(len(news_feed)):\r\n            clean_news_feed.append(heapq.heappop(news_feed)[1])  # clean news feed from time stamps\r\n        return (list(reversed(clean_news_feed)))\r\n\r\n\r\n    def follow(self, followerId: int, followeeId: int) -> None:\r\n        if followerId != followeeId:  # user should not follow itself\r\n            self.user_follows[followerId].add(followeeId)\r\n\r\n\r\n    def unfollow(self, followerId: int, followeeId: int) -> None:\r\n        if followerId in self.user_follows:  # if user has a following list (set)\r\n            self.user_follows[followerId].discard(followeeId)\r\n\r\n\r\n# Your Twitter object will be instantiated and called as such:\r\n# obj = Twitter()\r\n# obj.postTweet(userId,tweetId)\r\n# param_2 = obj.getNewsFeed(userId)\r\n# obj.follow(followerId,followeeId)\r\n# obj.unfollow(followerId,followeeId)\r\n\r\n\r\ndef test_input(operations: list[str], arguments: list[list[int | None]]) -> list[list[int] | None]:\r\n    \"\"\"\r\n    Test imput provided in two separate lists: operations and arguments\r\n    \"\"\"\r\n    twitter = None\r\n    result = []\r\n    \r\n    for operation, argument in zip(operations, arguments):\r\n        if operation == \"Twitter\":\r\n            twitter = Twitter()\r\n            result.append(None)\r\n        elif operation == \"postTweet\":\r\n            result.append(twitter.postTweet(*argument))\r\n        elif operation == \"getNewsFeed\":\r\n            result.append(twitter.getNewsFeed(*argument))\r\n        elif operation == \"follow\":\r\n            result.append(twitter.follow(*argument))\r\n        elif operation == \"unfollow\":\r\n            result.append(twitter.unfollow(*argument))\r\n\r\n    return result\r\n\r\n# Example Input\r\noperations = [\"Twitter\", \"getNewsFeed\"]\r\narguments = [[], [1]]\r\nexpected_output = [None, []]\r\n\r\noperations = [\"Twitter\",\"postTweet\",\"getNewsFeed\",\"follow\",\"postTweet\",\"getNewsFeed\",\"unfollow\",\"getNewsFeed\"]\r\narguments = [[],[1,5],[1],[1,2],[2,6],[1],[1,2],[1]]\r\nexpected_output = [None, None, [5], None, None, [6, 5], None, [5]]\r\n\r\noperations = [\"Twitter\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"postTweet\",\"getNewsFeed\",\"follow\",\"getNewsFeed\",\"unfollow\",\"getNewsFeed\"]\r\narguments = [[],[1,5],[2,3],[1,101],[2,13],[2,10],[1,2],[1,94],[2,505],[1,333],[2,22],[1,11],[1,205],[2,203],[1,201],[2,213],[1,200],[2,202],[1,204],[2,208],[2,233],[1,222],[2,211],[1],[1,2],[1],[1,2],[1]]\r\nexpected_output = [None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,None,[222,204,200,201,205,11,333,94,2,101],None,[211,222,233,208,204,202,200,213,201,203],None,[222,204,200,201,205,11,333,94,2,101]]\r\n\r\n\r\n# Run tests\r\ntest_output = test_input(operations, arguments)\r\nprint(test_output == expected_output)\r\nprint(test_output)\r\n\r\n\r\n\r\n\r\n\r\ntwitter = Twitter()\r\nprint(twitter.postTweet(1, 5))  # User 1 posts a new tweet (id = 5).\r\nprint(twitter.getNewsFeed(1))  # User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\r\nprint(twitter.follow(1, 2))  # User 1 follows user 2.\r\nprint(twitter.postTweet(2, 6))  # User 2 posts a new tweet (id = 6).\r\nprint(twitter.getNewsFeed(1))  # User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\r\nprint(twitter.unfollow(1, 2))  # User 1 unfollows user 2.\r\nprint(twitter.getNewsFeed(1))  # User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\r\nprint()\r\ntwitter = Twitter()\r\nprint(twitter.postTweet(1, 1))\r\nprint(twitter.getNewsFeed(1))  # [1]\r\nprint(twitter.follow(2, 1))\r\nprint(twitter.getNewsFeed(2))  # [1]\r\nprint(twitter.unfollow(2, 1))\r\nprint(twitter.getNewsFeed(2))  # []\r\nprint()\r\ntwitter = Twitter()\r\nprint(twitter.getNewsFeed(1))  # [0]\r\nprint()\r\ntwitter = Twitter()\r\nprint(twitter.follow(1, 5))\r\nprint(twitter.getNewsFeed(1))  # []\r\nprint()\r\ntwitter = Twitter()\r\nprint(twitter.postTweet(1, 5))\r\nprint(twitter.postTweet(1, 3))\r\nprint(twitter.getNewsFeed(1))  # [3, 5]\r\n\r\n\r\n\r\n\r\nimport heapq\r\nfrom collections import defaultdict\r\n\r\n\r\nclass ListNode:\r\n    def __init__(self, val=(0, 0), next=None):  # val=(timestamp, tweetId)\r\n        self.val = val\r\n        self.next = next\r\n\r\n# O(1): postTweet, follow, unfollow, O(n): getNewsFeed, O(n)\r\n# heap, linked list\r\n# O(nlog10) => O(n)\r\nclass Twitter:\r\n    def __init__(self):\r\n        self.user_follows = defaultdict(set)  # {user: {followee_1, followee_2, ...}}\r\n        self.user_tweets = {}  #  {user: ListNode((time stamp, tweet id), next node)}\r\n        self.time_stamp = 0\r\n\r\n    def postTweet(self, userId: int, tweetId: int) -> None:\r\n        self.time_stamp += 1  # update time stamp with higher (newer) value\r\n        if userId not in self.user_tweets:\r\n            self.user_tweets[userId] = ListNode()  # Dummy head node\r\n        \r\n        head = self.user_tweets[userId]\r\n        head.next = ListNode((self.time_stamp, tweetId), head.next)  # Insert new tweet at the front\r\n        \r\n\r\n    def getNewsFeed(self, userId: int) -> list[int]:\r\n        def merge_feed(user: int) -> None:\r\n            if (user not in self.user_tweets or # User has no tweets\r\n                    not self.user_tweets[user].next):\r\n                return\r\n            \r\n            # if news_feed and tweets[-1][0] < news_feed[0][0]:  # if the newest tweet from a user is older than the oldest tweet from the feed\r\n                # return\r\n            node = self.user_tweets[user].next\r\n            count = 0\r\n\r\n            while (node and count < 10  # take at most 10 tweets\r\n                   ):  #and node.val[0] < news_feed[0][0] take tweets that aren't older than the oldest tweet in news feed\r\n                if len(news_feed) < 10:\r\n                    heapq.heappush(news_feed, node.val)\r\n                else:\r\n                    heapq.heappushpop(news_feed, node.val)\r\n                node = node.next\r\n                count += 1\r\n\r\n        news_feed = []  # [(time stamp, tweet id)]  Min-heap for top 10 tweets\r\n        # Add user's own tweets\r\n        merge_feed(userId)\r\n\r\n        # Add followees' tweets\r\n        if userId in self.user_follows:  # if user has followees\r\n            for followee in self.user_follows[userId]:  # check every followee\r\n                merge_feed(followee)\r\n        \r\n        clean_news_feed = []  # [tweet id_1, tweet id_2], tweets witwhout timestamps starting from the newest\r\n        for _ in range(len(news_feed)):\r\n            clean_news_feed.append(heapq.heappop(news_feed)[1])  # clean news feed from time stamps\r\n        return clean_news_feed[::-1]\r\n\r\n\r\n    def follow(self, followerId: int, followeeId: int) -> None:\r\n        if followerId != followeeId:  # user should not follow itself\r\n            self.user_follows[followerId].add(followeeId)\r\n\r\n\r\n    def unfollow(self, followerId: int, followeeId: int) -> None:\r\n        if followerId in self.user_follows:  # if user has a following list (set)\r\n            self.user_follows[followerId].discard(followeeId)", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-01-29T19:54:12.659Z", "updated_at": "2025-01-29T19:54:12.693Z"}}, {"model": "python_problems.solution", "pk": 464, "fields": {"problem": 242, "language": 1, "owner": 3, "solution": "# O(2^n), O(n)\r\n# backtracking\r\nclass Solution:\r\n    def findDifferentBinaryString(self, numbers: list[str]) -> str:\r\n        permutation = []\r\n        number_set = set(numbers)\r\n\r\n        def dfs(index):\r\n            if index == len(numbers):\r\n                if \"\".join(permutation) in number_set:\r\n                    return\r\n                else:\r\n                    return \"\".join(permutation)\r\n\r\n            for number in \"01\":\r\n                permutation.append(number)\r\n                unique = dfs(index + 1)\r\n                if unique:\r\n                    return unique\r\n                permutation.pop()\r\n\r\n        return dfs(0)", "testcase": "print(Solution().findDifferentBinaryString([\"0\"]), \"1\")\r\nprint(Solution().findDifferentBinaryString([\"01\", \"10\"]), \"11\")\r\nprint(Solution().findDifferentBinaryString([\"00\", \"01\"]), \"11\")\r\nprint(Solution().findDifferentBinaryString([\"111\", \"011\", \"001\"]), \"101\")", "time_complexity": 6, "space_complexity": 2, "created_at": "2025-01-30T00:50:04.974Z", "updated_at": "2025-01-30T00:50:04.998Z"}}, {"model": "python_problems.solution", "pk": 465, "fields": {"problem": 242, "language": 2, "owner": 3, "solution": "/**\r\n * O(2^n), O(n)\r\n * backtracking\r\n * @param {string[]} numbers\r\n * @return {string}\r\n */\r\nvar findDifferentBinaryString = function (numbers) {\r\n  const permutation = [];\r\n  const numberSet = new Set(numbers);\r\n\r\n  var dfs = (index) => {\r\n    if (index == numbers.length) {\r\n      if (numberSet.has(permutation.join('')))\r\n        return\r\n      else\r\n        return permutation.join('')\r\n    }\r\n\r\n    for (const digit of ['0', '1']) {\r\n      permutation.push(digit);\r\n      let unique = dfs(index + 1);\r\n      if (unique)\r\n        return unique\r\n      permutation.pop();\r\n    }\r\n  }\r\n\r\n  return dfs(0)\r\n};", "testcase": "console.log(findDifferentBinaryString(['0']), '1')\r\nconsole.log(findDifferentBinaryString(['01', '10']), '11')\r\nconsole.log(findDifferentBinaryString(['00', '01']), '11')\r\nconsole.log(findDifferentBinaryString(['111', '011', '001']), '101')", "time_complexity": 6, "space_complexity": 2, "created_at": "2025-01-30T01:13:56.713Z", "updated_at": "2025-01-30T01:13:56.736Z"}}, {"model": "python_problems.solution", "pk": 466, "fields": {"problem": 243, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n                 .\r\n             /        \\\r\n            44        444\r\n          /   \\      /    \\\r\n        .     456   .     .\r\n\r\n[4, 4, 4, 5, 6]\r\n[T, F, T, F, F, T]\r\n[1, 1, 1, 2]\r\n[F, F, F, F, T]\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def validPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [False] * (len(numbers) + 1)\r\n        cache[-1] = True\r\n\r\n        for index in reversed(range(len(numbers))):\r\n            # two digit number \r\n            if index + 1 < len(numbers):\r\n                if numbers[index] == numbers[index + 1]:\r\n                    cache[index] = cache[index + 2]\r\n                    if cache[index]:  # if partitions here, no need to check three digit number\r\n                        continue  # early continue\r\n\r\n            # three digit number\r\n            if index + 2 < len(numbers):\r\n                if (numbers[index] == numbers[index + 1] == numbers[index + 2] or\r\n                        numbers[index] + 2 == numbers[index + 1] + 1 == numbers[index + 2]): # -\r\n                    cache[index] = cache[index + 3]\r\n\r\n        return cache[0]\r\n\r\n\r\nclass Solution:\r\n    def validPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(n), O(1)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [True, True, True]\r\n\r\n        for index in reversed(range(len(numbers))):\r\n            cache_0 = False\r\n            \r\n            # two digit number \r\n            if index + 1 < len(numbers):\r\n                if numbers[index] == numbers[index + 1]:\r\n                    cache_0 = cache[1]\r\n                    continue\r\n\r\n            # three digit number\r\n            if index + 2 < len(numbers):\r\n                if (numbers[index] == numbers[index + 1] == numbers[index + 2] or\r\n                        numbers[index] + 2 == numbers[index + 1] + 1 == numbers[index + 2]): # -\r\n                    cache_0 = cache[2]\r\n            \r\n            cache = [cache_0, cache[0], cache[1]]\r\n\r\n        return cache[0]\r\n\r\n\r\nclass Solution:\r\n    def validPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        memo = {len(numbers): True}\r\n\r\n        def dfs(index: int) -> bool:\r\n            if index in memo:\r\n                return memo[index]\r\n            \r\n            can_partition = False\r\n    \r\n            # two digit number\r\n            if index + 1 < len(numbers):\r\n                if numbers[index] == numbers[index + 1]:\r\n                    can_partition = dfs(index + 2)\r\n                    if can_partition:  # if partitions here, no need to check three digit number\r\n                        memo[index] = True\r\n                        return True  # early return\r\n\r\n            # three digit number\r\n            if index + 2 < len(numbers):\r\n                if (numbers[index] == numbers[index + 1] == numbers[index + 2] or\r\n                        numbers[index] + 2 == numbers[index + 1] + 1 == numbers[index + 2]): # -\r\n                    can_partition = can_partition or dfs(index + 3)\r\n\r\n            memo[index] = can_partition\r\n            return memo[index]\r\n        \r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def validPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [None] * (len(numbers) + 1)\r\n        memo[-1] = True\r\n\r\n        def dfs(index: int) -> bool:\r\n            if memo[index]:\r\n                return memo[index]\r\n            elif memo[index] == False:\r\n                return False\r\n            \r\n            can_partition = False\r\n            \r\n            # two digit number\r\n            if index + 1 < len(numbers):\r\n                if numbers[index] == numbers[index + 1]:\r\n                    can_partition = dfs(index + 2)\r\n                    if can_partition:  # if partitions here, no need to check three digit number\r\n                        memo[index] = True\r\n                        return True  # early return\r\n\r\n            # three digit number\r\n            if index + 2 < len(numbers):\r\n                if (numbers[index] == numbers[index + 1] == numbers[index + 2] or\r\n                        numbers[index] + 2 == numbers[index + 1] + 1 == numbers[index + 2]): # -\r\n                    can_partition = can_partition or dfs(index + 3)\r\n\r\n            memo[index] = can_partition\r\n            return memo[index]\r\n        \r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def validPartition(self, numbers: list[int]) -> bool:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        def dfs(index: int) -> bool:\r\n            if index >= len(numbers):\r\n                return index == len(numbers)\r\n            \r\n            can_partition = False\r\n    \r\n            # two digit number\r\n            if index + 1 < len(numbers):\r\n                if numbers[index] == numbers[index + 1]:\r\n                    can_partition = dfs(index + 2)\r\n                    if can_partition:  # if partitions here, no need to check three digit number\r\n                        return True  # early return\r\n\r\n            # three digit number\r\n            if index + 2 < len(numbers):\r\n                if (numbers[index] == numbers[index + 1] == numbers[index + 2] or\r\n                        numbers[index] + 2 == numbers[index + 1] + 1 == numbers[index + 2]): # -\r\n                    can_partition = can_partition or dfs(index + 3)\r\n\r\n            return can_partition\r\n        \r\n        return dfs(0)", "testcase": "print(Solution().validPartition([4, 4, 4, 5, 6]), True)\r\nprint(Solution().validPartition([1, 1, 1, 2]), False)\r\nprint(Solution().validPartition([993335, 993336, 993337, 993338, 993339, 993340, 993341]), False)\r\nprint(Solution().validPartition([803201, 803201, 803201, 803201, 803202, 803203]), True)\r\nprint(Solution().validPartition([67149,67149,67149,67149,67149,136768,136768,136768,136768,136768,136768,136768,136769,136770,136771,136772,136773,136774,136775,136776,136777,136778,136779,136780,136781,136782,136783,136784]), False)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-31T14:33:03.829Z", "updated_at": "2025-02-20T09:21:41.701Z"}}, {"model": "python_problems.solution", "pk": 467, "fields": {"problem": 243, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(1)\r\n * dp, bottom-up, iteration\r\n * @param {number[]} numbers\r\n * @return {boolean}\r\n */\r\nvar validPartition = function (numbers) {\r\n  const cache = [false, true, true];\r\n  \r\n  for (let index = numbers.length - 2; index >= 0; index--) {\r\n    let c0 = false;\r\n    \r\n    if (numbers[index] === numbers[index + 1]\r\n    ) {\r\n      c0 = cache[1];\r\n    }\r\n    if (\r\n      (numbers[index] === numbers[index + 1] &&\r\n        numbers[index + 1] === numbers[index + 2]) ||\r\n      (numbers[index] === numbers[index + 1] - 1 &&\r\n        numbers[index + 1] === numbers[index + 2] - 1)\r\n    ) {\r\n      c0 = c0 || cache[2];\r\n    }\r\n    cache[2] = cache[1];\r\n    cache[1] = cache[0];\r\n    cache[0] = c0;\r\n  }\r\n\r\n  return cache[0]\r\n};\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * dp, bottom-up, iteration\r\n * @param {number[]} numbers\r\n * @return {boolean}\r\n */\r\nvar validPartition = function (numbers) {\r\n  const cache = Array(numbers.length + 1).fill(false);\r\n  cache[numbers.length] = true;\r\n\r\n  for (let index = numbers.length - 2; index >= 0; index--) {\r\n    if (numbers[index] === numbers[index + 1]\r\n    ) {\r\n      cache[index] = cache[index + 2];\r\n    }\r\n    if (\r\n      (numbers[index] === numbers[index + 1] &&\r\n        numbers[index + 1] === numbers[index + 2]) ||\r\n      (numbers[index] === numbers[index + 1] - 1 &&\r\n        numbers[index + 1] === numbers[index + 2] - 1)\r\n    ) {\r\n      cache[index] = cache[index] || cache[index + 3];\r\n    }\r\n  }\r\n\r\n  return cache[0]\r\n};\r\n\r\n\r\n/**\r\n * O(n), O(n)\r\n * dp, top-down with memoization\r\n * @param {number[]} numbers\r\n * @return {boolean}\r\n */\r\nvar validPartition = function (numbers) {\r\n  const memo = new Map();\r\n\r\n  var dfs = (index) => {\r\n    if (index === numbers.length)\r\n      return true\r\n    else if (memo.has(index))\r\n      return memo.get(index)\r\n\r\n    let isPartitioned = false\r\n    if (\r\n      index < numbers.length - 1 &&\r\n      numbers[index] === numbers[index + 1]\r\n    ) {\r\n      isPartitioned = dfs(index + 2)\r\n    }\r\n\r\n    if (index < numbers.length - 2)\r\n      if (\r\n        (numbers[index] === numbers[index + 1] &&\r\n          numbers[index + 1] === numbers[index + 2]) ||\r\n        ((numbers[index] + 1 === numbers[index + 1] && \r\n          numbers[index + 1] + 1 === numbers[index + 2]))\r\n      ) {\r\n        isPartitioned = isPartitioned || dfs(index + 3)\r\n      }\r\n      \r\n    memo.set(index, isPartitioned)\r\n    return isPartitioned\r\n  }\r\n\r\n  return dfs(0)\r\n};\r\n\r\n\r\n/**\r\n * O(2^n), O(n)\r\n * brute force, recursion, tle\r\n * @param {number[]} numbers\r\n * @return {boolean}\r\n */\r\nvar validPartition = function (numbers) {\r\n  var dfs = (index) => {\r\n    if (index === numbers.length)\r\n      return true\r\n\r\n    if (\r\n      index < numbers.length - 1 &&\r\n      numbers[index] === numbers[index + 1]\r\n    ) {\r\n      if (dfs(index + 2))\r\n        return true\r\n    }\r\n\r\n    if (index < numbers.length - 2)\r\n      if (\r\n        (numbers[index] === numbers[index + 1] &&\r\n          numbers[index + 1] === numbers[index + 2]) ||\r\n        (numbers[index] === numbers[index + 1] - 1 &&\r\n          numbers[index + 1] === numbers[index + 2] - 1)\r\n      ) {\r\n        if (dfs(index + 3))\r\n          return true\r\n      }\r\n    \r\n    return false\r\n  }\r\n\r\n  return dfs(0)\r\n};", "testcase": "console.log(validPartition([4, 4, 4, 5, 6]), true)\r\nconsole.log(validPartition([1, 1, 1, 2]), false)\r\nconsole.log(validPartition([993335, 993336, 993337, 993338, 993339, 993340, 993341]), false)", "time_complexity": 2, "space_complexity": 1, "created_at": "2025-01-31T14:33:47.200Z", "updated_at": "2025-01-31T16:24:13.185Z"}}, {"model": "python_problems.solution", "pk": 468, "fields": {"problem": 244, "language": 1, "owner": 3, "solution": "# O(n2), O(n)\r\n# tle\r\nclass Solution:\r\n    def minOperations(self, numbers: list[int]) -> int:\r\n        number_set = set(numbers)\r\n        numbers.sort()\r\n        min_difference = len(numbers)\r\n\r\n\r\n        for number in number_set:  # check every unique number\r\n            difference = 0  # number of dffferences for current number\r\n            \r\n            for j in range(1, len(numbers)):  # check every distance starting from `1`\r\n                difference += number + j not in number_set  # increase difference if no distance from current number found\r\n            \r\n            min_difference = min(min_difference, difference)  # update max distance\r\n        \r\n        return min_difference", "testcase": "print(Solution().minOperations([4, 2, 5, 3]), 0)\r\nprint(Solution().minOperations([1, 2, 3, 5, 6]), 1)\r\nprint(Solution().minOperations([1, 10, 100, 1000]), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-02-06T23:38:03.791Z", "updated_at": "2025-02-06T23:38:03.814Z"}}, {"model": "python_problems.solution", "pk": 469, "fields": {"problem": 244, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(n)\r\n * tle\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar minOperations = function(numbers) {\r\n  const numberSet = new Set(numbers);\r\n  let difference;\r\n  minDifference = numbers.length;\r\n\r\n  for (const number of numberSet) {\r\n    difference = 0;\r\n\r\n    for (let index = 1; index < numbers.length; index++)\r\n    {\r\n      difference += !numberSet.has(number + index);\r\n    }\r\n\r\n    minDifference = Math.min(minDifference, difference);\r\n  }\r\n\r\n  return minDifference\r\n}", "testcase": "console.log(minOperations([4, 2, 5, 3]), 0)\r\nconsole.log(minOperations([1, 2, 3, 5, 6]), 1)\r\nconsole.log(minOperations([1, 10, 100, 1000]), 3)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-02-07T00:00:13.763Z", "updated_at": "2025-02-07T00:00:13.782Z"}}, {"model": "python_problems.solution", "pk": 470, "fields": {"problem": 245, "language": 1, "owner": 3, "solution": "# O(1), O(1)\r\n# Design, Array, String, Iterator\r\n# generator\r\nclass StringIterator:\r\n    def __init__(self, compressed_string: str):\r\n        self.generator = self._generate(compressed_string)\r\n        self.letter = next(self.generator, \" \")  # Preload the first letter\r\n\r\n    def _generate(self, compressed_string):\r\n        index = 0\r\n        \r\n        while index < len(compressed_string):\r\n            letter = compressed_string[index]\r\n            index += 1\r\n            frequency = 0\r\n            \r\n            # Parse the number representing the letter frequency\r\n            while (index < len(compressed_string) and \r\n                   compressed_string[index].isdigit()):\r\n                frequency = 10 * frequency + int(compressed_string[index])\r\n                index += 1\r\n            \r\n            # Yield the letter `frequency` times\r\n            for _ in range(frequency):\r\n                yield letter\r\n        \r\n    def next(self) -> str:\r\n        current_letter = self.letter\r\n        self.letter = next(self.generator, \" \")\r\n        return current_letter\r\n\r\n    def hasNext(self) -> bool:\r\n        return self.letter != \" \"\r\n\r\n\r\n# O(n): constructor; O(1): next, hasNext; aux space O(n)\r\n# Design, Array, String, Iterator\r\n# compressed string coppied to self.text in constructor\r\nclass StringIterator:\r\n    def __init__(self, text: str):\r\n        self.text = text\r\n        self.index = 0\r\n        self.letter = \"\"\r\n        self.letter_frequency = []\r\n        \r\n    def _get_next_letter(self):\r\n        \"\"\"\r\n        Method to get next letter and its frequency. Its called when current\r\n        letter frequency reaches zero.\r\n        \"\"\"\r\n        if self.index == len(self.text):\r\n            self.letter = \" \"\r\n            self.letter_frequency = 0\r\n            return\r\n        \r\n        self.letter = self.text[self.index]\r\n        self.index += 1\r\n        number = 0\r\n\r\n        while (self.index < len(self.text) and\r\n               self.text[self.index].isdigit()):\r\n            number = 10 * number + int(self.text[self.index])\r\n            self.index += 1\r\n        \r\n        self.letter_frequency = number\r\n\r\n    def next(self):\r\n        if not self.letter_frequency:\r\n            self._get_next_letter()\r\n        \r\n        if self.letter_frequency:\r\n            self.letter_frequency -= 1\r\n            return self.letter\r\n        \r\n        return \" \"\r\n\r\n        # if self.index == len(self.text):\r\n        #     return \" \"\r\n        # elif self.letter_frequency:\r\n        #     self.letter_frequency -= 1\r\n        #     return self.letter\r\n        # else:\r\n        #     self._get_next_letter()\r\n        #     self.letter_frequency -= 1\r\n        #     return self.letter\r\n\r\n    def hasNext(self):\r\n        return (self.index < len(self.text) or\r\n                self.letter_frequency > 0)\r\n\r\n\r\n# O(n): constructor; O(1): next, hasNext; aux space O(n)\r\n# Design, Array, String, Iterator\r\n# compressed string processed in constructor\r\nclass StringIterator:\r\n    def __init__(self, text: str):\r\n        self.index = 0\r\n        self.text = []\r\n        self.str_to_list(text)\r\n        \r\n    def str_to_list(self, text):\r\n        frequency = 0\r\n        for char in text:\r\n            if char.isalpha():\r\n                if frequency:\r\n                    self.text.append(frequency)\r\n                    frequency = 0\r\n                self.text.append(char)\r\n            elif char.isnumeric():\r\n                frequency = frequency * 10 + int(char)\r\n        self.text.append(frequency)\r\n\r\n    def next(self):\r\n        if not self.hasNext():\r\n            return \" \"\r\n        \r\n        letter = self.text[self.index]  # a letter to return\r\n        self.text[self.index + 1] -= 1  # decrease a letter frequency\r\n        if not self.text[self.index + 1]:  # if all letter occurences used\r\n            self.index += 2  # update index (list pointer)        \r\n        return letter\r\n\r\n    def hasNext(self):\r\n        return self.index < len(self.text)\r\n\r\n\r\niterator = StringIterator(\"L1e2t1C1o1d1e1\")\r\nprint(iterator.next())  # return \"L\"\r\nprint(iterator.next())  # return \"e\"\r\nprint(iterator.next())  # return \"e\"\r\nprint(iterator.next())  # return \"t\"\r\nprint(iterator.next())  # return \"C\"\r\nprint(iterator.next())  # return \"o\"\r\nprint(iterator.next())  # return \"d\"\r\nprint(iterator.hasNext())  # return True\r\nprint(iterator.next())  # return \"e\"\r\nprint(iterator.hasNext())  # return False\r\nprint(iterator.next())  # return \" \"", "testcase": "", "time_complexity": 1, "space_complexity": 1, "created_at": "2025-02-13T03:40:34.403Z", "updated_at": "2025-02-14T07:08:56.466Z"}}, {"model": "python_problems.solution", "pk": 471, "fields": {"problem": 245, "language": 2, "owner": 3, "solution": "/**\r\n * O(1), O(1)\r\n * Design, Array, String, Iterator\r\n * generator\r\n */\r\n\r\nclass StringIterator {\r\n  constructor(compressedString) {\r\n    this.generator = this.generate(compressedString);\r\n    this.letter = this._getNextLetter();\r\n  }\r\n\r\n  *generate(compressedString) {\r\n    let index = 0;\r\n\r\n    while (index < compressedString.length) {\r\n      let letter = compressedString[index];\r\n      index++;\r\n      let frequency = 0;\r\n\r\n      while (\r\n        index < compressedString.length &&\r\n        /\\d/.test(compressedString[index])\r\n      ) {\r\n        frequency = 10 * frequency + Number(compressedString[index]);\r\n        index++;\r\n      }\r\n\r\n      for (let f = 0; f < frequency; f++) {\r\n        yield letter;\r\n      }\r\n    }\r\n  }\r\n\r\n  _getNextLetter() {\r\n    const { value, done } = this.generator.next();\r\n    return done ? ' ' : value;\r\n  }\r\n\r\n  next() {\r\n    const currentLetter = this.letter;\r\n    this.letter = this._getNextLetter();\r\n    return currentLetter;\r\n  }\r\n\r\n  hasNext() {\r\n    return this.letter !== ' ';\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * O(n): constructor; O(1): next, hasNext; aux space O(n)\r\n * Design, Array, String, Iterator\r\n */\r\nclass StringIterator {\r\n  constructor(text) {\r\n    this.index = 0;\r\n    this.text = [];\r\n    this.strToList(text);\r\n  };\r\n\r\n  /**\r\n   * @param {string} text\r\n   * @return {}\r\n   */\r\n  strToList(text) {\r\n    let frequency = 0;\r\n    for (const char of text) {\r\n      if (char.match(/[A-Za-z]/)) {\r\n        if (frequency) {\r\n          this.text.push(frequency);\r\n          frequency = 0;\r\n        }\r\n        this.text.push(char);\r\n      } else if (char.match(/\\d/)) {\r\n        frequency = 10 * frequency + Number(char);\r\n      }\r\n    }\r\n    this.text.push(frequency)\r\n  };\r\n\r\n  /**\r\n   * @param {}\r\n   * @return {string}\r\n   */\r\n  next() {\r\n    if (!this.hasNext())\r\n      return ' '\r\n\r\n    const letter = this.text[this.index];\r\n    this.text[this.index + 1] -= 1;\r\n    if (!this.text[this.index + 1])\r\n      this.index += 2;\r\n    return letter\r\n  };\r\n\r\n  /**\r\n   * @param {}\r\n   * @return {boolean}\r\n   */\r\n  hasNext() {\r\n    return this.index < this.text.length\r\n  };\r\n}\r\n\r\n\r\nconst iterator = new StringIterator('L1e2t1C1o1d1e1')\r\nconsole.log(iterator.next())  // return 'L'\r\nconsole.log(iterator.next())  // return 'e'\r\nconsole.log(iterator.next())  // return 'e'\r\nconsole.log(iterator.next())  // return 't'\r\nconsole.log(iterator.next())  // return 'C'\r\nconsole.log(iterator.next())  // return 'o'\r\nconsole.log(iterator.next())  // return 'd'\r\nconsole.log(iterator.hasNext())  // return True\r\nconsole.log(iterator.next())  // return 'e'\r\nconsole.log(iterator.hasNext())  // return False\r\nconsole.log(iterator.next())  // return ' '", "testcase": "", "time_complexity": 1, "space_complexity": 1, "created_at": "2025-02-13T03:41:43.257Z", "updated_at": "2025-02-14T09:32:14.206Z"}}, {"model": "python_problems.solution", "pk": 472, "fields": {"problem": 246, "language": 1, "owner": 3, "solution": "# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n\r\n\r\n# Your BSTIterator object will be instantiated and called as such:\r\n# obj = BSTIterator(root)\r\n# param_1 = obj.next()\r\n# param_2 = obj.hasNext()\r\n\r\n\r\n# O(n): constructor; O(1): next, hasNext; aux space O(n)\r\nclass BSTIterator:\r\n    def __init__(self, root: Optional[TreeNode]):\r\n        self.node_list = []\r\n        self.tree_to_queue(root)\r\n        self.index = 0\r\n    \r\n    def tree_to_queue(self, node):\r\n        if not node:\r\n            return\r\n        \r\n        self.tree_to_queue(node.left)\r\n        self.node_list.append(node.val)\r\n        self.tree_to_queue(node.right)\r\n            \r\n    def next(self) -> int:\r\n        self.index += 1\r\n        return self.node_list[self.index - 1]\r\n\r\n    def hasNext(self) -> bool:\r\n        return self.index < len(self.node_list)\r\n\r\n\r\n# O(n): constructor; O(1): next, hasNext; aux space O(n)\r\nclass BSTIterator:\r\n    def __init__(self, root: Optional[TreeNode]):\r\n        self.node_list = self.tree_to_queue(root)\r\n        self.index = 0\r\n    \r\n    def tree_to_queue(self, node):\r\n        if not node:\r\n            return []\r\n\r\n        return (self.tree_to_queue(node.left) + \r\n                [node.val] + \r\n                self.tree_to_queue(node.right))\r\n            \r\n    def next(self) -> int:\r\n        self.index += 1\r\n        return self.node_list[self.index - 1]\r\n\r\n    def hasNext(self) -> bool:\r\n        return self.index < len(self.node_list)", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-14T10:41:24.419Z", "updated_at": "2025-02-14T10:41:24.442Z"}}, {"model": "python_problems.solution", "pk": 473, "fields": {"problem": 246, "language": 2, "owner": 3, "solution": "/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n\r\n/** \r\n * Your BSTIterator object will be instantiated and called as such:\r\n * var obj = new BSTIterator(root)\r\n * var param_1 = obj.next()\r\n * var param_2 = obj.hasNext()\r\n */\r\n\r\n\r\n/**\r\n * O(n): constructor; O(1): next, hasNext; aux space O(n)\r\n * @param {TreeNode} root\r\n */\r\nvar BSTIterator = function(root) {\r\n  this.nodes = [];\r\n  this.treeToList(root);\r\n  this.index = 0;\r\n};\r\n\r\nBSTIterator.prototype.treeToList = function(node) {\r\n  if (!node)\r\n    return\r\n\r\n  this.treeToList(node.left);\r\n  this.nodes.push(node.val)\r\n  this.treeToList(node.right);\r\n}\r\n\r\n/**\r\n * @return {number}\r\n */\r\nBSTIterator.prototype.next = function() {\r\n  val = this.nodes[this.index];\r\n  this.index += 1\r\n  return val\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nBSTIterator.prototype.hasNext = function() {\r\n  return this.index < this.nodes.length\r\n};", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-14T10:42:28.530Z", "updated_at": "2025-02-14T10:42:28.552Z"}}, {"model": "python_problems.solution", "pk": 474, "fields": {"problem": 247, "language": 1, "owner": 3, "solution": "# Your FreqStack object will be instantiated and called as such:\r\n# obj = FreqStack()\r\n# obj.push(val)\r\n# param_2 = obj.pop()\r\n\r\n\r\n# O(1): push O(n): pop; aux space O(n)\r\n# brute force\r\nclass FreqStack:\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.counter = {}\r\n\r\n    def push(self, val: int) -> None:\r\n        self.stack.append(val)\r\n        self.counter[val] = self.counter.get(val, 0) + 1\r\n\r\n    def pop(self) -> int:\r\n        max_frequency = max(self.counter.values())\r\n        reversed_stack = []\r\n\r\n        while (self.stack and\r\n               self.counter[self.stack[-1]] != max_frequency):\r\n            reversed_stack.append(self.stack.pop())\r\n\r\n        most_frequent = self.stack.pop()\r\n        self.counter[most_frequent] -= 1\r\n\r\n        while reversed_stack:\r\n            self.stack.append(reversed_stack.pop())\r\n\r\n        return most_frequent\r\n\r\n\r\nimport heapq\r\n\r\n# O(logn), O(n)\r\n# heap\r\nclass FreqStack:\r\n    def __init__(self):\r\n        self.stack = []  # [((-frequency, -index), value), ]\r\n        self.counter = {}\r\n        self.index = 0\r\n\r\n    def push(self, val: int) -> None:\r\n        self.counter[val] = self.counter.get(val, 0) + 1\r\n        heapq.heappush(self.stack, ((-self.counter[val], -self.index), val))\r\n        self.index += 1\r\n\r\n    def pop(self) -> int:\r\n        val = heapq.heappop(self.stack)[1]\r\n        self.counter[val] -= 1\r\n        return val\r\n\r\n\r\n# O(n), O(n)\r\n# 2 hash maps\r\nclass FreqStack:\r\n    def __init__(self):\r\n        self.counter = {}  # {value: frequency, }\r\n        self.bucket = {}  # {frequency: [value1, value2, ], }\r\n        self.max_frequency = 0\r\n\r\n    def push(self, val: int) -> None:\r\n        self.counter[val] = self.counter.get(val, 0) + 1\r\n        self.max_frequency = max(self.max_frequency, self.counter[val])\r\n        if self.max_frequency not in self.bucket:\r\n            self.bucket[self.max_frequency] = []\r\n        self.bucket[self.counter[val]].append(val)\r\n\r\n    def pop(self) -> int:\r\n        val = self.bucket[self.max_frequency].pop()\r\n        self.counter[val] -= 1\r\n        if not self.bucket[self.max_frequency]:\r\n            self.max_frequency -= 1\r\n        return val\r\n\r\n\r\nfrom collections import deque\r\n\r\n# O(n), O(n)\r\n# 2 hash maps, deque\r\nclass FreqStack:\r\n    def __init__(self):\r\n        self.counter = {}  # {value: frequency, }\r\n        self.bucket = {}  # {frequency: deque(value1, value2, ), }\r\n        self.max_frequency = 0\r\n\r\n    def push(self, val: int) -> None:\r\n        self.counter[val] = self.counter.get(val, 0) + 1\r\n        self.max_frequency = max(self.max_frequency, self.counter[val])\r\n        if self.max_frequency not in self.bucket:\r\n            self.bucket[self.max_frequency] = deque()\r\n        self.bucket[self.counter[val]].append(val)\r\n\r\n    def pop(self) -> int:\r\n        val = self.bucket[self.max_frequency].pop()\r\n        self.counter[val] -= 1\r\n        if not self.bucket[self.max_frequency]:\r\n            self.max_frequency -= 1\r\n        return val\r\n\r\n\r\nfrom collections import defaultdict\r\n\r\n# O(n), O(n)\r\n# 2 default hash maps\r\nclass FreqStack:\r\n    def __init__(self):\r\n        self.counter = defaultdict(int)  # {value: frequency, }\r\n        self.bucket = defaultdict(list)  # {frequency: [value1, value2, ], }\r\n        self.max_frequency = 0\r\n\r\n    def push(self, val: int) -> None:\r\n        self.counter[val] += 1\r\n        self.max_frequency = max(self.max_frequency, self.counter[val])\r\n        self.bucket[self.counter[val]].append(val)\r\n\r\n    def pop(self) -> int:\r\n        val = self.bucket[self.max_frequency].pop()\r\n        self.counter[val] -= 1\r\n        if not self.bucket[self.max_frequency]:\r\n            self.max_frequency -= 1\r\n        return val\r\n\r\n\r\nfrom collections import defaultdict, deque\r\n\r\n# O(n), O(n)\r\n# 2 default hash maps, deque\r\nclass FreqStack:\r\n    def __init__(self):\r\n        self.counter = defaultdict(int)  # {value: frequency, }\r\n        self.bucket = defaultdict(deque)  # {frequency: deque(value1, value2, ), }\r\n        self.max_frequency = 0\r\n\r\n    def push(self, val: int) -> None:\r\n        self.counter[val] += 1\r\n        self.max_frequency = max(self.max_frequency, self.counter[val])\r\n        self.bucket[self.counter[val]].append(val)\r\n\r\n    def pop(self) -> int:\r\n        val = self.bucket[self.max_frequency].pop()\r\n        self.counter[val] -= 1\r\n        if not self.bucket[self.max_frequency]:\r\n            self.max_frequency -= 1\r\n        return val\r\n\r\n\r\nfreqStack = FreqStack()\r\nprint(freqStack.push(5))  # The stack is [5]\r\nprint(freqStack.push(7))  # The stack is [5,7]\r\nprint(freqStack.push(5))  # The stack is [5,7,5]\r\nprint(freqStack.push(7))  # The stack is [5,7,5,7]\r\nprint(freqStack.push(4))  # The stack is [5,7,5,7,4]\r\nprint(freqStack.push(5))  # The stack is [5,7,5,7,4,5]\r\nprint(freqStack.pop())  # return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\r\nprint(freqStack.pop())  # return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\r\nprint(freqStack.pop())  # return 5, as 5 is the most frequent. The stack becomes [5,7,4].\r\nprint(freqStack.pop())  # return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\r\n\r\n\r\ndef test_input(operations: list[str], arguments: list[list[int | None]]) -> list[list[int] | None]:\r\n    result = []\r\n\r\n    for operation, argument in zip(operations, arguments):\r\n        if operation == \"FreqStack\":\r\n            freqStack = FreqStack()\r\n            result.append(None)\r\n        elif operation == \"push\":\r\n            freqStack.push(*argument)\r\n            result.append(None)\r\n        elif operation == \"pop\":\r\n            result.append(freqStack.pop())\r\n    \r\n    return result\r\n\r\n# Example Input\r\noperations = [\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\r\narguments = [[], [5], [7], [5], [7], [4], [5], [], [], [], []]\r\nexpected_output = [None, None, None, None, None, None, None, 5, 7, 5, 4]\r\n\r\noperations = [\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"pop\", \"pop\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\"]\r\narguments = [[],[1], [1], [1], [2], [], [], [2], [2], [1], [], [], []]\r\nexpected_output = [None, None, None, None, None, 1, 1, None, None, None, 2, 1, 2]\r\n\r\n# Run tests\r\ntest_output = test_input(operations, arguments)\r\nprint(test_output == expected_output)\r\nprint(test_output)", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-15T08:17:10.412Z", "updated_at": "2025-02-15T08:17:10.444Z"}}, {"model": "python_problems.solution", "pk": 475, "fields": {"problem": 247, "language": 2, "owner": 3, "solution": "/** \r\n * Your FreqStack object will be instantiated and called as such:\r\n * var obj = new FreqStack()\r\n * obj.push(val)\r\n * var param_2 = obj.pop()\r\n */\r\n\r\n\r\n/** \r\n * O(n), O(n)\r\n * 2 hash maps\r\n */\r\nvar FreqStack = function () {\r\n  this.counter = new Map();\r\n  this.bucket = new Map();\r\n  this.maxFrequency = 0;\r\n};\r\n\r\n/** \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nFreqStack.prototype.push = function (val) {\r\n  this.counter.set(val, (this.counter.get(val) || 0) + 1);\r\n  this.maxFrequency = Math.max(this.maxFrequency, this.counter.get(val));\r\n  \r\n  if (!this.bucket.has(this.counter.get(val))) {\r\n    this.bucket.set(this.counter.get(val), []);\r\n  }\r\n  this.bucket.get(this.counter.get(val)).push(val);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nFreqStack.prototype.pop = function () {\r\n  const val = this.bucket.get(this.maxFrequency).pop();\r\n  this.counter.set(val, this.counter.get(val) - 1);\r\n  \r\n  if (this.bucket.get(this.maxFrequency).length === 0)\r\n    this.maxFrequency--;\r\n  \r\n  return val\r\n};\r\n\r\n\r\n// const freqStack = new FreqStack()\r\n// console.log(freqStack.push(5))  // The stack is [5]\r\n// console.log(freqStack.push(7))  // The stack is [5,7]\r\n// console.log(freqStack.push(5))  // The stack is [5,7,5]\r\n// console.log(freqStack.push(7))  // The stack is [5,7,5,7]\r\n// console.log(freqStack.push(4))  // The stack is [5,7,5,7,4]\r\n// console.log(freqStack.push(5))  // The stack is [5,7,5,7,4,5]\r\n// console.log(freqStack.pop())  // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\r\n// console.log(freqStack.pop())  // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\r\n// console.log(freqStack.pop())  // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\r\n// console.log(freqStack.pop())  // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\r\n\r\n\r\n/** \r\n * @param {string[]} operations\r\n * @param {number[][]} args\r\n * @return {number[][]}\r\n */\r\nvar test_input = function (operations, args) {\r\n  const result = []\r\n  const freqStack = new FreqStack();\r\n\r\n  for (let index = 0; index < operations.length; index++) {\r\n    const operation = operations[index];\r\n    const argument = args[index];\r\n\r\n    if (operation === 'FreqStack') {\r\n      result.push(null);\r\n    } else if (operation === 'push') {\r\n      freqStack.push(...argument);\r\n      result.push(null);\r\n    } else if (operation === 'pop') {\r\n      result.push(freqStack.pop());\r\n    } \r\n  }\r\n\r\n  return result\r\n}\r\n\r\n// Example Input\r\nconst operations = ['FreqStack', 'push', 'push', 'push', 'push', 'push', 'push', 'pop', 'pop', 'pop', 'pop']\r\nconst args = [[], [5], [7], [5], [7], [4], [5], [], [], [], []]\r\nconst expected_output = [null, null, null, null, null, null, null, 5, 7, 5, 4]\r\n\r\n// const operations = ['FreqStack','push','push','push','push','pop', 'pop', 'push', 'push', 'push', 'pop', 'pop', 'pop']\r\n// const args = [[],[1], [1], [1], [2], [], [], [2], [2], [1], [], [], []]\r\n// const expected_output = [null, null, null, null, null, 1, 1, null, null, null, 2, 1, 2]\r\n\r\n// Run tests\r\nconst test_output = test_input(operations, args)\r\nconsole.log(JSON.stringify(test_output) === JSON.stringify(expected_output))\r\nconsole.log(test_output)", "testcase": "", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-15T08:49:45.023Z", "updated_at": "2025-02-15T08:51:32.524Z"}}, {"model": "python_problems.solution", "pk": 476, "fields": {"problem": 248, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\r\n        \"\"\"\r\n        O(3^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        def dfs(day_index):\r\n            if day_index >= len(days):\r\n                return 0\r\n            \r\n            min_cost = float(\"inf\")\r\n\r\n            for cost, validity in zip(costs, (1, 7, 30)):\r\n                ticket_index = 0\r\n                \r\n                while (day_index + ticket_index < len(days) and\r\n                       days[day_index + ticket_index] < days[day_index] + validity):\r\n                    ticket_index += 1\r\n                \r\n                min_cost = min(min_cost, cost + dfs(day_index + ticket_index))\r\n\r\n            return min_cost\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        memo = {}  # {day_index: cost} minimum cost to travel from day index pointing day onwards\r\n\r\n        def dfs(day_index):\r\n            if day_index >= len(days):\r\n                return 0\r\n            elif day_index in memo:\r\n                return memo[day_index]\r\n            \r\n            min_cost = float(\"inf\")\r\n\r\n            for cost, validity in zip(costs, (1, 7, 30)):\r\n                ticket_index = 0\r\n                \r\n                while (day_index + ticket_index < len(days) and\r\n                       days[day_index + ticket_index] < days[day_index] + validity):\r\n                    ticket_index += 1\r\n                \r\n                min_cost = min(min_cost, cost + dfs(day_index + ticket_index))\r\n\r\n            memo[day_index] = min_cost\r\n            return min_cost\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [None] * len(days)  # {day_index: cost} minimum cost to travel from day index pointing day onwards\r\n\r\n        def dfs(day_index):\r\n            if day_index >= len(days):\r\n                return 0\r\n            elif memo[day_index] is not None:\r\n                return memo[day_index]\r\n            \r\n            min_cost = float(\"inf\")\r\n\r\n            for cost, validity in zip(costs, (1, 7, 30)):\r\n                ticket_index = 0\r\n                \r\n                while (day_index + ticket_index < len(days) and\r\n                       days[day_index + ticket_index] < days[day_index] + validity):\r\n                    ticket_index += 1\r\n                \r\n                min_cost = min(min_cost, cost + dfs(day_index + ticket_index))\r\n\r\n            memo[day_index] = min_cost\r\n            return min_cost\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [float(\"inf\")] * (len(days) + 0)  # {day_index: cost} minimum cost to travel from day index pointing day onwards\r\n        # cache = \r\n\r\n        for day_index, day in enumerate(days):\r\n            for cost, validity in zip(costs, (1, 7, 30)):\r\n                ticket_index = 0\r\n                \r\n                while (day_index + ticket_index < len(days) and\r\n                       days[day_index + ticket_index] < days[day_index] + validity):\r\n                    ticket_index += 1\r\n                \r\n                cache[day_index] = min(cache[day_index], \r\n                                       cost + cache[day_index + ticket_index])\r\n\r\n            \r\n            # if day_index >= len(days):\r\n            #     return 0\r\n            # elif cache[day_index] is not None:\r\n            #     return cache[day_index]\r\n            \r\n\r\n        return cache", "testcase": "print(Solution().mincostTickets([5], [2, 7, 15]), 2)\r\nprint(Solution().mincostTickets([1, 4, 6, 7, 8, 20], [2, 7, 15]), 11)\r\nprint(Solution().mincostTickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 7, 15]), 17)\r\nprint(Solution().mincostTickets([1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,20,21,24,25,27,28,29,30,31,34,37,38,39,41,43,44,45,47,48,49,54,57,60,62,63,66,69,70,72,74,76,78,80,81,82,83,84,85,88,89,91,93,94,97,99], [9,38,134]), 423)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-21T07:23:19.933Z", "updated_at": "2025-02-21T07:23:19.955Z"}}, {"model": "python_problems.solution", "pk": 477, "fields": {"problem": 248, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * dp, top-down with memoization as hash map\r\n * @param {number[]} days\r\n * @param {number[]} costs\r\n * @return {number}\r\n */\r\nvar mincostTickets = function (days, costs) {\r\n  const memo = new Map();\r\n  const validities = [1, 7, 30];\r\n\r\n  var dfs = (dayIndex) => {\r\n    if (dayIndex >= days.length) {\r\n      return 0\r\n    } else if (memo.has(dayIndex)) {\r\n      return memo.get(dayIndex)\r\n    }\r\n\r\n    let minCost = Infinity;\r\n\r\n    for (let option = 0; option < costs.length; option++) {\r\n      const cost = costs[option];\r\n      const validity = validities[option];\r\n      let ticketIndex = 0;\r\n\r\n      while (\r\n        dayIndex + ticketIndex < days.length &&\r\n        days[dayIndex + ticketIndex] < days[dayIndex] + validity\r\n      ) {\r\n        ticketIndex++;\r\n      }\r\n\r\n      minCost = Math.min(minCost, cost + dfs(dayIndex + ticketIndex));\r\n    }\r\n\r\n    memo.set(dayIndex, minCost);\r\n    return minCost\r\n  }\r\n\r\n  return dfs(0)\r\n};", "testcase": "console.log(mincostTickets([5], [2, 7, 15]), 2)\r\nconsole.log(mincostTickets([1, 4, 6, 7, 8, 20], [2, 7, 15]), 11)\r\nconsole.log(mincostTickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 7, 15]), 17)\r\nconsole.log(mincostTickets([1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,20,21,24,25,27,28,29,30,31,34,37,38,39,41,43,44,45,47,48,49,54,57,60,62,63,66,69,70,72,74,76,78,80,81,82,83,84,85,88,89,91,93,94,97,99], [9,38,134]), 423)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-21T07:38:32.342Z", "updated_at": "2025-02-21T07:38:32.365Z"}}, {"model": "python_problems.solution", "pk": 478, "fields": {"problem": 249, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n                        4\r\n                  1/            2|           3\\  \r\n                  3              2            1\r\n               1/     2\\        1/ \\2        1|\r\n              2       1        1     0        0\r\n           1/  \\2    1|       1|\r\n           1    0     1        0\r\n          1|\r\n           0\r\n\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def integerBreak(self, n: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        memo = {0: 1}  # {number: product}  maximum product for current number\r\n\r\n        def dfs(index: int, is_first: bool) -> int:\r\n            if index in memo:\r\n                return memo[index]\r\n            \r\n            memo[index] = max(number * dfs(index - number, False) \r\n                              for number \r\n                              in range(1, index + bool(not is_first)))  # bool is `1` excep of the first loop\r\n            return memo[index]\r\n\r\n        return dfs(n, True)\r\n\r\n\r\nclass Solution:\r\n    def integerBreak(self, n: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [None] * (n + 1)  # maximum product for current number (index)\r\n        memo[0] = 1\r\n\r\n        def dfs(index: int, is_first: bool) -> int:\r\n            if memo[index] is not None:\r\n                return memo[index]\r\n            \r\n            memo[index] = max(number * dfs(index - number, False) \r\n                              for number \r\n                              in range(1, index + bool(not is_first)))  # bool is `1` excep of the first loop\r\n            return memo[index]\r\n\r\n        return dfs(n, True)\r\n\r\n\r\nclass Solution:\r\n    def integerBreak(self, n: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        def dfs(index: int, is_first: bool) -> int:\r\n            if index == 0:\r\n                return 1\r\n            \r\n            max_number = 0\r\n\r\n            for number in range(1, index + bool(not is_first)):  # bool is `1` excep of the first loop\r\n                max_number = max(max_number, \r\n                                 number * dfs(index - number, False))\r\n\r\n            return max_number\r\n\r\n        return dfs(n, True)\r\n\r\n\r\nclass Solution:\r\n    def integerBreak(self, n: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, backtracking, tle\r\n        \"\"\"\r\n        integers = []\r\n        max_product = 0\r\n\r\n        def product():\r\n            p = 1\r\n            for number in integers:\r\n                p *= number\r\n            return p\r\n\r\n        def dfs(n, max_product):\r\n            if (n == 0 and\r\n                    len(integers) > 1):\r\n                max_product = max(max_product, product())\r\n                return max_product\r\n\r\n            for index in range(1, n + 1):\r\n                integers.append(index)\r\n                max_product = dfs(n - index, max_product)\r\n                integers.pop()\r\n            \r\n            return max_product\r\n\r\n        return dfs(n, max_product)\r\n\r\n\r\nclass Solution:\r\n    def integerBreak(self, n: int) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [None] * (n + 1)  # maximum product for current number (index)\r\n        cache[0] = 1\r\n\r\n        for index in range(2, n + 1):\r\n            # if cache[index] is not None:\r\n            #     return cache[index]\r\n            \r\n            cache[index] = max(number * cache[index - number, False]\r\n                              for number \r\n                              in range(1, index + bool(not is_first)))  # bool is `1` excep of the first loop\r\n            return cache[index]\r\n\r\n        return cache", "testcase": "print(Solution().integerBreak(2), 1)  # Explanation: 2 = 1 + 1, 1  1 = 1.\r\nprint(Solution().integerBreak(3), 2)  # Explanation: 3 = 1 + 2, 1  2 = 2.\r\nprint(Solution().integerBreak(4), 4)  # Explanation: 4 = 2 + 2, 2  2 = 4.\r\nprint(Solution().integerBreak(5), 6)  # Explanation: 5 = 2 + 3, 2  3 = 6.\r\nprint(Solution().integerBreak(6), 9)  # Explanation: 6 = 3 + 3, 3  3 = 9.\r\nprint(Solution().integerBreak(7), 12)  # Explanation: 7 = 3 + 4, 3  4 = 12; 2 = 2 + 2 + 3, 2 x 2 x 3 = 12.\r\nprint(Solution().integerBreak(10), 36)  # Explanation: 10 = 3 + 3 + 4, 3  3  4 = 36.\r\nprint(Solution().integerBreak(24), 6561)  # tle testcase", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-02-21T10:20:13.629Z", "updated_at": "2025-02-21T10:20:13.653Z"}}, {"model": "python_problems.solution", "pk": 479, "fields": {"problem": 249, "language": 2, "owner": 3, "solution": "* O(n2), O(n)\r\n * dp, top-down with memoization as hash map\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar integerBreak = function (n) {\r\n  const memo = new Map([[0, 1]]);  // {number: product}  maximum product for current number\r\n\r\n  var dfs = (index, isFirst) => {\r\n    if (memo.has(index)) {\r\n      return memo.get(index)\r\n    }\r\n\r\n    let maxNumber = 0;\r\n\r\n    for (let number = 1; number < index + Boolean(!isFirst); number++) {\r\n      maxNumber = Math.max(maxNumber, (number * dfs(index - number, false)))\r\n    }\r\n\r\n    memo.set(index, maxNumber);\r\n    return memo.get(index)\r\n  \r\n  }\r\n  return dfs(n, true)\r\n};", "testcase": "console.log(integerBreak(2), 1)  // Explanation: 2 = 1 + 1, 1  1 = 1.\r\nconsole.log(integerBreak(3), 2)  // Explanation: 3 = 1 + 2, 1  2 = 2.\r\nconsole.log(integerBreak(4), 4)  // Explanation: 4 = 2 + 2, 2  2 = 4.\r\nconsole.log(integerBreak(5), 6)  // Explanation: 5 = 2 + 3, 2  3 = 6.\r\nconsole.log(integerBreak(6), 9)  // Explanation: 6 = 3 + 3, 3  3 = 9.\r\nconsole.log(integerBreak(7), 12)  // Explanation: 7 = 3 + 4, 3  4 = 12; 2 = 2 + 2 + 3, 2 x 2 x 3 = 12.\r\nconsole.log(integerBreak(10), 36)  // Explanation: 10 = 3 + 3 + 4, 3  3  4 = 36.\r\nconsole.log(integerBreak(24), 6561)  // tle testcase", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-02-21T10:20:57.967Z", "updated_at": "2025-02-21T10:20:57.988Z"}}, {"model": "python_problems.solution", "pk": 480, "fields": {"problem": 250, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n[1, 3, 5, 4, 7]\r\n[1, 1]      [[LIS lengths, frequency]]\r\n   [2, 1]\r\n      [3, 1]\r\n         [3, 1]\r\n            [4, 2]\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def findNumberOfLIS(self, numbers: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [[1, 1] for _ in range(len(numbers))]  # [[LIS lengths, frequency]]\r\n\r\n        for right in range(len(numbers)):\r\n            for left in range(right):\r\n                if numbers[left] < numbers[right]:  # if right number is greater\r\n                    if cache[left][0] + 1 > cache[right][0]:  # longer LIS\r\n                        cache[right] = [cache[left][0] + 1,  # update LIS length\r\n                                        cache[left][1]]  # carry frequencies to new LIS\r\n                    elif cache[left][0] + 1 == cache[right][0]:  # same length LIS                   \r\n                        cache[right] = [cache[right][0], \r\n                                        cache[right][1] + cache[left][1]]  # update LIS frequency\r\n\r\n        # Travrse through cache and gather max frequencies.\r\n        max_lis_length = 0\r\n        for lis_length, frequency in cache:\r\n            if lis_length > max_lis_length:\r\n                max_lis_length = lis_length\r\n                max_frequency = frequency\r\n            elif lis_length == max_lis_length:\r\n               max_frequency += frequency\r\n\r\n        return max_frequency", "testcase": "print(Solution().findNumberOfLIS([1, 3, 5, 4]), 2)  # [1, 3, 4] and [1, 3, 5]\r\nprint(Solution().findNumberOfLIS([1, 3, 5, 4, 7]), 2)  # [1, 3, 4, 7] and [1, 3, 5, 7]\r\nprint(Solution().findNumberOfLIS([2, 2, 2, 2, 2]), 5)  # [2] * 5\r\nprint(Solution().findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]), 3)  # [1, 2, 3, 4, 7], [1, 2, 3, 5, 7], [1, 2, 4, 5, 7]\r\nprint(Solution().findNumberOfLIS([1, 1, 1, 2, 2, 2, 3, 3, 3]), 27)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-02-22T07:59:04.964Z", "updated_at": "2025-02-22T08:01:01.980Z"}}, {"model": "python_problems.solution", "pk": 481, "fields": {"problem": 250, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(n)\r\n * dp, bottom-up\r\n * @param {number[]} numbers\r\n * @return {number}\r\n */\r\nvar findNumberOfLIS = function (numbers) {\r\n  const cache = Array.from({ length: numbers.length }, () => [1, 1]);\r\n\r\n  for (let right = 0; right < numbers.length; right++) {\r\n    for (let left = 0; left < right; left++) {\r\n      if (numbers[left] < numbers[right]) {\r\n        if (cache[left][0] + 1 > cache[right][0]) {\r\n          cache[right] = [cache[left][0] + 1, cache[left][1]]\r\n        } else if (cache[left][0] + 1 == cache[right][0]) {\r\n          cache[right] = [cache[right][0], cache[right][1] + cache[left][1]];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  let maxLISLength = 0;\r\n  let maxFrequency = 0;\r\n  for (let [lis_length, frequency] of cache) {\r\n    if (lis_length > maxLISLength) {\r\n      maxLISLength = lis_length;\r\n      maxFrequency = frequency;\r\n    }\r\n    else if (lis_length == maxLISLength) {\r\n      maxFrequency += frequency;\r\n    }\r\n  }\r\n  return maxFrequency\r\n};", "testcase": "console.log(findNumberOfLIS([1, 3, 5, 4]), 2)  // [1, 3, 4] and [1, 3, 5]\r\nconsole.log(findNumberOfLIS([1, 3, 5, 4, 7]), 2)  // [1, 3, 4, 7] and [1, 3, 5, 7]\r\nconsole.log(findNumberOfLIS([2, 2, 2, 2, 2]), 5)  // [2] * 5\r\nconsole.log(findNumberOfLIS([1, 2, 4, 3, 5, 4, 7, 2]), 3)  // [1, 2, 3, 4, 7], [1, 2, 3, 5, 7], [1, 2, 4, 5, 7]\r\nconsole.log(findNumberOfLIS([1, 1, 1, 2, 2, 2, 3, 3, 3]), 27)", "time_complexity": 3, "space_complexity": 2, "created_at": "2025-02-22T07:59:45.502Z", "updated_at": "2025-02-22T07:59:45.528Z"}}, {"model": "python_problems.solution", "pk": 482, "fields": {"problem": 251, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n[1, 4, 2]\r\n |    \\\\\r\n[1, 2, 4]\r\n[1, 2], [1, 4]\r\n\r\n[2,  5, 1, 2, 5]\r\n     |    \\   |\r\n[10, 5, 2, 1, 5, 2]\r\n[2, 5, 2], [5, 1, 5], [5, 1, 2]\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def maxUncrossedLines(self, numbers_1: list[int], numbers_2: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2), O(n2)\r\n        dp, bottom-up\r\n        reversed iteration\r\n        \"\"\"\r\n        cache = [[0] * (len(numbers_2) + 1)\r\n                for _ in range((len(numbers_1) + 1))]  # [(index_1, index_2): number of connections]\r\n\r\n        for index_1 in reversed(range(len(numbers_1))):\r\n            for index_2 in reversed(range(len(numbers_2))):\r\n                if numbers_1[index_1] == numbers_2[index_2]:\r\n                    cache[index_1][index_2] = cache[index_1 + 1][index_2 + 1] + 1\r\n                else:\r\n                    cache[index_1][index_2] = max(cache[index_1 + 1][index_2], \r\n                                                  cache[index_1][index_2 + 1])\r\n                \r\n        return cache[0][0]\r\n\r\n\r\nclass Solution:\r\n    def maxUncrossedLines(self, numbers_1: list[int], numbers_2: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2), O(n2)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        cache = [[0] * (len(numbers_2) + 1)\r\n                for _ in range((len(numbers_1) + 1))]  # [(index_1, index_2): number of connections]\r\n\r\n        for index_1 in range(len(numbers_1)):\r\n            for index_2 in range(len(numbers_2)):\r\n                if numbers_1[index_1] == numbers_2[index_2]:\r\n                    cache[index_1 + 1][index_2 + 1] = cache[index_1][index_2] + 1\r\n                else:\r\n                    cache[index_1 + 1][index_2 + 1] = max(cache[index_1 + 1][index_2], \r\n                                                          cache[index_1][index_2 + 1])\r\n        \r\n        return cache[len(numbers_1)][len(numbers_2)]\r\n\r\n\r\nclass Solution:\r\n    def maxUncrossedLines(self, numbers_1: list[int], numbers_2: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2), O(n2)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        cache = {}  # {(index_1, index_2): number of connections}\r\n\r\n        def dfs(index_1, index_2):\r\n            if (index_1 == len(numbers_1) or\r\n                    index_2 == len(numbers_2)):\r\n                return 0\r\n            elif (index_1, index_2) in cache:\r\n                return cache[(index_1, index_2)]\r\n\r\n            if numbers_1[index_1] == numbers_2[index_2]:\r\n                cache[(index_1, index_2)] = 1 + dfs(index_1 + 1, index_2 + 1)\r\n            else:\r\n                cache[(index_1, index_2)] = max(dfs(index_1 + 1, index_2), \r\n                                               dfs(index_1, index_2 + 1))\r\n            \r\n            return cache[(index_1, index_2)]\r\n\r\n        return dfs(0, 0)\r\n\r\n\r\nclass Solution:\r\n    def maxUncrossedLines(self, numbers_1: list[int], numbers_2: list[int]) -> int:\r\n        \"\"\"\r\n        O(n2), O(n2)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [[-1] * len(numbers_2) \r\n                for _ in range(len(numbers_1))]  # [(index_1, index_2): number of connections]\r\n\r\n        def dfs(index_1, index_2):\r\n            if (index_1 == len(numbers_1) or\r\n                    index_2 == len(numbers_2)):\r\n                return 0\r\n            elif memo[index_1][index_2] != -1:\r\n                return memo[index_1][index_2]\r\n\r\n            if numbers_1[index_1] == numbers_2[index_2]:\r\n                memo[index_1][index_2] = 1 + dfs(index_1 + 1, index_2 + 1)\r\n            else:\r\n                memo[index_1][index_2] = max(dfs(index_1 + 1, index_2), \r\n                                               dfs(index_1, index_2 + 1))\r\n            \r\n            return memo[index_1][index_2]\r\n\r\n        return dfs(0, 0)\r\n\r\n\r\nclass Solution:\r\n    def maxUncrossedLines(self, numbers_1: list[int], numbers_2: list[int]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        def dfs(index_1, index_2):\r\n            if (index_1 == len(numbers_1) or\r\n                    index_2 == len(numbers_2)):\r\n                return 0\r\n\r\n            if numbers_1[index_1] == numbers_2[index_2]:\r\n                return 1 + dfs(index_1 + 1, index_2 + 1)\r\n            else:\r\n                return max(dfs(index_1 + 1, index_2), \r\n                           dfs(index_1, index_2 + 1))\r\n\r\n        return dfs(0, 0)", "testcase": "print(Solution().maxUncrossedLines([1, 4, 2], [1, 2, 4]), 2)\r\nprint(Solution().maxUncrossedLines([2, 5, 1, 2, 5], [10, 5, 2, 1, 5, 2]), 3)\r\nprint(Solution().maxUncrossedLines([1, 3, 7, 1, 7, 5], [1, 9, 2, 5, 1]), 2)\r\nprint(Solution().maxUncrossedLines([4,1,2,5,1,5,3,4,1,5], [3,1,1,3,2,5,2,4,1,3,2,2,5,5,3,5,5,1,2,1]), 7)\r\nprint(Solution().maxUncrossedLines([5,1,2,5,1,2,2,3,1,1,1,1,1,3,1], [2,5,1,3,4,5,5,2,2,4,5,2,2,3,1,4,5,3,2,4,5,2,4,4,2,2,2,1,3,1]), 11)", "time_complexity": 3, "space_complexity": 3, "created_at": "2025-02-23T07:19:27.929Z", "updated_at": "2025-02-23T07:19:27.960Z"}}, {"model": "python_problems.solution", "pk": 483, "fields": {"problem": 251, "language": 2, "owner": 3, "solution": "/**\r\n * O(n2), O(n2)\r\n * dp, bottom-up\r\n * reversed iteration\r\n * @param {number[]} numbers_1\r\n * @param {number[]} numbers_2\r\n * @return {number}\r\n */\r\nvar maxUncrossedLines = function (numbers_1, numbers_2) {\r\n  const cache = Array.from({ length: numbers_1.length + 1 }, () => Array(numbers_2.length + 1).fill(0));\r\n\r\n  for (let index_1 = numbers_1.length - 1; index_1 >= 0; index_1--) {\r\n    for (let index_2 = numbers_2.length - 1; index_2 >= 0; index_2--) {\r\n      if (numbers_1[index_1] === numbers_2[index_2]) {\r\n        cache[index_1][index_2] = cache[index_1 + 1][index_2 + 1] + 1;\r\n      } else {\r\n        cache[index_1][index_2] =\r\n          Math.max(\r\n            cache[index_1 + 1][index_2],\r\n            cache[index_1][index_2 + 1]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return cache[0][0]\r\n};\r\n\r\n\r\n/**\r\n * O(n2), O(n2)\r\n * dp, top-down with memoization as list\r\n * @param {number[]} numbers_1\r\n * @param {number[]} numbers_2\r\n * @return {number}\r\n */\r\nvar maxUncrossedLines = function (numbers_1, numbers_2) {\r\n  const memo = Array.from({ length: numbers_1.length + 1 }, () => Array(numbers_2.length + 1).fill(-1));\r\n\r\n  var dfs = (index_1, index_2) => {\r\n    if (\r\n      index_1 === numbers_1.length ||\r\n      index_2 === numbers_2.length\r\n    ) {\r\n      return 0\r\n    } else if (memo[index_1][index_2] != -1) {\r\n      return memo[index_1][index_2]\r\n    }\r\n\r\n    if (numbers_1[index_1] == numbers_2[index_2]) {\r\n      memo[index_1][index_2] = 1 + dfs(index_1 + 1, index_2 + 1);\r\n    } else {\r\n      memo[index_1][index_2] = \r\n      Math.max(\r\n        dfs(index_1 + 1, index_2),\r\n        dfs(index_1, index_2 + 1));\r\n    }\r\n\r\n    return memo[index_1][index_2]\r\n  }\r\n  return dfs(0, 0)\r\n};\r\n\r\n\r\n/**\r\n * O(n2), O(n2)\r\n * dp, top-down with memoization as hash map\r\n * @param {number[]} numbers_1\r\n * @param {number[]} numbers_2\r\n * @return {number}\r\n */\r\nvar maxUncrossedLines = function (numbers_1, numbers_2) {\r\n  const memo = new Map();\r\n\r\n  var dfs = (index_1, index_2) => {\r\n    if (\r\n      index_1 === numbers_1.length ||\r\n      index_2 === numbers_2.length\r\n    ) {\r\n      return 0\r\n    } else if (memo.has(`${index_1},${index_2}`)) {\r\n      return memo.get(`${index_1},${index_2}`)\r\n    }\r\n\r\n    if (numbers_1[index_1] == numbers_2[index_2]) {\r\n      memo.set(`${index_1},${index_2}`, 1 + dfs(index_1 + 1, index_2 + 1));\r\n    } else {\r\n      memo.set(\r\n        `${index_1},${index_2}`,\r\n        Math.max(\r\n          dfs(index_1 + 1, index_2),\r\n          dfs(index_1, index_2 + 1)\r\n        )\r\n      );\r\n    }\r\n\r\n    return memo.get(`${index_1},${index_2}`)\r\n  }\r\n  return dfs(0, 0)\r\n};", "testcase": "console.log(maxUncrossedLines([1, 4, 2], [1, 2, 4]), 2)\r\nconsole.log(maxUncrossedLines([2, 5, 1, 2, 5], [10, 5, 2, 1, 5, 2]), 3)\r\nconsole.log(maxUncrossedLines([1, 3, 7, 1, 7, 5], [1, 9, 2, 5, 1]), 2)\r\nconsole.log(maxUncrossedLines([4, 1, 2, 5, 1, 5, 3, 4, 1, 5], [3, 1, 1, 3, 2, 5, 2, 4, 1, 3, 2, 2, 5, 5, 3, 5, 5, 1, 2, 1]), 7)\r\nconsole.log(maxUncrossedLines([5, 1, 2, 5, 1, 2, 2, 3, 1, 1, 1, 1, 1, 3, 1], [2, 5, 1, 3, 4, 5, 5, 2, 2, 4, 5, 2, 2, 3, 1, 4, 5, 3, 2, 4, 5, 2, 4, 4, 2, 2, 2, 1, 3, 1]), 11)", "time_complexity": 3, "space_complexity": 3, "created_at": "2025-02-23T07:47:10.115Z", "updated_at": "2025-02-23T08:07:32.030Z"}}, {"model": "python_problems.solution", "pk": 484, "fields": {"problem": 252, "language": 1, "owner": 3, "solution": "class Solution:\r\n    def mostPoints(self, questions: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up with tabulation as hash map\r\n        \"\"\"\r\n        cache = {}  # {question: maximum points cumulated}\r\n    \r\n        for index in reversed(range(len(questions))):\r\n            cache[index] = max(\r\n                questions[index][0] + cache.get(index + 1 + questions[index][1], 0),  # solve question\r\n                cache.get(index + 1, 0)  # skip question\r\n            )\r\n        \r\n        return cache.get(0)\r\n\r\n\r\nclass Solution:\r\n    def mostPoints(self, questions: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        memo = {len(questions): 0}  # {question: maximum points cumulated}\r\n\r\n        def dfs(index):\r\n            if index >= len(questions):\r\n                return 0\r\n            elif index in memo:\r\n                return memo[index]\r\n            \r\n\r\n            memo[index] = max(\r\n                questions[index][0] + dfs(index + 1 + questions[index][1]),  # solve question\r\n                dfs(index + 1)  # skip question\r\n            )\r\n            return memo[index]\r\n        \r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def mostPoints(self, questions: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as list\r\n        \"\"\"\r\n        memo = [-1] * (len(questions) + 1)  # [question: maximum points cumulated]\r\n        memo[len(questions)]\r\n\r\n        def dfs(index):\r\n            if index >= len(questions):\r\n                return 0\r\n            elif memo[index] != -1:\r\n                return memo[index]\r\n            \r\n\r\n            memo[index] = max(\r\n                questions[index][0] + dfs(index + 1 + questions[index][1]),  # solve question\r\n                dfs(index + 1)  # skip question\r\n            )\r\n            return memo[index]\r\n        \r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def mostPoints(self, questions: list[list[int]]) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n\r\n        def dfs(index):\r\n            if index >= len(questions):\r\n                return 0\r\n            \r\n            return max(\r\n                questions[index][0] + dfs(index + 1 + questions[index][1]),  # solve question\r\n                dfs(index + 1)  # skip question\r\n            )\r\n\r\n        return dfs(0)", "testcase": "print(Solution().mostPoints([[3, 2], [4, 3], [4, 4], [2, 5]]), 5)\r\nprint(Solution().mostPoints([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]), 7)\r\nprint(Solution().mostPoints([[72,5],[36,5],[95,5],[50,1],[62,1],[14,3],[72,5],[86,2],[43,3],[51,3],[14,1],[91,5],[47,4],[72,4],[63,5],[40,3],[68,1],[8,3],[84,5],[7,5],[40,1],[35,3],[66,2],[39,5],[40,1],[92,3],[67,5],[34,3],[84,4],[75,5],[6,1],[71,3],[77,3],[25,3],[53,3],[32,3],[88,5],[18,2],[21,3],[78,2],[69,5],[45,4],[94,2],[70,1],[85,2],[7,2],[68,4],[71,4],[57,2],[12,5],[53,5],[51,3],[46,1],[28,3]]), 845)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-23T11:13:14.936Z", "updated_at": "2025-02-23T11:13:14.962Z"}}, {"model": "python_problems.solution", "pk": 485, "fields": {"problem": 252, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * dp, bottom-up with tabulation as hash map\r\n * @param {number[][]} questions\r\n * @return {number}\r\n */\r\nvar mostPoints = function (questions) {\r\n  const cache = new Map();\r\n\r\n  for (let index = questions.length - 1; index > -1; index--) {\r\n    cache.set(index,\r\n      Math.max(\r\n        questions[index][0] + (cache.get(index + 1 + questions[index][1]) ?? 0),\r\n        cache.get(index + 1) ?? 0\r\n      ));\r\n  }\r\n\r\n  return cache.get(0)\r\n};", "testcase": "console.log(mostPoints([[3, 2], [4, 3], [4, 4], [2, 5]]), 5)\r\nconsole.log(mostPoints([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]), 7)\r\nconsole.log(mostPoints([[72, 5], [36, 5], [95, 5], [50, 1], [62, 1], [14, 3], [72, 5], [86, 2], [43, 3], [51, 3], [14, 1], [91, 5], [47, 4], [72, 4], [63, 5], [40, 3], [68, 1], [8, 3], [84, 5], [7, 5], [40, 1], [35, 3], [66, 2], [39, 5], [40, 1], [92, 3], [67, 5], [34, 3], [84, 4], [75, 5], [6, 1], [71, 3], [77, 3], [25, 3], [53, 3], [32, 3], [88, 5], [18, 2], [21, 3], [78, 2], [69, 5], [45, 4], [94, 2], [70, 1], [85, 2], [7, 2], [68, 4], [71, 4], [57, 2], [12, 5], [53, 5], [51, 3], [46, 1], [28, 3]]), 845)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-23T11:40:44.888Z", "updated_at": "2025-02-23T11:40:44.916Z"}}, {"model": "python_problems.solution", "pk": 486, "fields": {"problem": 253, "language": 1, "owner": 3, "solution": "\"\"\"\r\ndraft\r\n[1, 1, 1, 1]\r\n\"0\", \"1\"\r\n\r\n[1, 2, 1, 1]\r\n\"0\", \"1\", \"00\", \"01\", \"10\", \"11\"\r\n\r\n[2, 2, 1, 1]\r\n\"00\", \"01\", \"10\", \"11\"\r\n2**2 = 4\r\n\r\n[3, 3, 1, 1]\r\n2**3 + 2**2 + 2**1 = 8 + 4 + 2 = 14\r\n\r\n[2, 3, 1, 2]\r\n\"00\", \"11\", \"000\", \"110\", and \"011\"\r\n\"\"\"\r\n\r\n\r\nclass Solution:\r\n    def countGoodStrings(self, low: int, high: int, zero_times: int, one_times: int) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, bottom-up\r\n        \"\"\"\r\n        mod = 10 ** 9 + 7\r\n        cache = {}  # memo[string length]: store the number of ways to make a good string of length index\r\n        cache[0] = 1  # one way to create zero length (empty) string\r\n\r\n        for index in range(1, high + 1):\r\n            cache[index] = (cache.get(index - zero_times, 0) + \r\n                            cache.get(index - one_times, 0)) % mod\r\n        \r\n        return sum(cache[index]\r\n                   for index in range(low, high + 1)) % mod\r\n\r\n\r\nclass Solution:\r\n    def countGoodStrings(self, low: int, high: int, zero_times: int, one_times: int) -> int:\r\n        \"\"\"\r\n        O(n), O(n)\r\n        dp, top-down with memoization as hash map\r\n        \"\"\"\r\n        mod = 10 ** 9 + 7\r\n        memo = {}  # represents the total number of valid good strings that can be constructed starting from length index and going up to high\r\n\r\n        def dfs(index: int) -> int:\r\n            if index > high:\r\n                return 0\r\n            elif index in memo:\r\n                return memo[index]\r\n            \r\n            current_node_count = 1 if index >= low else 0\r\n            zero_branch = dfs(index + zero_times)\r\n            one_branch = dfs(index + one_times)\r\n            \r\n            memo[index] = (current_node_count + zero_branch + one_branch) % mod\r\n            return memo[index]\r\n\r\n        return dfs(0)\r\n\r\n\r\nclass Solution:\r\n    def countGoodStrings(self, low: int, high: int, zero_times: int, one_times: int) -> int:\r\n        \"\"\"\r\n        O(2^n), O(n)\r\n        brute force, tle\r\n        \"\"\"\r\n        mod = 10 ** 9 + 7\r\n\r\n        def dfs(index: int) -> int:\r\n            if index > high:\r\n                return 0\r\n            \r\n            current_node_count = 1 if index >= low else 0\r\n            zero_branch = dfs(index + zero_times)\r\n            one_branch = dfs(index + one_times)\r\n            \r\n            return (current_node_count + zero_branch + one_branch) % mod\r\n\r\n        return dfs(0)", "testcase": "print(Solution().countGoodStrings(1, 1, 1, 1), 2)\r\nprint(Solution().countGoodStrings(1, 2, 1, 1), 6)\r\nprint(Solution().countGoodStrings(2, 2, 1, 1), 4)\r\nprint(Solution().countGoodStrings(1, 3, 1, 1), 14)\r\nprint(Solution().countGoodStrings(3, 3, 1, 1), 8)\r\nprint(Solution().countGoodStrings(2, 3, 1, 2), 5)\r\nprint(Solution().countGoodStrings(200, 200, 10, 1), 764262396)  # tle\r\nprint(Solution().countGoodStrings(1, 100000, 1, 1), 215447031)  # RecursionError: maximum recursion depth exceeded", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-25T13:13:13.743Z", "updated_at": "2025-02-25T17:44:31.606Z"}}, {"model": "python_problems.solution", "pk": 487, "fields": {"problem": 253, "language": 2, "owner": 3, "solution": "/**\r\n * O(n), O(n)\r\n * dp, bottom-up\r\n * @param {number} low\r\n * @param {number} high\r\n * @param {number} zero\r\n * @param {number} one\r\n * @return {number}\r\n */\r\nvar countGoodStrings = function (low, high, zero, one) {\r\n  const mod = 10 ** 9 + 7;\r\n  const cache = new Map([[0, 1]]);\r\n\r\n  for (let index = 1; index <= high; index++) {\r\n    const value = (\r\n      (cache.get(index - zero) ?? 0) + \r\n      (cache.get(index - one) ?? 0)) % mod;\r\n    cache.set(index, value);\r\n  }\r\n\r\n  let counter = 0;\r\n  for (let index = low; index <= high; index++) {\r\n    counter += cache.get(index);\r\n  }\r\n\r\n  return counter % mod\r\n};", "testcase": "console.log(countGoodStrings(1, 1, 1, 1), 2)\r\nconsole.log(countGoodStrings(1, 2, 1, 1), 6)\r\nconsole.log(countGoodStrings(2, 2, 1, 1), 4)\r\nconsole.log(countGoodStrings(1, 3, 1, 1), 14)\r\nconsole.log(countGoodStrings(3, 3, 1, 1), 8)\r\nconsole.log(countGoodStrings(2, 3, 1, 2), 5)\r\nconsole.log(countGoodStrings(200, 200, 10, 1), 764262396)  // tle", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-02-25T15:29:52.206Z", "updated_at": "2025-02-25T15:29:52.235Z"}}, {"model": "python_problems.solution", "pk": 488, "fields": {"problem": 37, "language": 2, "owner": 3, "solution": "_\\/\\|/_\r\nc'///\\/\r\n  \" \"", "testcase": "(Solution().hedgehog(\"needle\"), \"haystack\")", "time_complexity": 1, "space_complexity": 1, "created_at": "2025-03-08T09:16:14.843Z", "updated_at": "2025-03-09T12:48:49.258Z"}}, {"model": "python_problems.solution", "pk": 489, "fields": {"problem": 11, "language": 6, "owner": 3, "solution": "import java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n/**\r\n * This class provides a solution to check if an array contains duplicate\r\n * elements.\r\n */\r\npublic class Solution {\r\n  /**\r\n   * Checks if the given array contains any duplicate elements.\r\n   *\r\n   * @param numbers The array of integers to check for duplicates.\r\n   * @return {@code true} if the array contains duplicates, {@code false}\r\n   *         otherwise.\r\n   */\r\n  public boolean containsDuplicate(int[] numbers) {\r\n    Set<Integer> uniqueNumbers = new HashSet<>();\r\n    for (int number : numbers) {\r\n      if (uniqueNumbers.contains(number)) {\r\n        return true;\r\n      } else {\r\n        uniqueNumbers.add(number);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public static void main(String[] agrs) {\r\n    Solution solution = new Solution();\r\n    int[] numbers = { 1, 2, 3, 1 };\r\n    boolean result = solution.containsDuplicate(numbers);\r\n    System.out.println(result);\r\n  }\r\n}", "testcase": "(containsDuplicate([1, 2, 3, 1]), true)\r\n(containsDuplicate([1, 2, 3]), false)\r\n(containsDuplicate([1, 2, 3, 4]), false)\r\n(containsDuplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]), true)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-03-14T15:49:00.064Z", "updated_at": "2025-03-14T15:49:00.134Z"}}, {"model": "python_problems.solution", "pk": 490, "fields": {"problem": 11, "language": 7, "owner": 3, "solution": "class Solution {\r\npublic:\r\n    bool containsDuplicate(vector<int>& numbers) {\r\n        set<int> uniqueNumbers;\r\n        for (int number : numbers) {\r\n            if (uniqueNumbers.contains(number)) {\r\n                return true;\r\n            } else {\r\n                uniqueNumbers.insert(number);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n};", "testcase": "(containsDuplicate([1, 2, 3, 1]), true)\r\n(containsDuplicate([1, 2, 3]), false)\r\n(containsDuplicate([1, 2, 3, 4]), false)\r\n(containsDuplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]), true)", "time_complexity": 2, "space_complexity": 2, "created_at": "2025-03-16T14:16:43.439Z", "updated_at": "2025-03-16T14:16:43.470Z"}}, {"model": "sql_problems.difficulty", "pk": 1, "fields": {"name": "Easy"}}, {"model": "sql_problems.difficulty", "pk": 2, "fields": {"name": "Medium"}}, {"model": "sql_problems.difficulty", "pk": 3, "fields": {"name": "Hard"}}, {"model": "sql_problems.problem", "pk": 1, "fields": {"title": "Combine Two Tables", "difficulty": 1, "url": "https://leetcode.com/problems/combine-two-tables/", "description": "Table: Person\r\n\r\n+-------------+---------+\r\n| Column Name | Type    |\r\n+-------------+---------+\r\n| personId    | int     |\r\n| lastName    | varchar |\r\n| firstName   | varchar |\r\n+-------------+---------+\r\npersonId is the primary key (column with unique values) for this table.\r\nThis table contains information about the ID of some persons and their first and last names.\r\n \r\n\r\nTable: Address\r\n\r\n+-------------+---------+\r\n| Column Name | Type    |\r\n+-------------+---------+\r\n| addressId   | int     |\r\n| personId    | int     |\r\n| city        | varchar |\r\n| state       | varchar |\r\n+-------------+---------+\r\naddressId is the primary key (column with unique values) for this table.\r\nEach row of this table contains information about the city and state of one person with ID = PersonId.\r\n \r\n\r\nWrite a solution to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, repo", "is_solved": false, "solution_my": "SELECT p.firstName, p.lastName, a.city, a.state\r\nFROM Person AS p\r\nLEFT JOIN Address AS a USING(personID)\r\n-- LEFT JOIN Address AS a ON a.personID = p.personID", "solution_pd": "import pandas as pd\r\n\r\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\r\n    sol_df = pd.merge(person, address, how=\"left\", on=[\"personId\"])\r\n    return sol_df[[\"firstName\", \"lastName\", \"city\", \"state\"]]\r\n    # return person.merge(address, how=\"left\", on=[\"personId\"])[[\"firstName\", \"lastName\", \"city\", \"state\"]]", "testcase": "Input: \r\nPerson table:\r\n+----------+----------+-----------+\r\n| personId | lastName | firstName |\r\n+----------+----------+-----------+\r\n| 1        | Wang     | Allen     |\r\n| 2        | Alice    | Bob       |\r\n+----------+----------+-----------+\r\nAddress table:\r\n+-----------+----------+---------------+------------+\r\n| addressId | personId | city          | state      |\r\n+-----------+----------+---------------+------------+\r\n| 1         | 2        | New York City | New York   |\r\n| 2         | 3        | Leetcode      | California |\r\n+-----------+----------+---------------+------------+\r\n\r\nOutput: \r\n+-----------+----------+---------------+----------+\r\n| firstName | lastName | city          | state    |\r\n+-----------+----------+---------------+----------+\r\n| Allen     | Wang     | Null          | Null     |\r\n| Bob       | Alice    | New York City | New York |\r\n+-----------+----------+---------------+----------+", "tags": [1]}}, {"model": "sql_problems.tag", "pk": 1, "fields": {"name": "Database"}}, {"model": "forums.bugforum", "pk": 1, "fields": {"title": "Duplicated tag :(", "text": "None", "owner": 4, "created_at": "2024-06-10T18:53:15.406Z", "updated_at": "2024-06-10T18:53:15.419Z"}}, {"model": "forums.bugcomment", "pk": 1, "fields": {"text": "Fixed. Tag is now unique.", "forum": 1, "owner": 3, "created_at": "2024-06-11T19:30:02.151Z", "updated_at": "2024-06-11T19:30:02.151Z"}}, {"model": "forums.featureforum", "pk": 1, "fields": {"title": "Remove duplicated tags :(", "text": "None", "owner": 4, "created_at": "2024-06-10T18:53:44.018Z", "updated_at": "2024-06-10T18:53:44.031Z"}}, {"model": "forums.featurecomment", "pk": 1, "fields": {"text": "Fixed. Tag is now unique.", "forum": 1, "owner": 3, "created_at": "2024-06-11T19:30:46.638Z", "updated_at": "2024-06-11T19:30:46.638Z"}}]